Using verible-verilog-format version v0.0-520-g650c6cc
Commit	2020-08-06 11:55:13 -0700
Built	2020-08-06T19:47:56Z
hw/ip/usb_fs_nb_pe/rtl/usb_fs_tx_mux.sv: Already formatted, no change.
hw/ip/usb_fs_nb_pe/rtl/usb_consts_pkg.sv: Already formatted, no change.
hw/ip/usb_fs_nb_pe/rtl/usb_fs_nb_pe.sv: Already formatted, no change.
hw/ip/rv_core_ibex/rtl/rv_core_ibex.sv: Already formatted, no change.
hw/ip/usb_fs_nb_pe/rtl/usb_fs_nb_in_pe.sv: Already formatted, no change.
hw/ip/rv_core_ibex/dv/sva/rv_core_ibex_bind.sv: Already formatted, no change.
hw/ip/usb_fs_nb_pe/rtl/usb_fs_nb_out_pe.sv: Already formatted, no change.
hw/ip/usb_fs_nb_pe/rtl/usb_fs_tx.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_rom.sv: Already formatted, no change.
hw/ip/usb_fs_nb_pe/rtl/usb_fs_rx.sv: Re-formatted text does not match formatted text; formatting failed to converge!  Please file a bug.
Original: --lines: 
// Copyright lowRISC contributors.
// Copyright ETH Zurich.
// Copyright Luke Valenty (TinyFPGA project, https://github.com/tinyfpga/TinyFPGA-Bootloader).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

module usb_fs_rx (
  // A 48MHz clock is required to recover the clock from the incoming data.
  input  logic clk_i,
  input  logic rst_ni,
  input  logic link_reset_i,

  // EOP configuration
  input  logic cfg_eop_single_bit_i,

  // USB data+ and data- lines (synchronous)
  input  logic usb_d_i,
  input  logic usb_se0_i,

  // Transmit enable disables the receier
  input  logic tx_en_i,

  // pulse on every bit transition.
  output logic bit_strobe_o,

  // Pulse on beginning of new packet.
  output logic pkt_start_o,

  // Pulse on end of current packet.
  output logic pkt_end_o,

  // Most recent packet decoded.
  output logic [3:0]  pid_o,
  output logic [6:0]  addr_o,
  output logic [3:0]  endp_o,
  output logic [10:0] frame_num_o,

  // Pulse on valid data on rx_data.
  output logic rx_data_put_o,
  output logic [7:0] rx_data_o,

  // Most recent packet passes PID and CRC checks
  output logic valid_packet_o,

  // Error detection
  output logic crc_error_o,
  output logic pid_error_o,
  output logic bitstuff_error_o
);

  logic [6:0] bitstuff_history_q, bitstuff_history_d;
  logic       bitstuff_error;
  logic       bitstuff_error_q, bitstuff_error_d;

  //////////////////////
  // usb receive path //
  //////////////////////

  ///////////////////////////////////////
  // line state recovery state machine //
  ///////////////////////////////////////

  // The receive path doesn't currently use a differential reciever.  because of
  // this there is a chance that one of the differential pairs will appear to have
  // changed to the new state while the other is still in the old state.  the
  // following state machine detects transitions and waits an extra sampling clock
  // before decoding the state on the differential pair.  this transition period
  // will only ever last for one clock as long as there is no noise on the line.
  // if there is enough noise on the line then the data may be corrupted and the
  // packet will fail the data integrity checks.

  logic [2:0] line_state_q, line_state_d;
  localparam logic [2:0]  DT = 3'b100; // transition state
  localparam logic [2:0]  DJ = 3'b010; // J - idle line state
  // localparam logic [2:0]  DK = 3'b001; // K - inverse of J
  localparam logic [2:0] SE0 = 3'b000; // single-ended 0 - end of packet or detached
  // localparam logic [2:0] SE1 = 3'b011; // single-ended 1 - illegal

  // Mute the input if we're transmitting
  logic [1:0] dpair;
  always_comb begin : proc_dpair_mute
    if (tx_en_i) begin
      dpair = DJ[1:0]; // J
    end else begin
      dpair = (usb_se0_i) ? 2'b00 : {usb_d_i, ~usb_d_i};
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_line_state_q
    if (!rst_ni) begin
      line_state_q <= SE0;
    end else begin
      if (link_reset_i) begin
        line_state_q <= SE0;
      end else begin
        line_state_q <= line_state_d;
      end
    end
  end

  always_comb begin : proc_line_state_d
    // Default assignment
    line_state_d = line_state_q;

    if (line_state_q == DT) begin
      // if we are in a transition state, then we can sample the pair and
      // move to the next corresponding line state
      line_state_d = {1'b0, dpair};

    end else begin
      // if we are in a valid line state and the value of the pair changes,
      // then we need to move to the transition state
      if (dpair != line_state_q[1:0]) begin
        line_state_d = DT;
      end
    end
  end

  ////////////////////
  // clock recovery //
  ////////////////////

  // the DT state from the line state recovery state machine is used to align to
  // transmit clock.  the line state is sampled in the middle of the bit time.

  // example of signal relationships
  // -------------------------------
  // line_state        DT  DJ  DJ  DJ  DT  DK  DK  DK  DK  DK  DK  DT  DJ  DJ  DJ
  // line_state_valid  ________----____________----____________----________----____
  // bit_phase         0   0   1   2   3   0   1   2   3   0   1   2   0   1   2


  logic [1:0] bit_phase_q, bit_phase_d;
  logic line_state_valid;

  assign line_state_valid = (bit_phase_q == 2'd1);
  assign bit_strobe_o     = (bit_phase_q == 2'd2);

  // keep track of phase within each bit
  assign bit_phase_d = (line_state_q == DT) ? 0 : bit_phase_q + 1;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bit_phase_q
    if (!rst_ni) begin
      bit_phase_q <= 0;
    end else begin
      if (link_reset_i) begin
        bit_phase_q <= 0;
      end else begin
        bit_phase_q <= bit_phase_d;
      end
    end
  end


  //////////////////////
  // packet detection //
  //////////////////////

  // usb uses a sync to denote the beginning of a packet and two single-ended-0 to
  // denote the end of a packet.  this state machine recognizes the beginning and
  // end of packets for subsequent layers to process.

  logic [11:0] line_history_q, line_history_d;
  logic packet_valid_q, packet_valid_d;
  logic see_eop, packet_start, packet_end;

  assign packet_start = packet_valid_d & ~packet_valid_q;
  assign packet_end   = ~packet_valid_d & packet_valid_q;

  // EOP detection is configurable for 1/2 bit periods of SE0.
  // The standard (Table 7-7) mandates min = 82 ns = 1 bit period.
  // We also trigger an EOP on seeing a bitstuff error.
  assign see_eop = (cfg_eop_single_bit_i && line_history_q[1:0] == 2'b00)
    || (line_history_q[3:0] == 4'b0000) || bitstuff_error_q;

  always_comb begin : proc_packet_valid_d
    if (line_state_valid) begin
      // check for packet start: KJKJKK, we use the last 6 bits
      if (!packet_valid_q && line_history_q[11:0] == 12'b011001100101) begin
        packet_valid_d = 1;
      end

      // check for packet end: SE0 SE0
      else if (packet_valid_q && see_eop) begin
        packet_valid_d = 0;

      end else begin
        packet_valid_d = packet_valid_q;
      end
    end else begin
      packet_valid_d = packet_valid_q;
    end
  end

  // keep a history of the last two states on the line
  assign line_history_d = line_state_valid ? {line_history_q[9:0], line_state_q[1:0]} :
                                              line_history_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg_pkt_line
    if (!rst_ni) begin
      packet_valid_q <= 0;
      line_history_q <= 12'b101010101010; // all K
    end else begin
      if (link_reset_i) begin
        packet_valid_q <= 0;
        line_history_q <= 12'b101010101010; // all K
      end else begin
        packet_valid_q <= packet_valid_d;
        line_history_q <= line_history_d;
      end
    end
  end


  /////////////////
  // NRZI decode //
  /////////////////

  // in order to ensure there are enough bit transitions for a receiver to recover
  // the clock usb uses NRZI encoding.

  // https://en.wikipedia.org/wiki/Non-return-to-zero

  logic dvalid_raw;
  logic din;

  always_comb begin
    unique case (line_history_q[3:0])
      4'b0101 : din = 1;
      4'b0110 : din = 0;
      4'b1001 : din = 0;
      4'b1010 : din = 1;
      default : din = 0;
    endcase

    if (packet_valid_q && line_state_valid) begin
      unique case (line_history_q[3:0])
        4'b0101 : dvalid_raw = 1;
        4'b0110 : dvalid_raw = 1;
        4'b1001 : dvalid_raw = 1;
        4'b1010 : dvalid_raw = 1;
        default : dvalid_raw = 0;
      endcase
    end else begin
      dvalid_raw = 0;
    end
  end

  //////////////////////////////////////////////////////
  // Undo bit stuffing and detect bit stuffing errors //
  //////////////////////////////////////////////////////

  always_comb begin : proc_bitstuff_history_d
    if (packet_end) begin
      bitstuff_history_d = '0;
    end else if (dvalid_raw) begin
      bitstuff_history_d = {bitstuff_history_q[5:0], din};
    end else begin
      bitstuff_history_d = bitstuff_history_q;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_history_q
    if (!rst_ni) begin
      bitstuff_history_q <= 0;
    end else begin
      if (link_reset_i) begin
        bitstuff_history_q <= 0;
      end else begin
        bitstuff_history_q <= bitstuff_history_d;
      end
    end
  end

  logic dvalid;
  assign dvalid = dvalid_raw && !(bitstuff_history_q[5:0] == 6'b111111);

  // 7 consecutive ones should not be seen on the bus
  // USB spec, 7.1.9.1: "If the receiver sees seven
  // consecutive ones anywhere in the packet, then a bit stuffing error
  // has occurred and the packet should be ignored."
  assign bitstuff_error = bitstuff_history_q == 7'b1111111;

  // remember the bitstuff errors
  always_comb begin : proc_bistuff_error_d
    bitstuff_error_d = bitstuff_error_q;
    if (packet_start) begin
      bitstuff_error_d = 0;
    end else if (bitstuff_error && dvalid_raw) begin
      bitstuff_error_d = 1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_error_q
    if (!rst_ni) begin
      bitstuff_error_q <= 0;
    end else begin
      bitstuff_error_q <= bitstuff_error_d;
    end
  end

  assign bitstuff_error_o = bitstuff_error_q && packet_end;


  ////////////////////////
  // save and check pid //
  ////////////////////////

  // shift in the entire 8-bit pid with an additional 9th bit used as a sentinal.

  logic [8:0] full_pid_q, full_pid_d;
  logic pid_valid, pid_complete;

  assign pid_valid    = full_pid_q[4:1] == ~full_pid_q[8:5];
  assign pid_complete = full_pid_q[0];

  always_comb begin : proc_full_pid_d
    if (dvalid && !pid_complete) begin
      full_pid_d = {din, full_pid_q[8:1]};
    end else if (packet_start) begin
      full_pid_d = 9'b100000000;
    end else begin
      full_pid_d = full_pid_q;
    end
  end

  ////////////////
  // check crc5 //
  ////////////////
  logic [4:0] crc5_q, crc5_d;
  logic crc5_valid, crc5_invert;
  assign crc5_valid  = crc5_q == 5'b01100;
  assign crc5_invert = din ^ crc5_q[4];

  always_comb begin
    crc5_d = crc5_q; // default value

    if (packet_start) begin
      crc5_d = 5'b11111;
    end

    if (dvalid && pid_complete) begin
      crc5_d = {crc5_q[3:0], 1'b0} ^ ({5{crc5_invert}} & 5'b00101);
    end
  end


  /////////////////
  // check crc16 //
  /////////////////
  logic [15:0] crc16_q, crc16_d;
  logic crc16_valid, crc16_invert;

  assign crc16_valid  = crc16_q == 16'b1000000000001101;
  assign crc16_invert = din ^ crc16_q[15];

  always_comb begin
    crc16_d = crc16_q; // default value

    if (packet_start) begin
      crc16_d = 16'b1111111111111111;
    end

    if (dvalid && pid_complete) begin
      crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);
    end
  end


  ////////////////////////////
  // output control signals //
  ////////////////////////////
  logic pkt_is_token, pkt_is_data, pkt_is_handshake;
  assign pkt_is_token     = full_pid_q[2:1] == 2'b01;
  assign pkt_is_data      = full_pid_q[2:1] == 2'b11;
  assign pkt_is_handshake = full_pid_q[2:1] == 2'b10;


  // TODO: need to check for data packet babble
  assign valid_packet_o = pid_valid && !bitstuff_error_q &&
    ((pkt_is_handshake) ||
    (pkt_is_data && crc16_valid) ||
    (pkt_is_token && crc5_valid)
  );

  // Detect CRC errors
  assign crc_error_o = ((pkt_is_data && !crc16_valid) ||
    (pkt_is_token && !crc5_valid)) && packet_end;

  // Detect PID errors
  assign pid_error_o = !pid_valid && packet_end;

  logic [11:0] token_payload_q, token_payload_d;
  logic token_payload_done;

  assign token_payload_done = token_payload_q[0];

  logic [6:0] addr_q, addr_d;
  logic [3:0] endp_q, endp_d;
  logic [10:0] frame_num_q, frame_num_d;

  always_comb begin
    token_payload_d = token_payload_q; // default

    if (packet_start) begin
      token_payload_d = 12'b100000000000;
    end

    if (dvalid && pid_complete && pkt_is_token && !token_payload_done) begin
      token_payload_d = {din, token_payload_q[11:1]};
    end
  end

  always_comb begin
    // defaults
    addr_d      = addr_q;
    endp_d      = endp_q;
    frame_num_d = frame_num_q;

    if (token_payload_done && pkt_is_token) begin
      addr_d      = token_payload_q[7:1];
      endp_d      = token_payload_q[11:8];
      frame_num_d = token_payload_q[11:1];
    end
  end

  assign addr_o      = addr_q;
  assign endp_o      = endp_q;
  assign frame_num_o = frame_num_q;
  assign pid_o       = full_pid_q[4:1];

  assign pkt_start_o = packet_start;
  assign pkt_end_o   = packet_end;


  /////////////////////////////////
  // deserialize and output data //
  /////////////////////////////////
  //assign rx_data_put = dvalid && pid_complete && pkt_is_data;
  logic [8:0] rx_data_buffer_q, rx_data_buffer_d;
  logic rx_data_buffer_full;

  assign rx_data_buffer_full = rx_data_buffer_q[0];
  assign rx_data_put_o       = rx_data_buffer_full;
  assign rx_data_o           = rx_data_buffer_q[8:1];

  always_comb begin
    rx_data_buffer_d = rx_data_buffer_q; // default

    if (packet_start || rx_data_buffer_full) begin
      rx_data_buffer_d = 9'b100000000;
    end

    if (dvalid && pid_complete && pkt_is_data) begin
      rx_data_buffer_d = {din, rx_data_buffer_q[8:1]};
    end
  end


  ///////////////
  // Registers //
  ///////////////
  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_gp_regs
    if (!rst_ni) begin
      full_pid_q          <= 0;
      crc16_q             <= 0;
      crc5_q              <= 0;
      token_payload_q     <= 0;
      addr_q              <= 0;
      endp_q              <= 0;
      frame_num_q         <= 0;
      rx_data_buffer_q    <= 0;
    end else begin
      if (link_reset_i) begin
        full_pid_q          <= 0;
        crc16_q             <= 0;
        crc5_q              <= 0;
        token_payload_q     <= 0;
        addr_q              <= 0;
        endp_q              <= 0;
        frame_num_q         <= 0;
        rx_data_buffer_q    <= 0;
      end else begin
        full_pid_q          <= full_pid_d;
        crc16_q             <= crc16_d;
        crc5_q              <= crc5_d;
        token_payload_q     <= token_payload_d;
        addr_q              <= addr_d;
        endp_q              <= endp_d;
        frame_num_q         <= frame_num_d;
        rx_data_buffer_q    <= rx_data_buffer_d;
      end
    end
  end

endmodule // usb_fs_rx
Formatted:
// Copyright lowRISC contributors.
// Copyright ETH Zurich.
// Copyright Luke Valenty (TinyFPGA project, https://github.com/tinyfpga/TinyFPGA-Bootloader).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

module usb_fs_rx (
    // A 48MHz clock is required to recover the clock from the incoming data.
    input logic clk_i,
    input logic rst_ni,
    input logic link_reset_i,

    // EOP configuration
    input logic cfg_eop_single_bit_i,

    // USB data+ and data- lines (synchronous)
    input logic usb_d_i,
    input logic usb_se0_i,

    // Transmit enable disables the receier
    input logic tx_en_i,

    // pulse on every bit transition.
    output logic bit_strobe_o,

    // Pulse on beginning of new packet.
    output logic pkt_start_o,

    // Pulse on end of current packet.
    output logic pkt_end_o,

    // Most recent packet decoded.
    output logic [ 3:0] pid_o,
    output logic [ 6:0] addr_o,
    output logic [ 3:0] endp_o,
    output logic [10:0] frame_num_o,

    // Pulse on valid data on rx_data.
    output logic       rx_data_put_o,
    output logic [7:0] rx_data_o,

    // Most recent packet passes PID and CRC checks
    output logic valid_packet_o,

    // Error detection
    output logic crc_error_o,
    output logic pid_error_o,
    output logic bitstuff_error_o
);

  logic [6:0] bitstuff_history_q, bitstuff_history_d;
  logic bitstuff_error;
  logic bitstuff_error_q, bitstuff_error_d;

  //////////////////////
  // usb receive path //
  //////////////////////

  ///////////////////////////////////////
  // line state recovery state machine //
  ///////////////////////////////////////

  // The receive path doesn't currently use a differential reciever.  because of
  // this there is a chance that one of the differential pairs will appear to have
  // changed to the new state while the other is still in the old state.  the
  // following state machine detects transitions and waits an extra sampling clock
  // before decoding the state on the differential pair.  this transition period
  // will only ever last for one clock as long as there is no noise on the line.
  // if there is enough noise on the line then the data may be corrupted and the
  // packet will fail the data integrity checks.

  logic [2:0] line_state_q, line_state_d;
  localparam logic [2:0] DT = 3'b100;  // transition state
  localparam logic [2:0] DJ = 3'b010;  // J - idle line state
  // localparam logic [2:0]  DK = 3'b001; // K - inverse of J
  localparam logic [2:0] SE0 = 3'b000;  // single-ended 0 - end of packet or detached
  // localparam logic [2:0] SE1 = 3'b011; // single-ended 1 - illegal

  // Mute the input if we're transmitting
  logic [1:0] dpair;
  always_comb begin : proc_dpair_mute
    if (tx_en_i) begin
      dpair = DJ[1:0];  // J
    end else begin
      dpair = (usb_se0_i) ? 2'b00 : {usb_d_i, ~usb_d_i};
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_line_state_q
    if (!rst_ni) begin
      line_state_q <= SE0;
    end else begin
      if (link_reset_i) begin
        line_state_q <= SE0;
      end else begin
        line_state_q <= line_state_d;
      end
    end
  end

  always_comb begin : proc_line_state_d
    // Default assignment
    line_state_d = line_state_q;

    if (line_state_q == DT) begin
      // if we are in a transition state, then we can sample the pair and
      // move to the next corresponding line state
      line_state_d = {1'b0, dpair};

    end else begin
      // if we are in a valid line state and the value of the pair changes,
      // then we need to move to the transition state
      if (dpair != line_state_q[1:0]) begin
        line_state_d = DT;
      end
    end
  end

  ////////////////////
  // clock recovery //
  ////////////////////

  // the DT state from the line state recovery state machine is used to align to
  // transmit clock.  the line state is sampled in the middle of the bit time.

  // example of signal relationships
  // -------------------------------
  // line_state        DT  DJ  DJ  DJ  DT  DK  DK  DK  DK  DK  DK  DT  DJ  DJ  DJ
  // line_state_valid  ________----____________----____________----________----____
  // bit_phase         0   0   1   2   3   0   1   2   3   0   1   2   0   1   2


  logic [1:0] bit_phase_q, bit_phase_d;
  logic line_state_valid;

  assign line_state_valid = (bit_phase_q == 2'd1);
  assign bit_strobe_o = (bit_phase_q == 2'd2);

  // keep track of phase within each bit
  assign bit_phase_d = (line_state_q == DT) ? 0 : bit_phase_q + 1;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bit_phase_q
    if (!rst_ni) begin
      bit_phase_q <= 0;
    end else begin
      if (link_reset_i) begin
        bit_phase_q <= 0;
      end else begin
        bit_phase_q <= bit_phase_d;
      end
    end
  end


  //////////////////////
  // packet detection //
  //////////////////////

  // usb uses a sync to denote the beginning of a packet and two single-ended-0 to
  // denote the end of a packet.  this state machine recognizes the beginning and
  // end of packets for subsequent layers to process.

  logic [11:0] line_history_q, line_history_d;
  logic packet_valid_q, packet_valid_d;
  logic see_eop, packet_start, packet_end;

  assign packet_start = packet_valid_d & ~packet_valid_q;
  assign packet_end = ~packet_valid_d & packet_valid_q;

  // EOP detection is configurable for 1/2 bit periods of SE0.
  // The standard (Table 7-7) mandates min = 82 ns = 1 bit period.
  // We also trigger an EOP on seeing a bitstuff error.
  assign see_eop = (cfg_eop_single_bit_i && line_history_q[1:0] == 2'b00) || (
      line_history_q[3:0] == 4'b0000) || bitstuff_error_q;

  always_comb begin : proc_packet_valid_d
    if (line_state_valid) begin
      // check for packet start: KJKJKK, we use the last 6 bits
      if (!packet_valid_q && line_history_q[11:0] == 12'b011001100101) begin
        packet_valid_d = 1;
      end  // check for packet end: SE0 SE0
          else
      if (packet_valid_q && see_eop) begin
        packet_valid_d = 0;

      end else begin
        packet_valid_d = packet_valid_q;
      end
    end else begin
      packet_valid_d = packet_valid_q;
    end
  end

  // keep a history of the last two states on the line
  assign line_history_d = line_state_valid ? {
    line_history_q[9:0], line_state_q[1:0]
  } : line_history_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg_pkt_line
    if (!rst_ni) begin
      packet_valid_q <= 0;
      line_history_q <= 12'b101010101010;  // all K
    end else begin
      if (link_reset_i) begin
        packet_valid_q <= 0;
        line_history_q <= 12'b101010101010;  // all K
      end else begin
        packet_valid_q <= packet_valid_d;
        line_history_q <= line_history_d;
      end
    end
  end


  /////////////////
  // NRZI decode //
  /////////////////

  // in order to ensure there are enough bit transitions for a receiver to recover
  // the clock usb uses NRZI encoding.

  // https://en.wikipedia.org/wiki/Non-return-to-zero

  logic dvalid_raw;
  logic din;

  always_comb begin
    unique case (line_history_q[3:0])
      4'b0101: din = 1;
      4'b0110: din = 0;
      4'b1001: din = 0;
      4'b1010: din = 1;
      default: din = 0;
    endcase

    if (packet_valid_q && line_state_valid) begin
      unique case (line_history_q[3:0])
        4'b0101: dvalid_raw = 1;
        4'b0110: dvalid_raw = 1;
        4'b1001: dvalid_raw = 1;
        4'b1010: dvalid_raw = 1;
        default: dvalid_raw = 0;
      endcase
    end else begin
      dvalid_raw = 0;
    end
  end

  //////////////////////////////////////////////////////
  // Undo bit stuffing and detect bit stuffing errors //
  //////////////////////////////////////////////////////

  always_comb begin : proc_bitstuff_history_d
    if (packet_end) begin
      bitstuff_history_d = '0;
    end else if (dvalid_raw) begin
      bitstuff_history_d = {bitstuff_history_q[5:0], din};
    end else begin
      bitstuff_history_d = bitstuff_history_q;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_history_q
    if (!rst_ni) begin
      bitstuff_history_q <= 0;
    end else begin
      if (link_reset_i) begin
        bitstuff_history_q <= 0;
      end else begin
        bitstuff_history_q <= bitstuff_history_d;
      end
    end
  end

  logic dvalid;
  assign dvalid = dvalid_raw && !(bitstuff_history_q[5:0] == 6'b111111);

  // 7 consecutive ones should not be seen on the bus
  // USB spec, 7.1.9.1: "If the receiver sees seven
  // consecutive ones anywhere in the packet, then a bit stuffing error
  // has occurred and the packet should be ignored."
  assign bitstuff_error = bitstuff_history_q == 7'b1111111;

  // remember the bitstuff errors
  always_comb begin : proc_bistuff_error_d
    bitstuff_error_d = bitstuff_error_q;
    if (packet_start) begin
      bitstuff_error_d = 0;
    end else if (bitstuff_error && dvalid_raw) begin
      bitstuff_error_d = 1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_error_q
    if (!rst_ni) begin
      bitstuff_error_q <= 0;
    end else begin
      bitstuff_error_q <= bitstuff_error_d;
    end
  end

  assign bitstuff_error_o = bitstuff_error_q && packet_end;


  ////////////////////////
  // save and check pid //
  ////////////////////////

  // shift in the entire 8-bit pid with an additional 9th bit used as a sentinal.

  logic [8:0] full_pid_q, full_pid_d;
  logic pid_valid, pid_complete;

  assign pid_valid = full_pid_q[4:1] == ~full_pid_q[8:5];
  assign pid_complete = full_pid_q[0];

  always_comb begin : proc_full_pid_d
    if (dvalid && !pid_complete) begin
      full_pid_d = {din, full_pid_q[8:1]};
    end else if (packet_start) begin
      full_pid_d = 9'b100000000;
    end else begin
      full_pid_d = full_pid_q;
    end
  end

  ////////////////
  // check crc5 //
  ////////////////
  logic [4:0] crc5_q, crc5_d;
  logic crc5_valid, crc5_invert;
  assign crc5_valid = crc5_q == 5'b01100;
  assign crc5_invert = din ^ crc5_q[4];

  always_comb begin
    crc5_d = crc5_q;  // default value

    if (packet_start) begin
      crc5_d = 5'b11111;
    end

    if (dvalid && pid_complete) begin
      crc5_d = {crc5_q[3:0], 1'b0} ^ ({5{crc5_invert}} & 5'b00101);
    end
  end


  /////////////////
  // check crc16 //
  /////////////////
  logic [15:0] crc16_q, crc16_d;
  logic crc16_valid, crc16_invert;

  assign crc16_valid = crc16_q == 16'b1000000000001101;
  assign crc16_invert = din ^ crc16_q[15];

  always_comb begin
    crc16_d = crc16_q;  // default value

    if (packet_start) begin
      crc16_d = 16'b1111111111111111;
    end

    if (dvalid && pid_complete) begin
      crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);
    end
  end


  ////////////////////////////
  // output control signals //
  ////////////////////////////
  logic pkt_is_token, pkt_is_data, pkt_is_handshake;
  assign pkt_is_token = full_pid_q[2:1] == 2'b01;
  assign pkt_is_data = full_pid_q[2:1] == 2'b11;
  assign pkt_is_handshake = full_pid_q[2:1] == 2'b10;


  // TODO: need to check for data packet babble
  assign valid_packet_o = pid_valid && !bitstuff_error_q &&
      ((pkt_is_handshake) || (pkt_is_data && crc16_valid) || (pkt_is_token && crc5_valid));

  // Detect CRC errors
  assign
      crc_error_o = ((pkt_is_data && !crc16_valid) || (pkt_is_token && !crc5_valid)) && packet_end;

  // Detect PID errors
  assign pid_error_o = !pid_valid && packet_end;

  logic [11:0] token_payload_q, token_payload_d;
  logic token_payload_done;

  assign token_payload_done = token_payload_q[0];

  logic [6:0] addr_q, addr_d;
  logic [3:0] endp_q, endp_d;
  logic [10:0] frame_num_q, frame_num_d;

  always_comb begin
    token_payload_d = token_payload_q;  // default

    if (packet_start) begin
      token_payload_d = 12'b100000000000;
    end

    if (dvalid && pid_complete && pkt_is_token && !token_payload_done) begin
      token_payload_d = {din, token_payload_q[11:1]};
    end
  end

  always_comb begin
    // defaults
    addr_d = addr_q;
    endp_d = endp_q;
    frame_num_d = frame_num_q;

    if (token_payload_done && pkt_is_token) begin
      addr_d = token_payload_q[7:1];
      endp_d = token_payload_q[11:8];
      frame_num_d = token_payload_q[11:1];
    end
  end

  assign addr_o = addr_q;
  assign endp_o = endp_q;
  assign frame_num_o = frame_num_q;
  assign pid_o = full_pid_q[4:1];

  assign pkt_start_o = packet_start;
  assign pkt_end_o = packet_end;


  /////////////////////////////////
  // deserialize and output data //
  /////////////////////////////////
  //assign rx_data_put = dvalid && pid_complete && pkt_is_data;
  logic [8:0] rx_data_buffer_q, rx_data_buffer_d;
  logic rx_data_buffer_full;

  assign rx_data_buffer_full = rx_data_buffer_q[0];
  assign rx_data_put_o = rx_data_buffer_full;
  assign rx_data_o = rx_data_buffer_q[8:1];

  always_comb begin
    rx_data_buffer_d = rx_data_buffer_q;  // default

    if (packet_start || rx_data_buffer_full) begin
      rx_data_buffer_d = 9'b100000000;
    end

    if (dvalid && pid_complete && pkt_is_data) begin
      rx_data_buffer_d = {din, rx_data_buffer_q[8:1]};
    end
  end


  ///////////////
  // Registers //
  ///////////////
  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_gp_regs
    if (!rst_ni) begin
      full_pid_q <= 0;
      crc16_q <= 0;
      crc5_q <= 0;
      token_payload_q <= 0;
      addr_q <= 0;
      endp_q <= 0;
      frame_num_q <= 0;
      rx_data_buffer_q <= 0;
    end else begin
      if (link_reset_i) begin
        full_pid_q <= 0;
        crc16_q <= 0;
        crc5_q <= 0;
        token_payload_q <= 0;
        addr_q <= 0;
        endp_q <= 0;
        frame_num_q <= 0;
        rx_data_buffer_q <= 0;
      end else begin
        full_pid_q <= full_pid_d;
        crc16_q <= crc16_d;
        crc5_q <= crc5_d;
        token_payload_q <= token_payload_d;
        addr_q <= addr_d;
        endp_q <= endp_d;
        frame_num_q <= frame_num_d;
        rx_data_buffer_q <= rx_data_buffer_d;
      end
    end
  end

endmodule  // usb_fs_rx
Re-formatted:
// Copyright lowRISC contributors.
// Copyright ETH Zurich.
// Copyright Luke Valenty (TinyFPGA project, https://github.com/tinyfpga/TinyFPGA-Bootloader).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

module usb_fs_rx (
    // A 48MHz clock is required to recover the clock from the incoming data.
    input logic clk_i,
    input logic rst_ni,
    input logic link_reset_i,

    // EOP configuration
    input logic cfg_eop_single_bit_i,

    // USB data+ and data- lines (synchronous)
    input logic usb_d_i,
    input logic usb_se0_i,

    // Transmit enable disables the receier
    input logic tx_en_i,

    // pulse on every bit transition.
    output logic bit_strobe_o,

    // Pulse on beginning of new packet.
    output logic pkt_start_o,

    // Pulse on end of current packet.
    output logic pkt_end_o,

    // Most recent packet decoded.
    output logic [ 3:0] pid_o,
    output logic [ 6:0] addr_o,
    output logic [ 3:0] endp_o,
    output logic [10:0] frame_num_o,

    // Pulse on valid data on rx_data.
    output logic       rx_data_put_o,
    output logic [7:0] rx_data_o,

    // Most recent packet passes PID and CRC checks
    output logic valid_packet_o,

    // Error detection
    output logic crc_error_o,
    output logic pid_error_o,
    output logic bitstuff_error_o
);

  logic [6:0] bitstuff_history_q, bitstuff_history_d;
  logic bitstuff_error;
  logic bitstuff_error_q, bitstuff_error_d;

  //////////////////////
  // usb receive path //
  //////////////////////

  ///////////////////////////////////////
  // line state recovery state machine //
  ///////////////////////////////////////

  // The receive path doesn't currently use a differential reciever.  because of
  // this there is a chance that one of the differential pairs will appear to have
  // changed to the new state while the other is still in the old state.  the
  // following state machine detects transitions and waits an extra sampling clock
  // before decoding the state on the differential pair.  this transition period
  // will only ever last for one clock as long as there is no noise on the line.
  // if there is enough noise on the line then the data may be corrupted and the
  // packet will fail the data integrity checks.

  logic [2:0] line_state_q, line_state_d;
  localparam logic [2:0] DT = 3'b100;  // transition state
  localparam logic [2:0] DJ = 3'b010;  // J - idle line state
  // localparam logic [2:0]  DK = 3'b001; // K - inverse of J
  localparam logic [2:0] SE0 = 3'b000;  // single-ended 0 - end of packet or detached
  // localparam logic [2:0] SE1 = 3'b011; // single-ended 1 - illegal

  // Mute the input if we're transmitting
  logic [1:0] dpair;
  always_comb begin : proc_dpair_mute
    if (tx_en_i) begin
      dpair = DJ[1:0];  // J
    end else begin
      dpair = (usb_se0_i) ? 2'b00 : {usb_d_i, ~usb_d_i};
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_line_state_q
    if (!rst_ni) begin
      line_state_q <= SE0;
    end else begin
      if (link_reset_i) begin
        line_state_q <= SE0;
      end else begin
        line_state_q <= line_state_d;
      end
    end
  end

  always_comb begin : proc_line_state_d
    // Default assignment
    line_state_d = line_state_q;

    if (line_state_q == DT) begin
      // if we are in a transition state, then we can sample the pair and
      // move to the next corresponding line state
      line_state_d = {1'b0, dpair};

    end else begin
      // if we are in a valid line state and the value of the pair changes,
      // then we need to move to the transition state
      if (dpair != line_state_q[1:0]) begin
        line_state_d = DT;
      end
    end
  end

  ////////////////////
  // clock recovery //
  ////////////////////

  // the DT state from the line state recovery state machine is used to align to
  // transmit clock.  the line state is sampled in the middle of the bit time.

  // example of signal relationships
  // -------------------------------
  // line_state        DT  DJ  DJ  DJ  DT  DK  DK  DK  DK  DK  DK  DT  DJ  DJ  DJ
  // line_state_valid  ________----____________----____________----________----____
  // bit_phase         0   0   1   2   3   0   1   2   3   0   1   2   0   1   2


  logic [1:0] bit_phase_q, bit_phase_d;
  logic line_state_valid;

  assign line_state_valid = (bit_phase_q == 2'd1);
  assign bit_strobe_o = (bit_phase_q == 2'd2);

  // keep track of phase within each bit
  assign bit_phase_d = (line_state_q == DT) ? 0 : bit_phase_q + 1;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bit_phase_q
    if (!rst_ni) begin
      bit_phase_q <= 0;
    end else begin
      if (link_reset_i) begin
        bit_phase_q <= 0;
      end else begin
        bit_phase_q <= bit_phase_d;
      end
    end
  end


  //////////////////////
  // packet detection //
  //////////////////////

  // usb uses a sync to denote the beginning of a packet and two single-ended-0 to
  // denote the end of a packet.  this state machine recognizes the beginning and
  // end of packets for subsequent layers to process.

  logic [11:0] line_history_q, line_history_d;
  logic packet_valid_q, packet_valid_d;
  logic see_eop, packet_start, packet_end;

  assign packet_start = packet_valid_d & ~packet_valid_q;
  assign packet_end = ~packet_valid_d & packet_valid_q;

  // EOP detection is configurable for 1/2 bit periods of SE0.
  // The standard (Table 7-7) mandates min = 82 ns = 1 bit period.
  // We also trigger an EOP on seeing a bitstuff error.
  assign see_eop = (cfg_eop_single_bit_i && line_history_q[1:0] == 2'b00) || (
      line_history_q[3:0] == 4'b0000) || bitstuff_error_q;

  always_comb begin : proc_packet_valid_d
    if (line_state_valid) begin
      // check for packet start: KJKJKK, we use the last 6 bits
      if (!packet_valid_q && line_history_q[11:0] == 12'b011001100101) begin
        packet_valid_d = 1;
      end  // check for packet end: SE0 SE0
          else if (packet_valid_q && see_eop) begin
        packet_valid_d = 0;

      end else begin
        packet_valid_d = packet_valid_q;
      end
    end else begin
      packet_valid_d = packet_valid_q;
    end
  end

  // keep a history of the last two states on the line
  assign line_history_d = line_state_valid ? {
    line_history_q[9:0], line_state_q[1:0]
  } : line_history_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg_pkt_line
    if (!rst_ni) begin
      packet_valid_q <= 0;
      line_history_q <= 12'b101010101010;  // all K
    end else begin
      if (link_reset_i) begin
        packet_valid_q <= 0;
        line_history_q <= 12'b101010101010;  // all K
      end else begin
        packet_valid_q <= packet_valid_d;
        line_history_q <= line_history_d;
      end
    end
  end


  /////////////////
  // NRZI decode //
  /////////////////

  // in order to ensure there are enough bit transitions for a receiver to recover
  // the clock usb uses NRZI encoding.

  // https://en.wikipedia.org/wiki/Non-return-to-zero

  logic dvalid_raw;
  logic din;

  always_comb begin
    unique case (line_history_q[3:0])
      4'b0101: din = 1;
      4'b0110: din = 0;
      4'b1001: din = 0;
      4'b1010: din = 1;
      default: din = 0;
    endcase

    if (packet_valid_q && line_state_valid) begin
      unique case (line_history_q[3:0])
        4'b0101: dvalid_raw = 1;
        4'b0110: dvalid_raw = 1;
        4'b1001: dvalid_raw = 1;
        4'b1010: dvalid_raw = 1;
        default: dvalid_raw = 0;
      endcase
    end else begin
      dvalid_raw = 0;
    end
  end

  //////////////////////////////////////////////////////
  // Undo bit stuffing and detect bit stuffing errors //
  //////////////////////////////////////////////////////

  always_comb begin : proc_bitstuff_history_d
    if (packet_end) begin
      bitstuff_history_d = '0;
    end else if (dvalid_raw) begin
      bitstuff_history_d = {bitstuff_history_q[5:0], din};
    end else begin
      bitstuff_history_d = bitstuff_history_q;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_history_q
    if (!rst_ni) begin
      bitstuff_history_q <= 0;
    end else begin
      if (link_reset_i) begin
        bitstuff_history_q <= 0;
      end else begin
        bitstuff_history_q <= bitstuff_history_d;
      end
    end
  end

  logic dvalid;
  assign dvalid = dvalid_raw && !(bitstuff_history_q[5:0] == 6'b111111);

  // 7 consecutive ones should not be seen on the bus
  // USB spec, 7.1.9.1: "If the receiver sees seven
  // consecutive ones anywhere in the packet, then a bit stuffing error
  // has occurred and the packet should be ignored."
  assign bitstuff_error = bitstuff_history_q == 7'b1111111;

  // remember the bitstuff errors
  always_comb begin : proc_bistuff_error_d
    bitstuff_error_d = bitstuff_error_q;
    if (packet_start) begin
      bitstuff_error_d = 0;
    end else if (bitstuff_error && dvalid_raw) begin
      bitstuff_error_d = 1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_error_q
    if (!rst_ni) begin
      bitstuff_error_q <= 0;
    end else begin
      bitstuff_error_q <= bitstuff_error_d;
    end
  end

  assign bitstuff_error_o = bitstuff_error_q && packet_end;


  ////////////////////////
  // save and check pid //
  ////////////////////////

  // shift in the entire 8-bit pid with an additional 9th bit used as a sentinal.

  logic [8:0] full_pid_q, full_pid_d;
  logic pid_valid, pid_complete;

  assign pid_valid = full_pid_q[4:1] == ~full_pid_q[8:5];
  assign pid_complete = full_pid_q[0];

  always_comb begin : proc_full_pid_d
    if (dvalid && !pid_complete) begin
      full_pid_d = {din, full_pid_q[8:1]};
    end else if (packet_start) begin
      full_pid_d = 9'b100000000;
    end else begin
      full_pid_d = full_pid_q;
    end
  end

  ////////////////
  // check crc5 //
  ////////////////
  logic [4:0] crc5_q, crc5_d;
  logic crc5_valid, crc5_invert;
  assign crc5_valid = crc5_q == 5'b01100;
  assign crc5_invert = din ^ crc5_q[4];

  always_comb begin
    crc5_d = crc5_q;  // default value

    if (packet_start) begin
      crc5_d = 5'b11111;
    end

    if (dvalid && pid_complete) begin
      crc5_d = {crc5_q[3:0], 1'b0} ^ ({5{crc5_invert}} & 5'b00101);
    end
  end


  /////////////////
  // check crc16 //
  /////////////////
  logic [15:0] crc16_q, crc16_d;
  logic crc16_valid, crc16_invert;

  assign crc16_valid = crc16_q == 16'b1000000000001101;
  assign crc16_invert = din ^ crc16_q[15];

  always_comb begin
    crc16_d = crc16_q;  // default value

    if (packet_start) begin
      crc16_d = 16'b1111111111111111;
    end

    if (dvalid && pid_complete) begin
      crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);
    end
  end


  ////////////////////////////
  // output control signals //
  ////////////////////////////
  logic pkt_is_token, pkt_is_data, pkt_is_handshake;
  assign pkt_is_token = full_pid_q[2:1] == 2'b01;
  assign pkt_is_data = full_pid_q[2:1] == 2'b11;
  assign pkt_is_handshake = full_pid_q[2:1] == 2'b10;


  // TODO: need to check for data packet babble
  assign valid_packet_o = pid_valid && !bitstuff_error_q &&
      ((pkt_is_handshake) || (pkt_is_data && crc16_valid) || (pkt_is_token && crc5_valid));

  // Detect CRC errors
  assign
      crc_error_o = ((pkt_is_data && !crc16_valid) || (pkt_is_token && !crc5_valid)) && packet_end;

  // Detect PID errors
  assign pid_error_o = !pid_valid && packet_end;

  logic [11:0] token_payload_q, token_payload_d;
  logic token_payload_done;

  assign token_payload_done = token_payload_q[0];

  logic [6:0] addr_q, addr_d;
  logic [3:0] endp_q, endp_d;
  logic [10:0] frame_num_q, frame_num_d;

  always_comb begin
    token_payload_d = token_payload_q;  // default

    if (packet_start) begin
      token_payload_d = 12'b100000000000;
    end

    if (dvalid && pid_complete && pkt_is_token && !token_payload_done) begin
      token_payload_d = {din, token_payload_q[11:1]};
    end
  end

  always_comb begin
    // defaults
    addr_d = addr_q;
    endp_d = endp_q;
    frame_num_d = frame_num_q;

    if (token_payload_done && pkt_is_token) begin
      addr_d = token_payload_q[7:1];
      endp_d = token_payload_q[11:8];
      frame_num_d = token_payload_q[11:1];
    end
  end

  assign addr_o = addr_q;
  assign endp_o = endp_q;
  assign frame_num_o = frame_num_q;
  assign pid_o = full_pid_q[4:1];

  assign pkt_start_o = packet_start;
  assign pkt_end_o = packet_end;


  /////////////////////////////////
  // deserialize and output data //
  /////////////////////////////////
  //assign rx_data_put = dvalid && pid_complete && pkt_is_data;
  logic [8:0] rx_data_buffer_q, rx_data_buffer_d;
  logic rx_data_buffer_full;

  assign rx_data_buffer_full = rx_data_buffer_q[0];
  assign rx_data_put_o = rx_data_buffer_full;
  assign rx_data_o = rx_data_buffer_q[8:1];

  always_comb begin
    rx_data_buffer_d = rx_data_buffer_q;  // default

    if (packet_start || rx_data_buffer_full) begin
      rx_data_buffer_d = 9'b100000000;
    end

    if (dvalid && pid_complete && pkt_is_data) begin
      rx_data_buffer_d = {din, rx_data_buffer_q[8:1]};
    end
  end


  ///////////////
  // Registers //
  ///////////////
  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_gp_regs
    if (!rst_ni) begin
      full_pid_q <= 0;
      crc16_q <= 0;
      crc5_q <= 0;
      token_payload_q <= 0;
      addr_q <= 0;
      endp_q <= 0;
      frame_num_q <= 0;
      rx_data_buffer_q <= 0;
    end else begin
      if (link_reset_i) begin
        full_pid_q <= 0;
        crc16_q <= 0;
        crc5_q <= 0;
        token_payload_q <= 0;
        addr_q <= 0;
        endp_q <= 0;
        frame_num_q <= 0;
        rx_data_buffer_q <= 0;
      end else begin
        full_pid_q <= full_pid_d;
        crc16_q <= crc16_d;
        crc5_q <= crc5_d;
        token_payload_q <= token_payload_d;
        addr_q <= addr_d;
        endp_q <= endp_d;
        frame_num_q <= frame_num_d;
        rx_data_buffer_q <= rx_data_buffer_d;
      end
    end
  end

endmodule  // usb_fs_rx
Diffs are:
 // Copyright lowRISC contributors.
 // Copyright ETH Zurich.
 // Copyright Luke Valenty (TinyFPGA project, https://github.com/tinyfpga/TinyFPGA-Bootloader).
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
 module usb_fs_rx (
     // A 48MHz clock is required to recover the clock from the incoming data.
     input logic clk_i,
     input logic rst_ni,
     input logic link_reset_i,
 
     // EOP configuration
     input logic cfg_eop_single_bit_i,
 
     // USB data+ and data- lines (synchronous)
     input logic usb_d_i,
     input logic usb_se0_i,
 
     // Transmit enable disables the receier
     input logic tx_en_i,
 
     // pulse on every bit transition.
     output logic bit_strobe_o,
 
     // Pulse on beginning of new packet.
     output logic pkt_start_o,
 
     // Pulse on end of current packet.
     output logic pkt_end_o,
 
     // Most recent packet decoded.
     output logic [ 3:0] pid_o,
     output logic [ 6:0] addr_o,
     output logic [ 3:0] endp_o,
     output logic [10:0] frame_num_o,
 
     // Pulse on valid data on rx_data.
     output logic       rx_data_put_o,
     output logic [7:0] rx_data_o,
 
     // Most recent packet passes PID and CRC checks
     output logic valid_packet_o,
 
     // Error detection
     output logic crc_error_o,
     output logic pid_error_o,
     output logic bitstuff_error_o
 );
 
   logic [6:0] bitstuff_history_q, bitstuff_history_d;
   logic bitstuff_error;
   logic bitstuff_error_q, bitstuff_error_d;
 
   //////////////////////
   // usb receive path //
   //////////////////////
 
   ///////////////////////////////////////
   // line state recovery state machine //
   ///////////////////////////////////////
 
   // The receive path doesn't currently use a differential reciever.  because of
   // this there is a chance that one of the differential pairs will appear to have
   // changed to the new state while the other is still in the old state.  the
   // following state machine detects transitions and waits an extra sampling clock
   // before decoding the state on the differential pair.  this transition period
   // will only ever last for one clock as long as there is no noise on the line.
   // if there is enough noise on the line then the data may be corrupted and the
   // packet will fail the data integrity checks.
 
   logic [2:0] line_state_q, line_state_d;
   localparam logic [2:0] DT = 3'b100;  // transition state
   localparam logic [2:0] DJ = 3'b010;  // J - idle line state
   // localparam logic [2:0]  DK = 3'b001; // K - inverse of J
   localparam logic [2:0] SE0 = 3'b000;  // single-ended 0 - end of packet or detached
   // localparam logic [2:0] SE1 = 3'b011; // single-ended 1 - illegal
 
   // Mute the input if we're transmitting
   logic [1:0] dpair;
   always_comb begin : proc_dpair_mute
     if (tx_en_i) begin
       dpair = DJ[1:0];  // J
     end else begin
       dpair = (usb_se0_i) ? 2'b00 : {usb_d_i, ~usb_d_i};
     end
   end
 
   always_ff @(posedge clk_i or negedge rst_ni) begin : proc_line_state_q
     if (!rst_ni) begin
       line_state_q <= SE0;
     end else begin
       if (link_reset_i) begin
         line_state_q <= SE0;
       end else begin
         line_state_q <= line_state_d;
       end
     end
   end
 
   always_comb begin : proc_line_state_d
     // Default assignment
     line_state_d = line_state_q;
 
     if (line_state_q == DT) begin
       // if we are in a transition state, then we can sample the pair and
       // move to the next corresponding line state
       line_state_d = {1'b0, dpair};
 
     end else begin
       // if we are in a valid line state and the value of the pair changes,
       // then we need to move to the transition state
       if (dpair != line_state_q[1:0]) begin
         line_state_d = DT;
       end
     end
   end
 
   ////////////////////
   // clock recovery //
   ////////////////////
 
   // the DT state from the line state recovery state machine is used to align to
   // transmit clock.  the line state is sampled in the middle of the bit time.
 
   // example of signal relationships
   // -------------------------------
   // line_state        DT  DJ  DJ  DJ  DT  DK  DK  DK  DK  DK  DK  DT  DJ  DJ  DJ
   // line_state_valid  ________----____________----____________----________----____
   // bit_phase         0   0   1   2   3   0   1   2   3   0   1   2   0   1   2
 
 
   logic [1:0] bit_phase_q, bit_phase_d;
   logic line_state_valid;
 
   assign line_state_valid = (bit_phase_q == 2'd1);
   assign bit_strobe_o = (bit_phase_q == 2'd2);
 
   // keep track of phase within each bit
   assign bit_phase_d = (line_state_q == DT) ? 0 : bit_phase_q + 1;
 
   always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bit_phase_q
     if (!rst_ni) begin
       bit_phase_q <= 0;
     end else begin
       if (link_reset_i) begin
         bit_phase_q <= 0;
       end else begin
         bit_phase_q <= bit_phase_d;
       end
     end
   end
 
 
   //////////////////////
   // packet detection //
   //////////////////////
 
   // usb uses a sync to denote the beginning of a packet and two single-ended-0 to
   // denote the end of a packet.  this state machine recognizes the beginning and
   // end of packets for subsequent layers to process.
 
   logic [11:0] line_history_q, line_history_d;
   logic packet_valid_q, packet_valid_d;
   logic see_eop, packet_start, packet_end;
 
   assign packet_start = packet_valid_d & ~packet_valid_q;
   assign packet_end = ~packet_valid_d & packet_valid_q;
 
   // EOP detection is configurable for 1/2 bit periods of SE0.
   // The standard (Table 7-7) mandates min = 82 ns = 1 bit period.
   // We also trigger an EOP on seeing a bitstuff error.
   assign see_eop = (cfg_eop_single_bit_i && line_history_q[1:0] == 2'b00) || (
       line_history_q[3:0] == 4'b0000) || bitstuff_error_q;
 
   always_comb begin : proc_packet_valid_d
     if (line_state_valid) begin
       // check for packet start: KJKJKK, we use the last 6 bits
       if (!packet_valid_q && line_history_q[11:0] == 12'b011001100101) begin
         packet_valid_d = 1;
       end  // check for packet end: SE0 SE0
-          else
-      if (packet_valid_q && see_eop) begin
+          else if (packet_valid_q && see_eop) begin
         packet_valid_d = 0;
 
       end else begin
         packet_valid_d = packet_valid_q;
       end
     end else begin
       packet_valid_d = packet_valid_q;
     end
   end
 
   // keep a history of the last two states on the line
   assign line_history_d = line_state_valid ? {
     line_history_q[9:0], line_state_q[1:0]
   } : line_history_q;
 
   always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg_pkt_line
     if (!rst_ni) begin
       packet_valid_q <= 0;
       line_history_q <= 12'b101010101010;  // all K
     end else begin
       if (link_reset_i) begin
         packet_valid_q <= 0;
         line_history_q <= 12'b101010101010;  // all K
       end else begin
         packet_valid_q <= packet_valid_d;
         line_history_q <= line_history_d;
       end
     end
   end
 
 
   /////////////////
   // NRZI decode //
   /////////////////
 
   // in order to ensure there are enough bit transitions for a receiver to recover
   // the clock usb uses NRZI encoding.
 
   // https://en.wikipedia.org/wiki/Non-return-to-zero
 
   logic dvalid_raw;
   logic din;
 
   always_comb begin
     unique case (line_history_q[3:0])
       4'b0101: din = 1;
       4'b0110: din = 0;
       4'b1001: din = 0;
       4'b1010: din = 1;
       default: din = 0;
     endcase
 
     if (packet_valid_q && line_state_valid) begin
       unique case (line_history_q[3:0])
         4'b0101: dvalid_raw = 1;
         4'b0110: dvalid_raw = 1;
         4'b1001: dvalid_raw = 1;
         4'b1010: dvalid_raw = 1;
         default: dvalid_raw = 0;
       endcase
     end else begin
       dvalid_raw = 0;
     end
   end
 
   //////////////////////////////////////////////////////
   // Undo bit stuffing and detect bit stuffing errors //
   //////////////////////////////////////////////////////
 
   always_comb begin : proc_bitstuff_history_d
     if (packet_end) begin
       bitstuff_history_d = '0;
     end else if (dvalid_raw) begin
       bitstuff_history_d = {bitstuff_history_q[5:0], din};
     end else begin
       bitstuff_history_d = bitstuff_history_q;
     end
   end
 
   always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_history_q
     if (!rst_ni) begin
       bitstuff_history_q <= 0;
     end else begin
       if (link_reset_i) begin
         bitstuff_history_q <= 0;
       end else begin
         bitstuff_history_q <= bitstuff_history_d;
       end
     end
   end
 
   logic dvalid;
   assign dvalid = dvalid_raw && !(bitstuff_history_q[5:0] == 6'b111111);
 
   // 7 consecutive ones should not be seen on the bus
   // USB spec, 7.1.9.1: "If the receiver sees seven
   // consecutive ones anywhere in the packet, then a bit stuffing error
   // has occurred and the packet should be ignored."
   assign bitstuff_error = bitstuff_history_q == 7'b1111111;
 
   // remember the bitstuff errors
   always_comb begin : proc_bistuff_error_d
     bitstuff_error_d = bitstuff_error_q;
     if (packet_start) begin
       bitstuff_error_d = 0;
     end else if (bitstuff_error && dvalid_raw) begin
       bitstuff_error_d = 1;
     end
   end
 
   always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_error_q
     if (!rst_ni) begin
       bitstuff_error_q <= 0;
     end else begin
       bitstuff_error_q <= bitstuff_error_d;
     end
   end
 
   assign bitstuff_error_o = bitstuff_error_q && packet_end;
 
 
   ////////////////////////
   // save and check pid //
   ////////////////////////
 
   // shift in the entire 8-bit pid with an additional 9th bit used as a sentinal.
 
   logic [8:0] full_pid_q, full_pid_d;
   logic pid_valid, pid_complete;
 
   assign pid_valid = full_pid_q[4:1] == ~full_pid_q[8:5];
   assign pid_complete = full_pid_q[0];
 
   always_comb begin : proc_full_pid_d
     if (dvalid && !pid_complete) begin
       full_pid_d = {din, full_pid_q[8:1]};
     end else if (packet_start) begin
       full_pid_d = 9'b100000000;
     end else begin
       full_pid_d = full_pid_q;
     end
   end
 
   ////////////////
   // check crc5 //
   ////////////////
   logic [4:0] crc5_q, crc5_d;
   logic crc5_valid, crc5_invert;
   assign crc5_valid = crc5_q == 5'b01100;
   assign crc5_invert = din ^ crc5_q[4];
 
   always_comb begin
     crc5_d = crc5_q;  // default value
 
     if (packet_start) begin
       crc5_d = 5'b11111;
     end
 
     if (dvalid && pid_complete) begin
       crc5_d = {crc5_q[3:0], 1'b0} ^ ({5{crc5_invert}} & 5'b00101);
     end
   end
 
 
   /////////////////
   // check crc16 //
   /////////////////
   logic [15:0] crc16_q, crc16_d;
   logic crc16_valid, crc16_invert;
 
   assign crc16_valid = crc16_q == 16'b1000000000001101;
   assign crc16_invert = din ^ crc16_q[15];
 
   always_comb begin
     crc16_d = crc16_q;  // default value
 
     if (packet_start) begin
       crc16_d = 16'b1111111111111111;
     end
 
     if (dvalid && pid_complete) begin
       crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);
     end
   end
 
 
   ////////////////////////////
   // output control signals //
   ////////////////////////////
   logic pkt_is_token, pkt_is_data, pkt_is_handshake;
   assign pkt_is_token = full_pid_q[2:1] == 2'b01;
   assign pkt_is_data = full_pid_q[2:1] == 2'b11;
   assign pkt_is_handshake = full_pid_q[2:1] == 2'b10;
 
 
   // TODO: need to check for data packet babble
   assign valid_packet_o = pid_valid && !bitstuff_error_q &&
       ((pkt_is_handshake) || (pkt_is_data && crc16_valid) || (pkt_is_token && crc5_valid));
 
   // Detect CRC errors
   assign
       crc_error_o = ((pkt_is_data && !crc16_valid) || (pkt_is_token && !crc5_valid)) && packet_end;
 
   // Detect PID errors
   assign pid_error_o = !pid_valid && packet_end;
 
   logic [11:0] token_payload_q, token_payload_d;
   logic token_payload_done;
 
   assign token_payload_done = token_payload_q[0];
 
   logic [6:0] addr_q, addr_d;
   logic [3:0] endp_q, endp_d;
   logic [10:0] frame_num_q, frame_num_d;
 
   always_comb begin
     token_payload_d = token_payload_q;  // default
 
     if (packet_start) begin
       token_payload_d = 12'b100000000000;
     end
 
     if (dvalid && pid_complete && pkt_is_token && !token_payload_done) begin
       token_payload_d = {din, token_payload_q[11:1]};
     end
   end
 
   always_comb begin
     // defaults
     addr_d = addr_q;
     endp_d = endp_q;
     frame_num_d = frame_num_q;
 
     if (token_payload_done && pkt_is_token) begin
       addr_d = token_payload_q[7:1];
       endp_d = token_payload_q[11:8];
       frame_num_d = token_payload_q[11:1];
     end
   end
 
   assign addr_o = addr_q;
   assign endp_o = endp_q;
   assign frame_num_o = frame_num_q;
   assign pid_o = full_pid_q[4:1];
 
   assign pkt_start_o = packet_start;
   assign pkt_end_o = packet_end;
 
 
   /////////////////////////////////
   // deserialize and output data //
   /////////////////////////////////
   //assign rx_data_put = dvalid && pid_complete && pkt_is_data;
   logic [8:0] rx_data_buffer_q, rx_data_buffer_d;
   logic rx_data_buffer_full;
 
   assign rx_data_buffer_full = rx_data_buffer_q[0];
   assign rx_data_put_o = rx_data_buffer_full;
   assign rx_data_o = rx_data_buffer_q[8:1];
 
   always_comb begin
     rx_data_buffer_d = rx_data_buffer_q;  // default
 
     if (packet_start || rx_data_buffer_full) begin
       rx_data_buffer_d = 9'b100000000;
     end
 
     if (dvalid && pid_complete && pkt_is_data) begin
       rx_data_buffer_d = {din, rx_data_buffer_q[8:1]};
     end
   end
 
 
   ///////////////
   // Registers //
   ///////////////
   always_ff @(posedge clk_i or negedge rst_ni) begin : proc_gp_regs
     if (!rst_ni) begin
       full_pid_q <= 0;
       crc16_q <= 0;
       crc5_q <= 0;
       token_payload_q <= 0;
       addr_q <= 0;
       endp_q <= 0;
       frame_num_q <= 0;
       rx_data_buffer_q <= 0;
     end else begin
       if (link_reset_i) begin
         full_pid_q <= 0;
         crc16_q <= 0;
         crc5_q <= 0;
         token_payload_q <= 0;
         addr_q <= 0;
         endp_q <= 0;
         frame_num_q <= 0;
         rx_data_buffer_q <= 0;
       end else begin
         full_pid_q <= full_pid_d;
         crc16_q <= crc16_d;
         crc5_q <= crc5_d;
         token_payload_q <= token_payload_d;
         addr_q <= addr_d;
         endp_q <= endp_d;
         frame_num_q <= frame_num_d;
         rx_data_buffer_q <= rx_data_buffer_d;
       end
     end
   end
 
 endmodule  // usb_fs_rx
hw/ip/prim_generic/rtl/prim_generic_clock_buf.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_otp.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_clock_gating.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_pad_wrapper.sv: Already formatted, no change.
; problematic formatter output is
// Copyright lowRISC contributors.
// Copyright ETH Zurich.
// Copyright Luke Valenty (TinyFPGA project, https://github.com/tinyfpga/TinyFPGA-Bootloader).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

module usb_fs_rx (
    // A 48MHz clock is required to recover the clock from the incoming data.
    input logic clk_i,
    input logic rst_ni,
    input logic link_reset_i,

    // EOP configuration
    input logic cfg_eop_single_bit_i,

    // USB data+ and data- lines (synchronous)
    input logic usb_d_i,
    input logic usb_se0_i,

    // Transmit enable disables the receier
    input logic tx_en_i,

    // pulse on every bit transition.
    output logic bit_strobe_o,

    // Pulse on beginning of new packet.
    output logic pkt_start_o,

    // Pulse on end of current packet.
    output logic pkt_end_o,

    // Most recent packet decoded.
    output logic [ 3:0] pid_o,
    output logic [ 6:0] addr_o,
    output logic [ 3:0] endp_o,
    output logic [10:0] frame_num_o,

    // Pulse on valid data on rx_data.
    output logic       rx_data_put_o,
    output logic [7:0] rx_data_o,

    // Most recent packet passes PID and CRC checks
    output logic valid_packet_o,

    // Error detection
    output logic crc_error_o,
    output logic pid_error_o,
    output logic bitstuff_error_o
);

  logic [6:0] bitstuff_history_q, bitstuff_history_d;
  logic bitstuff_error;
  logic bitstuff_error_q, bitstuff_error_d;

  //////////////////////
  // usb receive path //
  //////////////////////

  ///////////////////////////////////////
  // line state recovery state machine //
  ///////////////////////////////////////

  // The receive path doesn't currently use a differential reciever.  because of
  // this there is a chance that one of the differential pairs will appear to have
  // changed to the new state while the other is still in the old state.  the
  // following state machine detects transitions and waits an extra sampling clock
  // before decoding the state on the differential pair.  this transition period
  // will only ever last for one clock as long as there is no noise on the line.
  // if there is enough noise on the line then the data may be corrupted and the
  // packet will fail the data integrity checks.

  logic [2:0] line_state_q, line_state_d;
  localparam logic [2:0] DT = 3'b100;  // transition state
  localparam logic [2:0] DJ = 3'b010;  // J - idle line state
  // localparam logic [2:0]  DK = 3'b001; // K - inverse of J
  localparam logic [2:0] SE0 = 3'b000;  // single-ended 0 - end of packet or detached
  // localparam logic [2:0] SE1 = 3'b011; // single-ended 1 - illegal

  // Mute the input if we're transmitting
  logic [1:0] dpair;
  always_comb begin : proc_dpair_mute
    if (tx_en_i) begin
      dpair = DJ[1:0];  // J
    end else begin
      dpair = (usb_se0_i) ? 2'b00 : {usb_d_i, ~usb_d_i};
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_line_state_q
    if (!rst_ni) begin
      line_state_q <= SE0;
    end else begin
      if (link_reset_i) begin
        line_state_q <= SE0;
      end else begin
        line_state_q <= line_state_d;
      end
    end
  end

  always_comb begin : proc_line_state_d
    // Default assignment
    line_state_d = line_state_q;

    if (line_state_q == DT) begin
      // if we are in a transition state, then we can sample the pair and
      // move to the next corresponding line state
      line_state_d = {1'b0, dpair};

    end else begin
      // if we are in a valid line state and the value of the pair changes,
      // then we need to move to the transition state
      if (dpair != line_state_q[1:0]) begin
        line_state_d = DT;
      end
    end
  end

  ////////////////////
  // clock recovery //
  ////////////////////

  // the DT state from the line state recovery state machine is used to align to
  // transmit clock.  the line state is sampled in the middle of the bit time.

  // example of signal relationships
  // -------------------------------
  // line_state        DT  DJ  DJ  DJ  DT  DK  DK  DK  DK  DK  DK  DT  DJ  DJ  DJ
  // line_state_valid  ________----____________----____________----________----____
  // bit_phase         0   0   1   2   3   0   1   2   3   0   1   2   0   1   2


  logic [1:0] bit_phase_q, bit_phase_d;
  logic line_state_valid;

  assign line_state_valid = (bit_phase_q == 2'd1);
  assign bit_strobe_o = (bit_phase_q == 2'd2);

  // keep track of phase within each bit
  assign bit_phase_d = (line_state_q == DT) ? 0 : bit_phase_q + 1;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bit_phase_q
    if (!rst_ni) begin
      bit_phase_q <= 0;
    end else begin
      if (link_reset_i) begin
        bit_phase_q <= 0;
      end else begin
        bit_phase_q <= bit_phase_d;
      end
    end
  end


  //////////////////////
  // packet detection //
  //////////////////////

  // usb uses a sync to denote the beginning of a packet and two single-ended-0 to
  // denote the end of a packet.  this state machine recognizes the beginning and
  // end of packets for subsequent layers to process.

  logic [11:0] line_history_q, line_history_d;
  logic packet_valid_q, packet_valid_d;
  logic see_eop, packet_start, packet_end;

  assign packet_start = packet_valid_d & ~packet_valid_q;
  assign packet_end = ~packet_valid_d & packet_valid_q;

  // EOP detection is configurable for 1/2 bit periods of SE0.
  // The standard (Table 7-7) mandates min = 82 ns = 1 bit period.
  // We also trigger an EOP on seeing a bitstuff error.
  assign see_eop = (cfg_eop_single_bit_i && line_history_q[1:0] == 2'b00) || (
      line_history_q[3:0] == 4'b0000) || bitstuff_error_q;

  always_comb begin : proc_packet_valid_d
    if (line_state_valid) begin
      // check for packet start: KJKJKK, we use the last 6 bits
      if (!packet_valid_q && line_history_q[11:0] == 12'b011001100101) begin
        packet_valid_d = 1;
      end  // check for packet end: SE0 SE0
          else
      if (packet_valid_q && see_eop) begin
        packet_valid_d = 0;

      end else begin
        packet_valid_d = packet_valid_q;
      end
    end else begin
      packet_valid_d = packet_valid_q;
    end
  end

  // keep a history of the last two states on the line
  assign line_history_d = line_state_valid ? {
    line_history_q[9:0], line_state_q[1:0]
  } : line_history_q;

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_reg_pkt_line
    if (!rst_ni) begin
      packet_valid_q <= 0;
      line_history_q <= 12'b101010101010;  // all K
    end else begin
      if (link_reset_i) begin
        packet_valid_q <= 0;
        line_history_q <= 12'b101010101010;  // all K
      end else begin
        packet_valid_q <= packet_valid_d;
        line_history_q <= line_history_d;
      end
    end
  end


  /////////////////
  // NRZI decode //
  /////////////////

  // in order to ensure there are enough bit transitions for a receiver to recover
  // the clock usb uses NRZI encoding.

  // https://en.wikipedia.org/wiki/Non-return-to-zero

  logic dvalid_raw;
  logic din;

  always_comb begin
    unique case (line_history_q[3:0])
      4'b0101: din = 1;
      4'b0110: din = 0;
      4'b1001: din = 0;
      4'b1010: din = 1;
      default: din = 0;
    endcase

    if (packet_valid_q && line_state_valid) begin
      unique case (line_history_q[3:0])
        4'b0101: dvalid_raw = 1;
        4'b0110: dvalid_raw = 1;
        4'b1001: dvalid_raw = 1;
        4'b1010: dvalid_raw = 1;
        default: dvalid_raw = 0;
      endcase
    end else begin
      dvalid_raw = 0;
    end
  end

  //////////////////////////////////////////////////////
  // Undo bit stuffing and detect bit stuffing errors //
  //////////////////////////////////////////////////////

  always_comb begin : proc_bitstuff_history_d
    if (packet_end) begin
      bitstuff_history_d = '0;
    end else if (dvalid_raw) begin
      bitstuff_history_d = {bitstuff_history_q[5:0], din};
    end else begin
      bitstuff_history_d = bitstuff_history_q;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_history_q
    if (!rst_ni) begin
      bitstuff_history_q <= 0;
    end else begin
      if (link_reset_i) begin
        bitstuff_history_q <= 0;
      end else begin
        bitstuff_history_q <= bitstuff_history_d;
      end
    end
  end

  logic dvalid;
  assign dvalid = dvalid_raw && !(bitstuff_history_q[5:0] == 6'b111111);

  // 7 consecutive ones should not be seen on the bus
  // USB spec, 7.1.9.1: "If the receiver sees seven
  // consecutive ones anywhere in the packet, then a bit stuffing error
  // has occurred and the packet should be ignored."
  assign bitstuff_error = bitstuff_history_q == 7'b1111111;

  // remember the bitstuff errors
  always_comb begin : proc_bistuff_error_d
    bitstuff_error_d = bitstuff_error_q;
    if (packet_start) begin
      bitstuff_error_d = 0;
    end else if (bitstuff_error && dvalid_raw) begin
      bitstuff_error_d = 1;
    end
  end

  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_bitstuff_error_q
    if (!rst_ni) begin
      bitstuff_error_q <= 0;
    end else begin
      bitstuff_error_q <= bitstuff_error_d;
    end
  end

  assign bitstuff_error_o = bitstuff_error_q && packet_end;


  ////////////////////////
  // save and check pid //
  ////////////////////////

  // shift in the entire 8-bit pid with an additional 9th bit used as a sentinal.

  logic [8:0] full_pid_q, full_pid_d;
  logic pid_valid, pid_complete;

  assign pid_valid = full_pid_q[4:1] == ~full_pid_q[8:5];
  assign pid_complete = full_pid_q[0];

  always_comb begin : proc_full_pid_d
    if (dvalid && !pid_complete) begin
      full_pid_d = {din, full_pid_q[8:1]};
    end else if (packet_start) begin
      full_pid_d = 9'b100000000;
    end else begin
      full_pid_d = full_pid_q;
    end
  end

  ////////////////
  // check crc5 //
  ////////////////
  logic [4:0] crc5_q, crc5_d;
  logic crc5_valid, crc5_invert;
  assign crc5_valid = crc5_q == 5'b01100;
  assign crc5_invert = din ^ crc5_q[4];

  always_comb begin
    crc5_d = crc5_q;  // default value

    if (packet_start) begin
      crc5_d = 5'b11111;
    end

    if (dvalid && pid_complete) begin
      crc5_d = {crc5_q[3:0], 1'b0} ^ ({5{crc5_invert}} & 5'b00101);
    end
  end


  /////////////////
  // check crc16 //
  /////////////////
  logic [15:0] crc16_q, crc16_d;
  logic crc16_valid, crc16_invert;

  assign crc16_valid = crc16_q == 16'b1000000000001101;
  assign crc16_invert = din ^ crc16_q[15];

  always_comb begin
    crc16_d = crc16_q;  // default value

    if (packet_start) begin
      crc16_d = 16'b1111111111111111;
    end

    if (dvalid && pid_complete) begin
      crc16_d = {crc16_q[14:0], 1'b0} ^ ({16{crc16_invert}} & 16'b1000000000000101);
    end
  end


  ////////////////////////////
  // output control signals //
  ////////////////////////////
  logic pkt_is_token, pkt_is_data, pkt_is_handshake;
  assign pkt_is_token = full_pid_q[2:1] == 2'b01;
  assign pkt_is_data = full_pid_q[2:1] == 2'b11;
  assign pkt_is_handshake = full_pid_q[2:1] == 2'b10;


  // TODO: need to check for data packet babble
  assign valid_packet_o = pid_valid && !bitstuff_error_q &&
      ((pkt_is_handshake) || (pkt_is_data && crc16_valid) || (pkt_is_token && crc5_valid));

  // Detect CRC errors
  assign
      crc_error_o = ((pkt_is_data && !crc16_valid) || (pkt_is_token && !crc5_valid)) && packet_end;

  // Detect PID errors
  assign pid_error_o = !pid_valid && packet_end;

  logic [11:0] token_payload_q, token_payload_d;
  logic token_payload_done;

  assign token_payload_done = token_payload_q[0];

  logic [6:0] addr_q, addr_d;
  logic [3:0] endp_q, endp_d;
  logic [10:0] frame_num_q, frame_num_d;

  always_comb begin
    token_payload_d = token_payload_q;  // default

    if (packet_start) begin
      token_payload_d = 12'b100000000000;
    end

    if (dvalid && pid_complete && pkt_is_token && !token_payload_done) begin
      token_payload_d = {din, token_payload_q[11:1]};
    end
  end

  always_comb begin
    // defaults
    addr_d = addr_q;
    endp_d = endp_q;
    frame_num_d = frame_num_q;

    if (token_payload_done && pkt_is_token) begin
      addr_d = token_payload_q[7:1];
      endp_d = token_payload_q[11:8];
      frame_num_d = token_payload_q[11:1];
    end
  end

  assign addr_o = addr_q;
  assign endp_o = endp_q;
  assign frame_num_o = frame_num_q;
  assign pid_o = full_pid_q[4:1];

  assign pkt_start_o = packet_start;
  assign pkt_end_o = packet_end;


  /////////////////////////////////
  // deserialize and output data //
  /////////////////////////////////
  //assign rx_data_put = dvalid && pid_complete && pkt_is_data;
  logic [8:0] rx_data_buffer_q, rx_data_buffer_d;
  logic rx_data_buffer_full;

  assign rx_data_buffer_full = rx_data_buffer_q[0];
  assign rx_data_put_o = rx_data_buffer_full;
  assign rx_data_o = rx_data_buffer_q[8:1];

  always_comb begin
    rx_data_buffer_d = rx_data_buffer_q;  // default

    if (packet_start || rx_data_buffer_full) begin
      rx_data_buffer_d = 9'b100000000;
    end

    if (dvalid && pid_complete && pkt_is_data) begin
      rx_data_buffer_d = {din, rx_data_buffer_q[8:1]};
    end
  end


  ///////////////
  // Registers //
  ///////////////
  always_ff @(posedge clk_i or negedge rst_ni) begin : proc_gp_regs
    if (!rst_ni) begin
      full_pid_q <= 0;
      crc16_q <= 0;
      crc5_q <= 0;
      token_payload_q <= 0;
      addr_q <= 0;
      endp_q <= 0;
      frame_num_q <= 0;
      rx_data_buffer_q <= 0;
    end else begin
      if (link_reset_i) begin
        full_pid_q <= 0;
        crc16_q <= 0;
        crc5_q <= 0;
        token_payload_q <= 0;
        addr_q <= 0;
        endp_q <= 0;
        frame_num_q <= 0;
        rx_data_buffer_q <= 0;
      end else begin
        full_pid_q <= full_pid_d;
        crc16_q <= crc16_d;
        crc5_q <= crc5_d;
        token_payload_q <= token_payload_d;
        addr_q <= addr_d;
        endp_q <= endp_d;
        frame_num_q <= frame_num_d;
        rx_data_buffer_q <= rx_data_buffer_d;
      end
    end
  end

endmodule  // usb_fs_rx
<<EOF>>
hw/ip/prim_generic/rtl/prim_generic_flop_2sync.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_flop.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_clock_inv.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_clock_mux2.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_ram_1p.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_status_registers.sv: Already formatted, no change.
hw/ip/nmi_gen/rtl/nmi_gen_reg_pkg.sv: Already formatted, no change.
hw/ip/nmi_gen/rtl/nmi_gen.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_ram_2p.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_pkg.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_core.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_alu_base.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_lsu.sv: Already formatted, no change.
hw/ip/nmi_gen/dv/env/nmi_gen_reg_block.sv: Already formatted, no change.
hw/ip/prim_generic/rtl/prim_generic_flash.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_instruction_fetch.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_rf_base.sv: Already formatted, no change.
hw/ip/nmi_gen/rtl/nmi_gen_reg_top.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_controller.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_reg_pkg.sv: Already formatted, no change.
hw/ip/otbn/dv/verilator/otbn_top_sim.sv: Already formatted, no change.
hw/ip/pinmux/rtl/pinmux_pkg.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_reg_top.sv: Already formatted, no change.
hw/ip/pinmux/rtl/pinmux_wkup.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn_decoder.sv: Already formatted, no change.
hw/ip/otbn/rtl/otbn.sv: Already formatted, no change.
hw/ip/pinmux/fpv/tb/pinmux_bind_fpv.sv: Already formatted, no change.
hw/ip/pinmux/rtl/pinmux_reg_pkg.sv: Already formatted, no change.
hw/ip/pinmux/fpv/tb/pinmux_fpv.sv: Already formatted, no change.
hw/ip/pinmux/rtl/pinmux.sv: Already formatted, no change.
hw/ip/pinmux/fpv/vip/pinmux_assert_fpv.sv: Already formatted, no change.
hw/ip/gpio/rtl/gpio.sv: Already formatted, no change.
hw/ip/gpio/rtl/gpio_reg_pkg.sv: Already formatted, no change.
hw/ip/gpio/dv/env/gpio_env_cov.sv: Already formatted, no change.
hw/ip/gpio/dv/env/gpio_env.sv: Already formatted, no change.
hw/ip/gpio/dv/env/gpio_env_cfg.sv: Already formatted, no change.
hw/ip/gpio/dv/env/gpio_env_pkg.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_common_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_random_dout_din_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_rand_intr_trigger_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_dout_din_regs_random_rw_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_sanity_vseq.sv: Already formatted, no change.
hw/ip/gpio/rtl/gpio_reg_top.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_vseq_list.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_base_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_stress_all_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_random_long_reg_writes_reg_reads_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_intr_rand_pgm_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_filter_stress_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/tests/gpio_base_test.sv: Already formatted, no change.
hw/ip/gpio/dv/sva/gpio_bind.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_full_random_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/tests/gpio_test_pkg.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr_ctrl.sv: Already formatted, no change.
hw/ip/gpio/dv/tb/tb.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr_por.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr_pkg.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr_reg_pkg.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr_info.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_mix_columns.sv: Already formatted, no change.
hw/ip/rstmgr/rtl/rstmgr_reg_top.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sbox_canright_masked_noreuse.sv: Already formatted, no change.
hw/ip/gpio/dv/env/seq_lib/gpio_intr_with_filter_rand_intr_event_vseq.sv: Already formatted, no change.
hw/ip/gpio/dv/env/gpio_scoreboard.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sbox_canright.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_mix_single_column.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_prng.sv: Already formatted, no change.
hw/ip/aes/rtl/aes.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_ctr.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sub_bytes.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sbox.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_reg_pkg.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_shift_rows.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_key_expand.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sbox_canright_pkg.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_reg_status.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_pkg.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sbox_canright_masked.sv: Already formatted, no change.
hw/ip/aes/pre_dv/aes_sbox_lec/aes_sbox_masked_wrapper.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_cipher_core.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_env_cfg.sv: Already formatted, no change.
hw/ip/aes/pre_dv/aes_sbox_tb/rtl/aes_sbox_tb.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_virtual_sequencer.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_reg_top.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_env_cov.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_seq_item.sv: Already formatted, no change.
hw/ip/pinmux/rtl/pinmux_reg_top.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_message_item.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_env.sv: Already formatted, no change.
hw/ip/aes/dv/env/seq_lib/aes_vseq_list.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_env_pkg.sv: Already formatted, no change.
hw/ip/aes/dv/env/seq_lib/aes_common_vseq.sv: Already formatted, no change.
hw/ip/aes/dv/env/seq_lib/aes_stress_vseq.sv: Already formatted, no change.
hw/ip/aes/dv/env/seq_lib/aes_wake_up_vseq.sv: Already formatted, no change.
hw/ip/aes/dv/tests/aes_sanity_test.sv: Already formatted, no change.
hw/ip/aes/dv/aes_model_dpi/aes_model_dpi_pkg.sv: Already formatted, no change.
hw/ip/aes/dv/tests/aes_wake_up_test.sv: Already formatted, no change.
hw/ip/aes/dv/env/aes_scoreboard.sv: Already formatted, no change.
hw/ip/aes/dv/tests/aes_base_test.sv: Already formatted, no change.
hw/ip/aes/dv/tests/aes_test_pkg.sv: Already formatted, no change.
hw/ip/aes/dv/tests/aes_stress_test.sv: Already formatted, no change.
hw/ip/aes/dv/sva/aes_bind.sv: Already formatted, no change.
hw/ip/aes/dv/tb/tb.sv: Already formatted, no change.
hw/ip/otp_ctrl/rtl/otp_ctrl_reg_pkg.sv: Already formatted, no change.
hw/ip/otp_ctrl/rtl/otp_ctrl.sv: Already formatted, no change.
hw/ip/otp_ctrl/rtl/otp_ctrl_pkg.sv: Already formatted, no change.
hw/ip/otp_ctrl/rtl/otp_ctrl_scrmbl.sv: Already formatted, no change.
hw/ip/otp_ctrl/dv/sva/otp_ctrl_bind.sv: Already formatted, no change.
hw/ip/hmac/rtl/hmac_reg_pkg.sv: Already formatted, no change.
hw/ip/hmac/rtl/sha2.sv: Already formatted, no change.
hw/ip/hmac/rtl/hmac.sv: Already formatted, no change.
hw/ip/otp_ctrl/rtl/otp_ctrl_reg_top.sv: Already formatted, no change.
hw/ip/hmac/rtl/sha2_pad.sv: Already formatted, no change.
hw/ip/hmac/rtl/hmac_reg_top.sv: Already formatted, no change.
hw/ip/hmac/dv/cryptoc_dpi/cryptoc_dpi_pkg.sv: Already formatted, no change.
hw/ip/hmac/dv/env/hmac_env.sv: Already formatted, no change.
hw/ip/hmac/dv/env/hmac_env_cfg.sv: Already formatted, no change.
hw/ip/hmac/dv/env/hmac_env_cov.sv: Already formatted, no change.
hw/ip/hmac/dv/env/hmac_scoreboard.sv: Already formatted, no change.
hw/ip/hmac/dv/env/hmac_env_pkg.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_sanity_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_error_vseq.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_sbox_lut.sv: *** Some token partitions failed to complete within the search limit:
>>[localparam logic [ 7 : 0 ] SBOX_FWD [ 256 ] = '{ 8 'h 63 , 8 'h 7C , 8 'h 77 , 8 'h 7B , 8 'h F2 , 8 'h 6B , 8 'h 6F , 8 'h C5 , 8 'h 30 , 8 'h 01 , 8 'h 67 , 8 'h 2B , 8 'h FE , 8 'h D7 , 8 'h AB , 8 'h 76 , 8 'h CA , 8 'h 82 , 8 'h C9 , 8 'h 7D , 8 'h FA , 8 'h 59 , 8 'h 47 , 8 'h F0 , 8 'h AD , 8 'h D4 , 8 'h A2 , 8 'h AF , 8 'h 9C , 8 'h A4 , 8 'h 72 , 8 'h C0 , 8 'h B7 , 8 'h FD , 8 'h 93 , 8 'h 26 , 8 'h 36 , 8 'h 3F , 8 'h F7 , 8 'h CC , 8 'h 34 , 8 'h A5 , 8 'h E5 , 8 'h F1 , 8 'h 71 , 8 'h D8 , 8 'h 31 , 8 'h 15 , 8 'h 04 , 8 'h C7 , 8 'h 23 , 8 'h C3 , 8 'h 18 , 8 'h 96 , 8 'h 05 , 8 'h 9A , 8 'h 07 , 8 'h 12 , 8 'h 80 , 8 'h E2 , 8 'h EB , 8 'h 27 , 8 'h B2 , 8 'h 75 , 8 'h 09 , 8 'h 83 , 8 'h 2C , 8 'h 1A , 8 'h 1B , 8 'h 6E , 8 'h 5A , 8 'h A0 , 8 'h 52 , 8 'h 3B , 8 'h D6 , 8 'h B3 , 8 'h 29 , 8 'h E3 , 8 'h 2F , 8 'h 84 , 8 'h 53 , 8 'h D1 , 8 'h 00 , 8 'h ED , 8 'h 20 , 8 'h FC , 8 'h B1 , 8 'h 5B , 8 'h 6A , 8 'h CB , 8 'h BE , 8 'h 39 , 8 'h 4A , 8 'h 4C , 8 'h 58 , 8 'h CF , 8 'h D0 , 8 'h EF , 8 'h AA , 8 'h FB , 8 'h 43 , 8 'h 4D , 8 'h 33 , 8 'h 85 , 8 'h 45 , 8 'h F9 , 8 'h 02 , 8 'h 7F , 8 'h 50 , 8 'h 3C , 8 'h 9F , 8 'h A8 , 8 'h 51 , 8 'h A3 , 8 'h 40 , 8 'h 8F , 8 'h 92 , 8 'h 9D , 8 'h 38 , 8 'h F5 , 8 'h BC , 8 'h B6 , 8 'h DA , 8 'h 21 , 8 'h 10 , 8 'h FF , 8 'h F3 , 8 'h D2 , 8 'h CD , 8 'h 0C , 8 'h 13 , 8 'h EC , 8 'h 5F , 8 'h 97 , 8 'h 44 , 8 'h 17 , 8 'h C4 , 8 'h A7 , 8 'h 7E , 8 'h 3D , 8 'h 64 , 8 'h 5D , 8 'h 19 , 8 'h 73 , 8 'h 60 , 8 'h 81 , 8 'h 4F , 8 'h DC , 8 'h 22 , 8 'h 2A , 8 'h 90 , 8 'h 88 , 8 'h 46 , 8 'h EE , 8 'h B8 , 8 'h 14 , 8 'h DE , 8 'h 5E , 8 'h 0B , 8 'h DB , 8 'h E0 , 8 'h 32 , 8 'h 3A , 8 'h 0A , 8 'h 49 , 8 'h 06 , 8 'h 24 , 8 'h 5C , 8 'h C2 , 8 'h D3 , 8 'h AC , 8 'h 62 , 8 'h 91 , 8 'h 95 , 8 'h E4 , 8 'h 79 , 8 'h E7 , 8 'h C8 , 8 'h 37 , 8 'h 6D , 8 'h 8D , 8 'h D5 , 8 'h 4E , 8 'h A9 , 8 'h 6C , 8 'h 56 , 8 'h F4 , 8 'h EA , 8 'h 65 , 8 'h 7A , 8 'h AE , 8 'h 08 , 8 'h BA , 8 'h 78 , 8 'h 25 , 8 'h 2E , 8 'h 1C , 8 'h A6 , 8 'h B4 , 8 'h C6 , 8 'h E8 , 8 'h DD , 8 'h 74 , 8 'h 1F , 8 'h 4B , 8 'h BD , 8 'h 8B , 8 'h 8A , 8 'h 70 , 8 'h 3E , 8 'h B5 , 8 'h 66 , 8 'h 48 , 8 'h 03 , 8 'h F6 , 8 'h 0E , 8 'h 61 , 8 'h 35 , 8 'h 57 , 8 'h B9 , 8 'h 86 , 8 'h C1 , 8 'h 1D , 8 'h 9E , 8 'h E1 , 8 'h F8 , 8 'h 98 , 8 'h 11 , 8 'h 69 , 8 'h D9 , 8 'h 8E , 8 'h 94 , 8 'h 9B , 8 'h 1E , 8 'h 87 , 8 'h E9 , 8 'h CE , 8 'h 55 , 8 'h 28 , 8 'h DF , 8 'h 8C , 8 'h A1 , 8 'h 89 , 8 'h 0D , 8 'h BF , 8 'h E6 , 8 'h 42 , 8 'h 68 , 8 'h 41 , 8 'h 99 , 8 'h 2D , 8 'h 0F , 8 'h B0 , 8 'h 54 , 8 'h BB , 8 'h 16 } ;], policy: fit-else-expand, (origin: "localparam ...BB, 8'h16};")
>>[localparam logic [ 7 : 0 ] SBOX_INV [ 256 ] = '{ 8 'h 52 , 8 'h 09 , 8 'h 6a , 8 'h d5 , 8 'h 30 , 8 'h 36 , 8 'h a5 , 8 'h 38 , 8 'h bf , 8 'h 40 , 8 'h a3 , 8 'h 9e , 8 'h 81 , 8 'h f3 , 8 'h d7 , 8 'h fb , 8 'h 7c , 8 'h e3 , 8 'h 39 , 8 'h 82 , 8 'h 9b , 8 'h 2f , 8 'h ff , 8 'h 87 , 8 'h 34 , 8 'h 8e , 8 'h 43 , 8 'h 44 , 8 'h c4 , 8 'h de , 8 'h e9 , 8 'h cb , 8 'h 54 , 8 'h 7b , 8 'h 94 , 8 'h 32 , 8 'h a6 , 8 'h c2 , 8 'h 23 , 8 'h 3d , 8 'h ee , 8 'h 4c , 8 'h 95 , 8 'h 0b , 8 'h 42 , 8 'h fa , 8 'h c3 , 8 'h 4e , 8 'h 08 , 8 'h 2e , 8 'h a1 , 8 'h 66 , 8 'h 28 , 8 'h d9 , 8 'h 24 , 8 'h b2 , 8 'h 76 , 8 'h 5b , 8 'h a2 , 8 'h 49 , 8 'h 6d , 8 'h 8b , 8 'h d1 , 8 'h 25 , 8 'h 72 , 8 'h f8 , 8 'h f6 , 8 'h 64 , 8 'h 86 , 8 'h 68 , 8 'h 98 , 8 'h 16 , 8 'h d4 , 8 'h a4 , 8 'h 5c , 8 'h cc , 8 'h 5d , 8 'h 65 , 8 'h b6 , 8 'h 92 , 8 'h 6c , 8 'h 70 , 8 'h 48 , 8 'h 50 , 8 'h fd , 8 'h ed , 8 'h b9 , 8 'h da , 8 'h 5e , 8 'h 15 , 8 'h 46 , 8 'h 57 , 8 'h a7 , 8 'h 8d , 8 'h 9d , 8 'h 84 , 8 'h 90 , 8 'h d8 , 8 'h ab , 8 'h 00 , 8 'h 8c , 8 'h bc , 8 'h d3 , 8 'h 0a , 8 'h f7 , 8 'h e4 , 8 'h 58 , 8 'h 05 , 8 'h b8 , 8 'h b3 , 8 'h 45 , 8 'h 06 , 8 'h d0 , 8 'h 2c , 8 'h 1e , 8 'h 8f , 8 'h ca , 8 'h 3f , 8 'h 0f , 8 'h 02 , 8 'h c1 , 8 'h af , 8 'h bd , 8 'h 03 , 8 'h 01 , 8 'h 13 , 8 'h 8a , 8 'h 6b , 8 'h 3a , 8 'h 91 , 8 'h 11 , 8 'h 41 , 8 'h 4f , 8 'h 67 , 8 'h dc , 8 'h ea , 8 'h 97 , 8 'h f2 , 8 'h cf , 8 'h ce , 8 'h f0 , 8 'h b4 , 8 'h e6 , 8 'h 73 , 8 'h 96 , 8 'h ac , 8 'h 74 , 8 'h 22 , 8 'h e7 , 8 'h ad , 8 'h 35 , 8 'h 85 , 8 'h e2 , 8 'h f9 , 8 'h 37 , 8 'h e8 , 8 'h 1c , 8 'h 75 , 8 'h df , 8 'h 6e , 8 'h 47 , 8 'h f1 , 8 'h 1a , 8 'h 71 , 8 'h 1d , 8 'h 29 , 8 'h c5 , 8 'h 89 , 8 'h 6f , 8 'h b7 , 8 'h 62 , 8 'h 0e , 8 'h aa , 8 'h 18 , 8 'h be , 8 'h 1b , 8 'h fc , 8 'h 56 , 8 'h 3e , 8 'h 4b , 8 'h c6 , 8 'h d2 , 8 'h 79 , 8 'h 20 , 8 'h 9a , 8 'h db , 8 'h c0 , 8 'h fe , 8 'h 78 , 8 'h cd , 8 'h 5a , 8 'h f4 , 8 'h 1f , 8 'h dd , 8 'h a8 , 8 'h 33 , 8 'h 88 , 8 'h 07 , 8 'h c7 , 8 'h 31 , 8 'h b1 , 8 'h 12 , 8 'h 10 , 8 'h 59 , 8 'h 27 , 8 'h 80 , 8 'h ec , 8 'h 5f , 8 'h 60 , 8 'h 51 , 8 'h 7f , 8 'h a9 , 8 'h 19 , 8 'h b5 , 8 'h 4a , 8 'h 0d , 8 'h 2d , 8 'h e5 , 8 'h 7a , 8 'h 9f , 8 'h 93 , 8 'h c9 , 8 'h 9c , 8 'h ef , 8 'h a0 , 8 'h e0 , 8 'h 3b , 8 'h 4d , 8 'h ae , 8 'h 2a , 8 'h f5 , 8 'h b0 , 8 'h c8 , 8 'h eb , 8 'h bb , 8 'h 3c , 8 'h 83 , 8 'h 53 , 8 'h 99 , 8 'h 61 , 8 'h 17 , 8 'h 2b , 8 'h 04 , 8 'h 7e , 8 'h ba , 8 'h 77 , 8 'h d6 , 8 'h 26 , 8 'h e1 , 8 'h 69 , 8 'h 14 , 8 'h 63 , 8 'h 55 , 8 'h 21 , 8 'h 0c , 8 'h 7d } ;], policy: fit-else-expand, (origin: "localparam ...0c, 8'h7d};")
*** end of partially formatted partition list
[other error status]
hw/ip/hmac/rtl/hmac_core.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_stress_all_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_test_vectors_hmac_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_common_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_vseq_list.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_test_vectors_sha_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_long_msg_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_datapath_stress_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_back_pressure_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/tests/hmac_base_test.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_base_vseq.sv: Already formatted, no change.
hw/ip/hmac/dv/sva/hmac_bind.sv: Already formatted, no change.
hw/ip/hmac/dv/tb/tb.sv: Already formatted, no change.
hw/ip/hmac/dv/tests/hmac_test_pkg.sv: Already formatted, no change.
hw/ip/hmac/dv/env/seq_lib/hmac_burst_wr_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/rtl/timer_core.sv: Already formatted, no change.
hw/ip/rv_timer/rtl/rv_timer.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_core.sv: *** Some token partitions failed to complete within the search limit:
>>[assign cipher_op = ( aes_mode_q == AES_ECB && aes_op_q == AES_ENC ) ? CIPH_FWD : ( aes_mode_q == AES_ECB && aes_op_q == AES_DEC ) ? CIPH_INV : ( aes_mode_q == AES_CBC && aes_op_q == AES_ENC ) ? CIPH_FWD : ( aes_mode_q == AES_CBC && aes_op_q == AES_DEC ) ? CIPH_INV : ( aes_mode_q == AES_CFB ) ? CIPH_FWD : ( aes_mode_q == AES_OFB ) ? CIPH_FWD : ( aes_mode_q == AES_CTR ) ? CIPH_FWD : CIPH_FWD ;], policy: fit-else-expand, (origin: "assign ciph...: CIPH_FWD;")
*** end of partially formatted partition list
[other error status]
hw/ip/rv_timer/dv/env/rv_timer_env_cfg.sv: Already formatted, no change.
hw/ip/rv_timer/rtl/rv_timer_reg_pkg.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/rv_timer_env_pkg.sv: Already formatted, no change.
hw/ip/rv_timer/rtl/rv_timer_reg_top.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_common_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/rv_timer_env_cov.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/rv_timer_env.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_random_reset_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_vseq_list.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_disabled_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_sanity_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/rv_timer_scoreboard.sv: Re-formatted text does not match formatted text; formatting failed to converge!  Please file a bug.
Original: --lines: 
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_scoreboard extends cip_base_scoreboard #(.CFG_T (rv_timer_env_cfg),
                                                        .RAL_T (rv_timer_reg_block),
                                                        .COV_T (rv_timer_env_cov));

  `uvm_component_utils(rv_timer_scoreboard)
  `uvm_component_new

  // local variables
  local uint64 prescale[NUM_HARTS];
  local uint64 step[NUM_HARTS];
  local uint64 timer_val[NUM_HARTS];
  local uint64 compare_val[NUM_HARTS][NUM_TIMERS];
  local uint   num_clks[NUM_HARTS][NUM_TIMERS];
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers_prev;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_interrupt;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] ignore_period;
  local bit [NUM_HARTS-1:0] num_clk_update_due;
  local bit ctimecmp_update_on_fly;

  // expected values
  local uint intr_status_exp[NUM_HARTS];

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    compute_and_check_interrupt();
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel = DataChannel);
    uvm_reg csr;
    string  csr_name;
    bit     do_read_check   = 1'b1;
    bit     write           = item.is_write();
    uvm_reg_addr_t csr_addr = get_normalized_addr(item.a_addr);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      csr_name = csr.get_name();
    end else begin
      `uvm_fatal(`gfn, $sformatf("Access unexpected addr 0x%0h", csr_addr))
    end

    if (!write && channel == AddrChannel) begin
      if (!uvm_re_match("intr_state*", csr_name)) begin
        for (int i = 0; i < NUM_HARTS; i++) begin
          if (csr_name == $sformatf("intr_state%0d", i)) begin
            if ((intr_status_exp[i] != csr.get_mirrored_value()) & (ignore_period[i] == 'b0)) begin
              void'(csr.predict(.value(intr_status_exp[i]), .kind(UVM_PREDICT_READ)));
            end
            break;
          end
          else if (i == (NUM_HARTS - 1)) begin
            `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
          end
        end
      end
    end

    // grab write transactions from address channel; grab completed transactions from data channel

    // if incoming access is a write to a valid csr, then make updates right away
    if (write && channel == AddrChannel) begin
      void'(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));

      // process the csr req
      case (1)
        (!uvm_re_match("ctrl*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_timers[i][j] = get_reg_fld_mirror_value(ral, "ctrl", $sformatf("active_%0d", j));
            end
            //Sample all timers active coverage for each hart
            if (cfg.en_cov) cov.ctrl_reg_cov_obj[i].timer_active_cg.sample(en_timers[i]);
          end
        end
        (!uvm_re_match("cfg*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            step[i]     = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "step");
            prescale[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "prescale");
          end
        end
        (!uvm_re_match("timer_v_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][31:0] = get_reg_fld_mirror_value(
                                     ral, $sformatf("timer_v_lower%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("timer_v_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][63:32] = get_reg_fld_mirror_value(
                                      ral, $sformatf("timer_v_upper%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("compare_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_lower_str = $sformatf("compare_lower%0d_%0d", i, j);
              if (csr_name == compare_lower_str) begin
                compare_val[i][j][31:0] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{"rv_timer_sticky_intr_pin",
                                        $sformatf("%0d", timer_idx)}].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{"rv_timer_sticky_intr_pin",
                                        $sformatf("%0d", timer_idx)}].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("compare_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_upper_str = $sformatf("compare_upper%0d_%0d", i, j);
              if (csr_name == compare_upper_str) begin
                compare_val[i][j][63:32] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{"rv_timer_sticky_intr_pin",
                                        $sformatf("%0d", timer_idx)}].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{"rv_timer_sticky_intr_pin",
                                        $sformatf("%0d", timer_idx)}].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("intr_enable*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_interrupt[i][j] = get_reg_fld_mirror_value(
                                       ral, $sformatf("intr_enable%0d", i), $sformatf("ie_%0d", j));
            end
          end
        end
        (!uvm_re_match("intr_state*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_state_str = $sformatf("intr_state%0d", i);
            if (csr_name == intr_state_str) begin
              // Intr_state reg is W1C, update expected status with RAL mirrored val
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int timer_idx = i * NUM_TIMERS + j;
                if (item.a_data[j] == 1) begin
                  if (en_timers[i][j] == 0) begin
                    intr_status_exp[i][j] = 0;
                    if (cfg.en_cov) begin
                      cov.sticky_intr_cov[{"rv_timer_sticky_intr_pin",
                                          $sformatf("%0d", timer_idx)}].sample(1'b0);
                    end
                  end
                  else if (cfg.en_cov) begin // sticky interrupt
                    cov.sticky_intr_cov[{"rv_timer_sticky_intr_pin",
                                        $sformatf("%0d", timer_idx)}].sample(1'b1);
                  end
                end
              end
              break;
            end
          end
        end
        (!uvm_re_match("intr_test*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_test_str = $sformatf("intr_test%0d", i);
            if (csr_name == intr_test_str) begin
              uint intr_test_val = item.a_data;
              for (int j = 0 ; j < NUM_TIMERS; j++) begin
                int intr_pin_idx = i * NUM_TIMERS + j;
                if (intr_test_val[j]) intr_status_exp[i][j] = intr_test_val[j];
                //Sample intr_test coverage for each bit of test reg
                if (cfg.en_cov) cov.intr_test_cg.sample(intr_pin_idx, intr_test_val[j],
                                                        en_interrupt[i][j], intr_status_exp[i][j]);
              end
              break;
            end
          end
        end
        default: begin
          `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
        end
      endcase
    end

    if (channel == DataChannel) begin
      // Check all interrupts in DataChannel of every Read/Write except when ctimecmp updated
      // during timer active. This scenario is checked in base sequence by reading the intr_state.
      // Ignored checking here because sticky intr_pin update has one cycle delay.
      // TODO #1464: temp constraint, if support external reg, this can be removed
      if (!ctimecmp_update_on_fly) check_interrupt_pin();
      ctimecmp_update_on_fly = 0;

      // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
      if (!write) begin
        // exclude read check for timer_val* reg if read happended when timer is enabled
        if (!uvm_re_match("timer_v_*", csr_name)) begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (!uvm_re_match($sformatf("timer_v_*%0d", i), csr_name)) begin
              if (en_timers[i] == 0) begin
                `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
              end
              else begin
                if (!uvm_re_match("timer_v_lower*", csr_name)) begin
                  timer_val[i][31:0] = item.d_data;
                  // on timer_val read update num_clks
                  num_clk_update_due[i] = 1'b1;
                end
                else begin
                  timer_val[i][63:32] = item.d_data;
                end
              end
              break;
            end
            else if (i == (NUM_HARTS - 1)) begin
              `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
            end
          end
        end
        // Read happened for other registers
        else if (do_read_check) begin
          `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
        end

        void'(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
      end
    end
  endtask

  // Task : compute_and_check_interrupt
  // wait for expected # of clocks and check for interrupt state reg and pin
  virtual task compute_and_check_interrupt();
    bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] reset_count;

    fork
      begin
        forever begin : compute_num_clks
          // calculate number of clocks required to have interrupt
          @(en_timers or num_clk_update_due);
          wait(under_reset == 0);
          foreach (en_timers[i, j]) begin
            uint64 mtime_diff = compare_val[i][j] - timer_val[i];
            num_clks[i][j] = ((mtime_diff / step[i]) +
                              ((mtime_diff % step[i]) != 0)) * (prescale[i] + 1) + 1;
          end
          // reset count if timer is enabled and num_clks got updated
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (num_clk_update_due[i]) reset_count[i] = en_timers[i];
          end
          num_clk_update_due = '0;
        end // compute_num_clks
      end
    join_none

    forever begin : wait_for_interrupt
      @(en_timers or under_reset);
      wait(under_reset == 0);
      // fork a thread for enabled timer on all enabled hart
      foreach (en_timers[i, j]) begin
        automatic int a_i = i;
        automatic int a_j = j;
        fork
          if (en_timers[a_i][a_j] & !en_timers_prev[a_i][a_j]) begin
            fork
              begin
                uint64 count = 0;
                en_timers_prev[a_i][a_j] = 1'b1;
                forever begin
                  @cfg.clk_rst_vif.cb;
                  count = count + 1;
                  if (reset_count[a_i][a_j] == 1'b1) begin
                    count = 0;
                    reset_count[a_i][a_j] = 1'b0;
                  end
                  if (count >= num_clks[a_i][a_j]) break;
                end
                // enabling one clock cycle of ignore period
                ignore_period[a_i][a_j] = 1'b1;
                `uvm_info(`gfn, $sformatf("Timer expired check for interrupt"), UVM_LOW)
                // Update exp val and predict it in read address_channel
                intr_status_exp[a_i][a_j] = 1'b1;
                check_interrupt_pin();
                if (cfg.en_cov) begin
                  int timer_idx = a_i * NUM_TIMERS + a_j;
                  //Sample cfg coverage for each timer
                  cov.cfg_values_cov_obj[timer_idx].timer_cfg_cg.sample(step[a_i],
                      prescale[a_i], timer_val[a_i], compare_val[a_i][a_j]);
                  //Sample toggle coverage for each prescale bit
                  for (int i = 0; i < 12; i++) begin
                    cov.rv_timer_prescale_values_cov_obj[a_i][i].sample(prescale[a_i][i]);
                  end
                end
                @cfg.clk_rst_vif.cb;
                ignore_period[a_i][a_j] = 1'b0;
              end
              begin
                wait((en_timers[a_i][a_j] == 0) | (under_reset == 1));
              end
            join_any
            en_timers_prev[a_i][a_j] = 1'b0;
            // kill forked threads if timer disabled or interrupt occured or under reset
            disable fork;
          end
        join_none
      end
    end // wait_for_interrupt
  endtask : compute_and_check_interrupt

  // function : check_interrupt_pin
  // check all interrupt output pins with expected intr state & pin enable
  function void check_interrupt_pin();
    for (int i = 0; i < NUM_HARTS; i++) begin
      for (int j = 0; j < NUM_TIMERS; j++) begin
        int intr_pin_idx = i * NUM_TIMERS + j;
        `DV_CHECK_CASE_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)),
                          (intr_status_exp[i][j] & en_interrupt[i][j]))
        //Sample interrupt and interrupt pin coverage for each timer
        if (cfg.en_cov) begin
          cov.intr_cg.sample(intr_pin_idx, en_interrupt[i][j], intr_status_exp[i][j]);
          cov.intr_pins_cg.sample(intr_pin_idx, cfg.intr_vif.sample_pin(.idx(intr_pin_idx)));
        end
      end
    end
  endfunction

  virtual function void reset(string kind = "HARD");
    super.reset(kind);
    // reset the local values
    step            = '{default:1};
    prescale        = '{default:0};
    timer_val       = '{default:0};
    compare_val     = '{default:'1};
    en_timers       = '{default:0};
    en_interrupt    = '{default:0};
    intr_status_exp = '{default:0};
    ignore_period   = '{default:0};
    en_timers_prev  = '{default:0};
    ctimecmp_update_on_fly = 0;
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
  endfunction

endclass
Formatted:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_scoreboard extends cip_base_scoreboard#(
    .CFG_T(rv_timer_env_cfg), .RAL_T(rv_timer_reg_block), .COV_T(rv_timer_env_cov)
);

  `uvm_component_utils(rv_timer_scoreboard)
  `uvm_component_new

  // local variables
  local uint64 prescale[NUM_HARTS];
  local uint64 step[NUM_HARTS];
  local uint64 timer_val[NUM_HARTS];
  local uint64 compare_val[NUM_HARTS][NUM_TIMERS];
  local uint num_clks[NUM_HARTS][NUM_TIMERS];
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers_prev;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_interrupt;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] ignore_period;
  local bit [NUM_HARTS-1:0] num_clk_update_due;
  local bit ctimecmp_update_on_fly;

  // expected values
  local uint intr_status_exp[NUM_HARTS];

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    compute_and_check_interrupt();
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel = DataChannel);
    uvm_reg csr;
    string csr_name;
    bit do_read_check = 1'b1;
    bit write = item.is_write();
    uvm_reg_addr_t csr_addr = get_normalized_addr(item.a_addr);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      csr_name = csr.get_name();
    end else begin
      `uvm_fatal(`gfn, $sformatf("Access unexpected addr 0x%0h", csr_addr))
    end

    if (!write && channel == AddrChannel) begin
      if (!uvm_re_match("intr_state*", csr_name)) begin
        for (int i = 0; i < NUM_HARTS; i++) begin
          if (csr_name == $sformatf("intr_state%0d", i)) begin
            if ((intr_status_exp[i] != csr.get_mirrored_value()) & (ignore_period[i] == 'b0)) begin
              void'(csr.predict(.value(intr_status_exp[i]), .kind(UVM_PREDICT_READ)));
            end
            break;
          end else if (i == (NUM_HARTS - 1)) begin
            `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
          end
        end
      end
    end

    // grab write transactions from address channel; grab completed transactions from data channel

    // if incoming access is a write to a valid csr, then make updates right away
    if (write && channel == AddrChannel) begin
      void'(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));

      // process the csr req
      case (1)
        (!uvm_re_match("ctrl*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_timers[i][j] = get_reg_fld_mirror_value(ral, "ctrl", $sformatf("active_%0d", j));
            end
            //Sample all timers active coverage for each hart
            if (cfg.en_cov) cov.ctrl_reg_cov_obj[i].timer_active_cg.sample(en_timers[i]);
          end
        end
        (!uvm_re_match("cfg*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            step[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "step");
            prescale[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "prescale");
          end
        end
        (!uvm_re_match("timer_v_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][31:0] =
                get_reg_fld_mirror_value(ral, $sformatf("timer_v_lower%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("timer_v_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][63:32] =
                get_reg_fld_mirror_value(ral, $sformatf("timer_v_upper%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("compare_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_lower_str = $sformatf("compare_lower%0d_%0d", i, j);
              if (csr_name == compare_lower_str) begin
                compare_val[i][j][31:0] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("compare_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_upper_str = $sformatf("compare_upper%0d_%0d", i, j);
              if (csr_name == compare_upper_str) begin
                compare_val[i][j][63:32] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("intr_enable*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_interrupt[i][j] = get_reg_fld_mirror_value(ral, $sformatf("intr_enable%0d", i),
                                                            $sformatf("ie_%0d", j));
            end
          end
        end
        (!uvm_re_match("intr_state*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_state_str = $sformatf("intr_state%0d", i);
            if (csr_name == intr_state_str) begin
              // Intr_state reg is W1C, update expected status with RAL mirrored val
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int timer_idx = i * NUM_TIMERS + j;
                if (item.a_data[j] == 1) begin
                  if (en_timers[i][j] == 0) begin
                    intr_status_exp[i][j] = 0;
                    if (cfg.en_cov) begin
                      cov.sticky_intr_cov[{
                        "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                      }].sample(1'b0);
                    end
                  end else if (cfg.en_cov) begin  // sticky interrupt
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b1);
                  end
                end
              end
              break;
            end
          end
        end
        (!uvm_re_match("intr_test*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_test_str = $sformatf("intr_test%0d", i);
            if (csr_name == intr_test_str) begin
              uint intr_test_val = item.a_data;
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int intr_pin_idx = i * NUM_TIMERS + j;
                if (intr_test_val[j]) intr_status_exp[i][j] = intr_test_val[j];
                //Sample intr_test coverage for each bit of test reg
                if (cfg.en_cov)
                  cov.intr_test_cg.sample(intr_pin_idx, intr_test_val[j], en_interrupt[i][j],
                                          intr_status_exp[i][j]);
              end
              break;
            end
          end
        end
        default: begin
          `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
        end
      endcase
    end

    if (channel == DataChannel) begin
      // Check all interrupts in DataChannel of every Read/Write except when ctimecmp updated
      // during timer active. This scenario is checked in base sequence by reading the intr_state.
      // Ignored checking here because sticky intr_pin update has one cycle delay.
      // TODO #1464: temp constraint, if support external reg, this can be removed
      if (!ctimecmp_update_on_fly) check_interrupt_pin();
      ctimecmp_update_on_fly = 0;

      // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
      if (!write) begin
        // exclude read check for timer_val* reg if read happended when timer is enabled
        if (!uvm_re_match("timer_v_*", csr_name)) begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (!uvm_re_match($sformatf("timer_v_*%0d", i), csr_name)) begin
              if (en_timers[i] == 0) begin
                `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
              end else begin
                if (!uvm_re_match("timer_v_lower*", csr_name)) begin
                  timer_val[i][31:0] = item.d_data;
                  // on timer_val read update num_clks
                  num_clk_update_due[i] = 1'b1;
                end else begin
                  timer_val[i][63:32] = item.d_data;
                end
              end
              break;
            end else if (i == (NUM_HARTS - 1)) begin
              `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
            end
          end
        end  // Read happened for other registers
            else
        if (do_read_check) begin
          `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
        end

        void'(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
      end
    end
  endtask

  // Task : compute_and_check_interrupt
  // wait for expected # of clocks and check for interrupt state reg and pin
  virtual task compute_and_check_interrupt();
    bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] reset_count;

    fork
      begin
        forever begin : compute_num_clks
          // calculate number of clocks required to have interrupt
          @(en_timers or num_clk_update_due);
          wait(under_reset == 0);
          foreach (en_timers[i, j]) begin
            uint64 mtime_diff = compare_val[i][j] - timer_val[i];
            num_clks[i][j] =
                ((mtime_diff / step[i]) + ((mtime_diff % step[i]) != 0)) * (prescale[i] + 1) + 1;
          end
          // reset count if timer is enabled and num_clks got updated
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (num_clk_update_due[i]) reset_count[i] = en_timers[i];
          end
          num_clk_update_due = '0;
        end  // compute_num_clks
      end
    join_none

    forever begin : wait_for_interrupt
      @(en_timers or under_reset);
      wait(under_reset == 0);
      // fork a thread for enabled timer on all enabled hart
      foreach (en_timers[i, j]) begin
        automatic int a_i = i;
        automatic int a_j = j;
        fork
          if (en_timers[a_i][a_j] & !en_timers_prev[a_i][a_j]) begin
            fork
              begin
                uint64 count = 0;
                en_timers_prev[a_i][a_j] = 1'b1;
                forever begin
                  @cfg.clk_rst_vif.cb;
                  count = count + 1;
                  if (reset_count[a_i][a_j] == 1'b1) begin
                    count = 0;
                    reset_count[a_i][a_j] = 1'b0;
                  end
                  if (count >= num_clks[a_i][a_j]) break;
                end
                // enabling one clock cycle of ignore period
                ignore_period[a_i][a_j] = 1'b1;
                `uvm_info(`gfn, $sformatf("Timer expired check for interrupt"), UVM_LOW)
                // Update exp val and predict it in read address_channel
                intr_status_exp[a_i][a_j] = 1'b1;
                check_interrupt_pin();
                if (cfg.en_cov) begin
                  int timer_idx = a_i * NUM_TIMERS + a_j;
                  //Sample cfg coverage for each timer
                  cov.cfg_values_cov_obj[timer_idx].timer_cfg_cg.sample(
                      step[a_i], prescale[a_i], timer_val[a_i], compare_val[a_i][a_j]);
                  //Sample toggle coverage for each prescale bit
                  for (int i = 0; i < 12; i++) begin
                    cov.rv_timer_prescale_values_cov_obj[a_i][i].sample(prescale[a_i][i]);
                  end
                end
                @cfg.clk_rst_vif.cb;
                ignore_period[a_i][a_j] = 1'b0;
              end
              begin
                wait((en_timers[a_i][a_j] == 0) | (under_reset == 1));
              end
            join_any
            en_timers_prev[a_i][a_j] = 1'b0;
            // kill forked threads if timer disabled or interrupt occured or under reset
            disable fork;
          end
        join_none
      end
    end  // wait_for_interrupt
  endtask : compute_and_check_interrupt

  // function : check_interrupt_pin
  // check all interrupt output pins with expected intr state & pin enable
  function void check_interrupt_pin();
    for (int i = 0; i < NUM_HARTS; i++) begin
      for (int j = 0; j < NUM_TIMERS; j++) begin
        int intr_pin_idx = i * NUM_TIMERS + j;
        `DV_CHECK_CASE_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)),
                          (intr_status_exp[i][j] & en_interrupt[i][j]))
        //Sample interrupt and interrupt pin coverage for each timer
        if (cfg.en_cov) begin
          cov.intr_cg.sample(intr_pin_idx, en_interrupt[i][j], intr_status_exp[i][j]);
          cov.intr_pins_cg.sample(intr_pin_idx, cfg.intr_vif.sample_pin(.idx(intr_pin_idx)));
        end
      end
    end
  endfunction

  virtual function void reset(string kind = "HARD");
    super.reset(kind);
    // reset the local values
    step = '{default: 1};
    prescale = '{default: 0};
    timer_val = '{default: 0};
    compare_val = '{default: '1};
    en_timers = '{default: 0};
    en_interrupt = '{default: 0};
    intr_status_exp = '{default: 0};
    ignore_period = '{default: 0};
    en_timers_prev = '{default: 0};
    ctimecmp_update_on_fly = 0;
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
  endfunction

endclass
Re-formatted:
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_scoreboard extends cip_base_scoreboard#(
    .CFG_T(rv_timer_env_cfg), .RAL_T(rv_timer_reg_block), .COV_T(rv_timer_env_cov)
);

  `uvm_component_utils(rv_timer_scoreboard)
  `uvm_component_new

  // local variables
  local uint64 prescale[NUM_HARTS];
  local uint64 step[NUM_HARTS];
  local uint64 timer_val[NUM_HARTS];
  local uint64 compare_val[NUM_HARTS][NUM_TIMERS];
  local uint num_clks[NUM_HARTS][NUM_TIMERS];
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers_prev;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_interrupt;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] ignore_period;
  local bit [NUM_HARTS-1:0] num_clk_update_due;
  local bit ctimecmp_update_on_fly;

  // expected values
  local uint intr_status_exp[NUM_HARTS];

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    compute_and_check_interrupt();
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel = DataChannel);
    uvm_reg csr;
    string csr_name;
    bit do_read_check = 1'b1;
    bit write = item.is_write();
    uvm_reg_addr_t csr_addr = get_normalized_addr(item.a_addr);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      csr_name = csr.get_name();
    end else begin
      `uvm_fatal(`gfn, $sformatf("Access unexpected addr 0x%0h", csr_addr))
    end

    if (!write && channel == AddrChannel) begin
      if (!uvm_re_match("intr_state*", csr_name)) begin
        for (int i = 0; i < NUM_HARTS; i++) begin
          if (csr_name == $sformatf("intr_state%0d", i)) begin
            if ((intr_status_exp[i] != csr.get_mirrored_value()) & (ignore_period[i] == 'b0)) begin
              void'(csr.predict(.value(intr_status_exp[i]), .kind(UVM_PREDICT_READ)));
            end
            break;
          end else if (i == (NUM_HARTS - 1)) begin
            `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
          end
        end
      end
    end

    // grab write transactions from address channel; grab completed transactions from data channel

    // if incoming access is a write to a valid csr, then make updates right away
    if (write && channel == AddrChannel) begin
      void'(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));

      // process the csr req
      case (1)
        (!uvm_re_match("ctrl*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_timers[i][j] = get_reg_fld_mirror_value(ral, "ctrl", $sformatf("active_%0d", j));
            end
            //Sample all timers active coverage for each hart
            if (cfg.en_cov) cov.ctrl_reg_cov_obj[i].timer_active_cg.sample(en_timers[i]);
          end
        end
        (!uvm_re_match("cfg*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            step[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "step");
            prescale[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "prescale");
          end
        end
        (!uvm_re_match("timer_v_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][31:0] =
                get_reg_fld_mirror_value(ral, $sformatf("timer_v_lower%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("timer_v_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][63:32] =
                get_reg_fld_mirror_value(ral, $sformatf("timer_v_upper%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("compare_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_lower_str = $sformatf("compare_lower%0d_%0d", i, j);
              if (csr_name == compare_lower_str) begin
                compare_val[i][j][31:0] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("compare_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_upper_str = $sformatf("compare_upper%0d_%0d", i, j);
              if (csr_name == compare_upper_str) begin
                compare_val[i][j][63:32] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("intr_enable*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_interrupt[i][j] = get_reg_fld_mirror_value(ral, $sformatf("intr_enable%0d", i),
                                                            $sformatf("ie_%0d", j));
            end
          end
        end
        (!uvm_re_match("intr_state*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_state_str = $sformatf("intr_state%0d", i);
            if (csr_name == intr_state_str) begin
              // Intr_state reg is W1C, update expected status with RAL mirrored val
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int timer_idx = i * NUM_TIMERS + j;
                if (item.a_data[j] == 1) begin
                  if (en_timers[i][j] == 0) begin
                    intr_status_exp[i][j] = 0;
                    if (cfg.en_cov) begin
                      cov.sticky_intr_cov[{
                        "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                      }].sample(1'b0);
                    end
                  end else if (cfg.en_cov) begin  // sticky interrupt
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b1);
                  end
                end
              end
              break;
            end
          end
        end
        (!uvm_re_match("intr_test*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_test_str = $sformatf("intr_test%0d", i);
            if (csr_name == intr_test_str) begin
              uint intr_test_val = item.a_data;
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int intr_pin_idx = i * NUM_TIMERS + j;
                if (intr_test_val[j]) intr_status_exp[i][j] = intr_test_val[j];
                //Sample intr_test coverage for each bit of test reg
                if (cfg.en_cov)
                  cov.intr_test_cg.sample(intr_pin_idx, intr_test_val[j], en_interrupt[i][j],
                                          intr_status_exp[i][j]);
              end
              break;
            end
          end
        end
        default: begin
          `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
        end
      endcase
    end

    if (channel == DataChannel) begin
      // Check all interrupts in DataChannel of every Read/Write except when ctimecmp updated
      // during timer active. This scenario is checked in base sequence by reading the intr_state.
      // Ignored checking here because sticky intr_pin update has one cycle delay.
      // TODO #1464: temp constraint, if support external reg, this can be removed
      if (!ctimecmp_update_on_fly) check_interrupt_pin();
      ctimecmp_update_on_fly = 0;

      // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
      if (!write) begin
        // exclude read check for timer_val* reg if read happended when timer is enabled
        if (!uvm_re_match("timer_v_*", csr_name)) begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (!uvm_re_match($sformatf("timer_v_*%0d", i), csr_name)) begin
              if (en_timers[i] == 0) begin
                `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
              end else begin
                if (!uvm_re_match("timer_v_lower*", csr_name)) begin
                  timer_val[i][31:0] = item.d_data;
                  // on timer_val read update num_clks
                  num_clk_update_due[i] = 1'b1;
                end else begin
                  timer_val[i][63:32] = item.d_data;
                end
              end
              break;
            end else if (i == (NUM_HARTS - 1)) begin
              `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
            end
          end
        end  // Read happened for other registers
            else if (do_read_check) begin
          `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
        end

        void'(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
      end
    end
  endtask

  // Task : compute_and_check_interrupt
  // wait for expected # of clocks and check for interrupt state reg and pin
  virtual task compute_and_check_interrupt();
    bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] reset_count;

    fork
      begin
        forever begin : compute_num_clks
          // calculate number of clocks required to have interrupt
          @(en_timers or num_clk_update_due);
          wait(under_reset == 0);
          foreach (en_timers[i, j]) begin
            uint64 mtime_diff = compare_val[i][j] - timer_val[i];
            num_clks[i][j] =
                ((mtime_diff / step[i]) + ((mtime_diff % step[i]) != 0)) * (prescale[i] + 1) + 1;
          end
          // reset count if timer is enabled and num_clks got updated
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (num_clk_update_due[i]) reset_count[i] = en_timers[i];
          end
          num_clk_update_due = '0;
        end  // compute_num_clks
      end
    join_none

    forever begin : wait_for_interrupt
      @(en_timers or under_reset);
      wait(under_reset == 0);
      // fork a thread for enabled timer on all enabled hart
      foreach (en_timers[i, j]) begin
        automatic int a_i = i;
        automatic int a_j = j;
        fork
          if (en_timers[a_i][a_j] & !en_timers_prev[a_i][a_j]) begin
            fork
              begin
                uint64 count = 0;
                en_timers_prev[a_i][a_j] = 1'b1;
                forever begin
                  @cfg.clk_rst_vif.cb;
                  count = count + 1;
                  if (reset_count[a_i][a_j] == 1'b1) begin
                    count = 0;
                    reset_count[a_i][a_j] = 1'b0;
                  end
                  if (count >= num_clks[a_i][a_j]) break;
                end
                // enabling one clock cycle of ignore period
                ignore_period[a_i][a_j] = 1'b1;
                `uvm_info(`gfn, $sformatf("Timer expired check for interrupt"), UVM_LOW)
                // Update exp val and predict it in read address_channel
                intr_status_exp[a_i][a_j] = 1'b1;
                check_interrupt_pin();
                if (cfg.en_cov) begin
                  int timer_idx = a_i * NUM_TIMERS + a_j;
                  //Sample cfg coverage for each timer
                  cov.cfg_values_cov_obj[timer_idx].timer_cfg_cg.sample(
                      step[a_i], prescale[a_i], timer_val[a_i], compare_val[a_i][a_j]);
                  //Sample toggle coverage for each prescale bit
                  for (int i = 0; i < 12; i++) begin
                    cov.rv_timer_prescale_values_cov_obj[a_i][i].sample(prescale[a_i][i]);
                  end
                end
                @cfg.clk_rst_vif.cb;
                ignore_period[a_i][a_j] = 1'b0;
              end
              begin
                wait((en_timers[a_i][a_j] == 0) | (under_reset == 1));
              end
            join_any
            en_timers_prev[a_i][a_j] = 1'b0;
            // kill forked threads if timer disabled or interrupt occured or under reset
            disable fork;
          end
        join_none
      end
    end  // wait_for_interrupt
  endtask : compute_and_check_interrupt

  // function : check_interrupt_pin
  // check all interrupt output pins with expected intr state & pin enable
  function void check_interrupt_pin();
    for (int i = 0; i < NUM_HARTS; i++) begin
      for (int j = 0; j < NUM_TIMERS; j++) begin
        int intr_pin_idx = i * NUM_TIMERS + j;
        `DV_CHECK_CASE_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)),
                          (intr_status_exp[i][j] & en_interrupt[i][j]))
        //Sample interrupt and interrupt pin coverage for each timer
        if (cfg.en_cov) begin
          cov.intr_cg.sample(intr_pin_idx, en_interrupt[i][j], intr_status_exp[i][j]);
          cov.intr_pins_cg.sample(intr_pin_idx, cfg.intr_vif.sample_pin(.idx(intr_pin_idx)));
        end
      end
    end
  endfunction

  virtual function void reset(string kind = "HARD");
    super.reset(kind);
    // reset the local values
    step = '{default: 1};
    prescale = '{default: 0};
    timer_val = '{default: 0};
    compare_val = '{default: '1};
    en_timers = '{default: 0};
    en_interrupt = '{default: 0};
    intr_status_exp = '{default: 0};
    ignore_period = '{default: 0};
    en_timers_prev = '{default: 0};
    ctimecmp_update_on_fly = 0;
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
  endfunction

endclass
Diffs are:
 // Copyright lowRISC contributors.
 // Licensed under the Apache License, Version 2.0, see LICENSE for details.
 // SPDX-License-Identifier: Apache-2.0
 
 class rv_timer_scoreboard extends cip_base_scoreboard#(
     .CFG_T(rv_timer_env_cfg), .RAL_T(rv_timer_reg_block), .COV_T(rv_timer_env_cov)
 );
 
   `uvm_component_utils(rv_timer_scoreboard)
   `uvm_component_new
 
   // local variables
   local uint64 prescale[NUM_HARTS];
   local uint64 step[NUM_HARTS];
   local uint64 timer_val[NUM_HARTS];
   local uint64 compare_val[NUM_HARTS][NUM_TIMERS];
   local uint num_clks[NUM_HARTS][NUM_TIMERS];
   local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers;
   local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers_prev;
   local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_interrupt;
   local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] ignore_period;
   local bit [NUM_HARTS-1:0] num_clk_update_due;
   local bit ctimecmp_update_on_fly;
 
   // expected values
   local uint intr_status_exp[NUM_HARTS];
 
   function void build_phase(uvm_phase phase);
     super.build_phase(phase);
   endfunction
 
   task run_phase(uvm_phase phase);
     super.run_phase(phase);
     compute_and_check_interrupt();
   endtask
 
   virtual task process_tl_access(tl_seq_item item, tl_channels_e channel = DataChannel);
     uvm_reg csr;
     string csr_name;
     bit do_read_check = 1'b1;
     bit write = item.is_write();
     uvm_reg_addr_t csr_addr = get_normalized_addr(item.a_addr);
 
     // if access was to a valid csr, get the csr handle
     if (csr_addr inside {cfg.csr_addrs}) begin
       csr = ral.default_map.get_reg_by_offset(csr_addr);
       `DV_CHECK_NE_FATAL(csr, null)
       csr_name = csr.get_name();
     end else begin
       `uvm_fatal(`gfn, $sformatf("Access unexpected addr 0x%0h", csr_addr))
     end
 
     if (!write && channel == AddrChannel) begin
       if (!uvm_re_match("intr_state*", csr_name)) begin
         for (int i = 0; i < NUM_HARTS; i++) begin
           if (csr_name == $sformatf("intr_state%0d", i)) begin
             if ((intr_status_exp[i] != csr.get_mirrored_value()) & (ignore_period[i] == 'b0)) begin
               void'(csr.predict(.value(intr_status_exp[i]), .kind(UVM_PREDICT_READ)));
             end
             break;
           end else if (i == (NUM_HARTS - 1)) begin
             `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
           end
         end
       end
     end
 
     // grab write transactions from address channel; grab completed transactions from data channel
 
     // if incoming access is a write to a valid csr, then make updates right away
     if (write && channel == AddrChannel) begin
       void'(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));
 
       // process the csr req
       case (1)
         (!uvm_re_match("ctrl*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             for (int j = 0; j < NUM_TIMERS; j++) begin
               en_timers[i][j] = get_reg_fld_mirror_value(ral, "ctrl", $sformatf("active_%0d", j));
             end
             //Sample all timers active coverage for each hart
             if (cfg.en_cov) cov.ctrl_reg_cov_obj[i].timer_active_cg.sample(en_timers[i]);
           end
         end
         (!uvm_re_match("cfg*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             step[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "step");
             prescale[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "prescale");
           end
         end
         (!uvm_re_match("timer_v_lower*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             timer_val[i][31:0] =
                 get_reg_fld_mirror_value(ral, $sformatf("timer_v_lower%0d", i), "v");
             num_clk_update_due[i] = 1'b1;
           end
         end
         (!uvm_re_match("timer_v_upper*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             timer_val[i][63:32] =
                 get_reg_fld_mirror_value(ral, $sformatf("timer_v_upper%0d", i), "v");
             num_clk_update_due[i] = 1'b1;
           end
         end
         (!uvm_re_match("compare_lower*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             for (int j = 0; j < NUM_TIMERS; j++) begin
               int timer_idx = i * NUM_TIMERS + j;
               string compare_lower_str = $sformatf("compare_lower%0d_%0d", i, j);
               if (csr_name == compare_lower_str) begin
                 compare_val[i][j][31:0] = csr.get_mirrored_value();
                 if (en_timers[i][j] == 0) begin
                   // Reset the interrupt when mtimecmp is updated and timer is not active
                   intr_status_exp[i][j] = 0;
                   if (cfg.en_cov) begin
                     cov.sticky_intr_cov[{
                       "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                     }].sample(1'b0);
                   end
                 end else begin
                   // intr stays sticky if timer is active
                   ctimecmp_update_on_fly = 1;
                   if (cfg.en_cov) begin
                     cov.sticky_intr_cov[{
                       "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                     }].sample(intr_status_exp[i][j]);
                   end
                 end
                 break;
               end
             end
           end
         end
         (!uvm_re_match("compare_upper*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             for (int j = 0; j < NUM_TIMERS; j++) begin
               int timer_idx = i * NUM_TIMERS + j;
               string compare_upper_str = $sformatf("compare_upper%0d_%0d", i, j);
               if (csr_name == compare_upper_str) begin
                 compare_val[i][j][63:32] = csr.get_mirrored_value();
                 if (en_timers[i][j] == 0) begin
                   // Reset the interrupt when mtimecmp is updated and timer is not active
                   intr_status_exp[i][j] = 0;
                   if (cfg.en_cov) begin
                     cov.sticky_intr_cov[{
                       "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                     }].sample(1'b0);
                   end
                 end else begin
                   // intr stays sticky if timer is active
                   ctimecmp_update_on_fly = 1;
                   if (cfg.en_cov) begin
                     cov.sticky_intr_cov[{
                       "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                     }].sample(intr_status_exp[i][j]);
                   end
                 end
                 break;
               end
             end
           end
         end
         (!uvm_re_match("intr_enable*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             for (int j = 0; j < NUM_TIMERS; j++) begin
               en_interrupt[i][j] = get_reg_fld_mirror_value(ral, $sformatf("intr_enable%0d", i),
                                                             $sformatf("ie_%0d", j));
             end
           end
         end
         (!uvm_re_match("intr_state*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             string intr_state_str = $sformatf("intr_state%0d", i);
             if (csr_name == intr_state_str) begin
               // Intr_state reg is W1C, update expected status with RAL mirrored val
               for (int j = 0; j < NUM_TIMERS; j++) begin
                 int timer_idx = i * NUM_TIMERS + j;
                 if (item.a_data[j] == 1) begin
                   if (en_timers[i][j] == 0) begin
                     intr_status_exp[i][j] = 0;
                     if (cfg.en_cov) begin
                       cov.sticky_intr_cov[{
                         "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                       }].sample(1'b0);
                     end
                   end else if (cfg.en_cov) begin  // sticky interrupt
                     cov.sticky_intr_cov[{
                       "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                     }].sample(1'b1);
                   end
                 end
               end
               break;
             end
           end
         end
         (!uvm_re_match("intr_test*", csr_name)): begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             string intr_test_str = $sformatf("intr_test%0d", i);
             if (csr_name == intr_test_str) begin
               uint intr_test_val = item.a_data;
               for (int j = 0; j < NUM_TIMERS; j++) begin
                 int intr_pin_idx = i * NUM_TIMERS + j;
                 if (intr_test_val[j]) intr_status_exp[i][j] = intr_test_val[j];
                 //Sample intr_test coverage for each bit of test reg
                 if (cfg.en_cov)
                   cov.intr_test_cg.sample(intr_pin_idx, intr_test_val[j], en_interrupt[i][j],
                                           intr_status_exp[i][j]);
               end
               break;
             end
           end
         end
         default: begin
           `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
         end
       endcase
     end
 
     if (channel == DataChannel) begin
       // Check all interrupts in DataChannel of every Read/Write except when ctimecmp updated
       // during timer active. This scenario is checked in base sequence by reading the intr_state.
       // Ignored checking here because sticky intr_pin update has one cycle delay.
       // TODO #1464: temp constraint, if support external reg, this can be removed
       if (!ctimecmp_update_on_fly) check_interrupt_pin();
       ctimecmp_update_on_fly = 0;
 
       // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
       if (!write) begin
         // exclude read check for timer_val* reg if read happended when timer is enabled
         if (!uvm_re_match("timer_v_*", csr_name)) begin
           for (int i = 0; i < NUM_HARTS; i++) begin
             if (!uvm_re_match($sformatf("timer_v_*%0d", i), csr_name)) begin
               if (en_timers[i] == 0) begin
                 `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
               end else begin
                 if (!uvm_re_match("timer_v_lower*", csr_name)) begin
                   timer_val[i][31:0] = item.d_data;
                   // on timer_val read update num_clks
                   num_clk_update_due[i] = 1'b1;
                 end else begin
                   timer_val[i][63:32] = item.d_data;
                 end
               end
               break;
             end else if (i == (NUM_HARTS - 1)) begin
               `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
             end
           end
         end  // Read happened for other registers
-            else
-        if (do_read_check) begin
+            else if (do_read_check) begin
           `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
         end
 
         void'(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
       end
     end
   endtask
 
   // Task : compute_and_check_interrupt
   // wait for expected # of clocks and check for interrupt state reg and pin
   virtual task compute_and_check_interrupt();
     bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] reset_count;
 
     fork
       begin
         forever begin : compute_num_clks
           // calculate number of clocks required to have interrupt
           @(en_timers or num_clk_update_due);
           wait(under_reset == 0);
           foreach (en_timers[i, j]) begin
             uint64 mtime_diff = compare_val[i][j] - timer_val[i];
             num_clks[i][j] =
                 ((mtime_diff / step[i]) + ((mtime_diff % step[i]) != 0)) * (prescale[i] + 1) + 1;
           end
           // reset count if timer is enabled and num_clks got updated
           for (int i = 0; i < NUM_HARTS; i++) begin
             if (num_clk_update_due[i]) reset_count[i] = en_timers[i];
           end
           num_clk_update_due = '0;
         end  // compute_num_clks
       end
     join_none
 
     forever begin : wait_for_interrupt
       @(en_timers or under_reset);
       wait(under_reset == 0);
       // fork a thread for enabled timer on all enabled hart
       foreach (en_timers[i, j]) begin
         automatic int a_i = i;
         automatic int a_j = j;
         fork
           if (en_timers[a_i][a_j] & !en_timers_prev[a_i][a_j]) begin
             fork
               begin
                 uint64 count = 0;
                 en_timers_prev[a_i][a_j] = 1'b1;
                 forever begin
                   @cfg.clk_rst_vif.cb;
                   count = count + 1;
                   if (reset_count[a_i][a_j] == 1'b1) begin
                     count = 0;
                     reset_count[a_i][a_j] = 1'b0;
                   end
                   if (count >= num_clks[a_i][a_j]) break;
                 end
                 // enabling one clock cycle of ignore period
                 ignore_period[a_i][a_j] = 1'b1;
                 `uvm_info(`gfn, $sformatf("Timer expired check for interrupt"), UVM_LOW)
                 // Update exp val and predict it in read address_channel
                 intr_status_exp[a_i][a_j] = 1'b1;
                 check_interrupt_pin();
                 if (cfg.en_cov) begin
                   int timer_idx = a_i * NUM_TIMERS + a_j;
                   //Sample cfg coverage for each timer
                   cov.cfg_values_cov_obj[timer_idx].timer_cfg_cg.sample(
                       step[a_i], prescale[a_i], timer_val[a_i], compare_val[a_i][a_j]);
                   //Sample toggle coverage for each prescale bit
                   for (int i = 0; i < 12; i++) begin
                     cov.rv_timer_prescale_values_cov_obj[a_i][i].sample(prescale[a_i][i]);
                   end
                 end
                 @cfg.clk_rst_vif.cb;
                 ignore_period[a_i][a_j] = 1'b0;
               end
               begin
                 wait((en_timers[a_i][a_j] == 0) | (under_reset == 1));
               end
             join_any
             en_timers_prev[a_i][a_j] = 1'b0;
             // kill forked threads if timer disabled or interrupt occured or under reset
             disable fork;
           end
         join_none
       end
     end  // wait_for_interrupt
   endtask : compute_and_check_interrupt
 
   // function : check_interrupt_pin
   // check all interrupt output pins with expected intr state & pin enable
   function void check_interrupt_pin();
     for (int i = 0; i < NUM_HARTS; i++) begin
       for (int j = 0; j < NUM_TIMERS; j++) begin
         int intr_pin_idx = i * NUM_TIMERS + j;
         `DV_CHECK_CASE_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)),
                           (intr_status_exp[i][j] & en_interrupt[i][j]))
         //Sample interrupt and interrupt pin coverage for each timer
         if (cfg.en_cov) begin
           cov.intr_cg.sample(intr_pin_idx, en_interrupt[i][j], intr_status_exp[i][j]);
           cov.intr_pins_cg.sample(intr_pin_idx, cfg.intr_vif.sample_pin(.idx(intr_pin_idx)));
         end
       end
     end
   endfunction
 
   virtual function void reset(string kind = "HARD");
     super.reset(kind);
     // reset the local values
     step = '{default: 1};
     prescale = '{default: 0};
     timer_val = '{default: 0};
     compare_val = '{default: '1};
     en_timers = '{default: 0};
     en_interrupt = '{default: 0};
     intr_status_exp = '{default: 0};
     ignore_period = '{default: 0};
     en_timers_prev = '{default: 0};
     ctimecmp_update_on_fly = 0;
   endfunction
 
   function void check_phase(uvm_phase phase);
     super.check_phase(phase);
   endfunction
 
 endclass
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_scoreboard extends cip_base_scoreboard#(
    .CFG_T(rv_timer_env_cfg), .RAL_T(rv_timer_reg_block), .COV_T(rv_timer_env_cov)
);

  `uvm_component_utils(rv_timer_scoreboard)
  `uvm_component_new

  // local variables
  local uint64 prescale[NUM_HARTS];
  local uint64 step[NUM_HARTS];
  local uint64 timer_val[NUM_HARTS];
  local uint64 compare_val[NUM_HARTS][NUM_TIMERS];
  local uint num_clks[NUM_HARTS][NUM_TIMERS];
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_timers_prev;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] en_interrupt;
  local bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] ignore_period;
  local bit [NUM_HARTS-1:0] num_clk_update_due;
  local bit ctimecmp_update_on_fly;

  // expected values
  local uint intr_status_exp[NUM_HARTS];

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction

  task run_phase(uvm_phase phase);
    super.run_phase(phase);
    compute_and_check_interrupt();
  endtask

  virtual task process_tl_access(tl_seq_item item, tl_channels_e channel = DataChannel);
    uvm_reg csr;
    string csr_name;
    bit do_read_check = 1'b1;
    bit write = item.is_write();
    uvm_reg_addr_t csr_addr = get_normalized_addr(item.a_addr);

    // if access was to a valid csr, get the csr handle
    if (csr_addr inside {cfg.csr_addrs}) begin
      csr = ral.default_map.get_reg_by_offset(csr_addr);
      `DV_CHECK_NE_FATAL(csr, null)
      csr_name = csr.get_name();
    end else begin
      `uvm_fatal(`gfn, $sformatf("Access unexpected addr 0x%0h", csr_addr))
    end

    if (!write && channel == AddrChannel) begin
      if (!uvm_re_match("intr_state*", csr_name)) begin
        for (int i = 0; i < NUM_HARTS; i++) begin
          if (csr_name == $sformatf("intr_state%0d", i)) begin
            if ((intr_status_exp[i] != csr.get_mirrored_value()) & (ignore_period[i] == 'b0)) begin
              void'(csr.predict(.value(intr_status_exp[i]), .kind(UVM_PREDICT_READ)));
            end
            break;
          end else if (i == (NUM_HARTS - 1)) begin
            `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
          end
        end
      end
    end

    // grab write transactions from address channel; grab completed transactions from data channel

    // if incoming access is a write to a valid csr, then make updates right away
    if (write && channel == AddrChannel) begin
      void'(csr.predict(.value(item.a_data), .kind(UVM_PREDICT_WRITE), .be(item.a_mask)));

      // process the csr req
      case (1)
        (!uvm_re_match("ctrl*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_timers[i][j] = get_reg_fld_mirror_value(ral, "ctrl", $sformatf("active_%0d", j));
            end
            //Sample all timers active coverage for each hart
            if (cfg.en_cov) cov.ctrl_reg_cov_obj[i].timer_active_cg.sample(en_timers[i]);
          end
        end
        (!uvm_re_match("cfg*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            step[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "step");
            prescale[i] = get_reg_fld_mirror_value(ral, $sformatf("cfg%0d", i), "prescale");
          end
        end
        (!uvm_re_match("timer_v_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][31:0] =
                get_reg_fld_mirror_value(ral, $sformatf("timer_v_lower%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("timer_v_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            timer_val[i][63:32] =
                get_reg_fld_mirror_value(ral, $sformatf("timer_v_upper%0d", i), "v");
            num_clk_update_due[i] = 1'b1;
          end
        end
        (!uvm_re_match("compare_lower*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_lower_str = $sformatf("compare_lower%0d_%0d", i, j);
              if (csr_name == compare_lower_str) begin
                compare_val[i][j][31:0] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("compare_upper*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              int timer_idx = i * NUM_TIMERS + j;
              string compare_upper_str = $sformatf("compare_upper%0d_%0d", i, j);
              if (csr_name == compare_upper_str) begin
                compare_val[i][j][63:32] = csr.get_mirrored_value();
                if (en_timers[i][j] == 0) begin
                  // Reset the interrupt when mtimecmp is updated and timer is not active
                  intr_status_exp[i][j] = 0;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b0);
                  end
                end else begin
                  // intr stays sticky if timer is active
                  ctimecmp_update_on_fly = 1;
                  if (cfg.en_cov) begin
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(intr_status_exp[i][j]);
                  end
                end
                break;
              end
            end
          end
        end
        (!uvm_re_match("intr_enable*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            for (int j = 0; j < NUM_TIMERS; j++) begin
              en_interrupt[i][j] = get_reg_fld_mirror_value(ral, $sformatf("intr_enable%0d", i),
                                                            $sformatf("ie_%0d", j));
            end
          end
        end
        (!uvm_re_match("intr_state*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_state_str = $sformatf("intr_state%0d", i);
            if (csr_name == intr_state_str) begin
              // Intr_state reg is W1C, update expected status with RAL mirrored val
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int timer_idx = i * NUM_TIMERS + j;
                if (item.a_data[j] == 1) begin
                  if (en_timers[i][j] == 0) begin
                    intr_status_exp[i][j] = 0;
                    if (cfg.en_cov) begin
                      cov.sticky_intr_cov[{
                        "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                      }].sample(1'b0);
                    end
                  end else if (cfg.en_cov) begin  // sticky interrupt
                    cov.sticky_intr_cov[{
                      "rv_timer_sticky_intr_pin", $sformatf("%0d", timer_idx)
                    }].sample(1'b1);
                  end
                end
              end
              break;
            end
          end
        end
        (!uvm_re_match("intr_test*", csr_name)): begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            string intr_test_str = $sformatf("intr_test%0d", i);
            if (csr_name == intr_test_str) begin
              uint intr_test_val = item.a_data;
              for (int j = 0; j < NUM_TIMERS; j++) begin
                int intr_pin_idx = i * NUM_TIMERS + j;
                if (intr_test_val[j]) intr_status_exp[i][j] = intr_test_val[j];
                //Sample intr_test coverage for each bit of test reg
                if (cfg.en_cov)
                  cov.intr_test_cg.sample(intr_pin_idx, intr_test_val[j], en_interrupt[i][j],
                                          intr_status_exp[i][j]);
              end
              break;
            end
          end
        end
        default: begin
          `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
        end
      endcase
    end

    if (channel == DataChannel) begin
      // Check all interrupts in DataChannel of every Read/Write except when ctimecmp updated
      // during timer active. This scenario is checked in base sequence by reading the intr_state.
      // Ignored checking here because sticky intr_pin update has one cycle delay.
      // TODO #1464: temp constraint, if support external reg, this can be removed
      if (!ctimecmp_update_on_fly) check_interrupt_pin();
      ctimecmp_update_on_fly = 0;

      // On reads, if do_read_check, is set, then check mirrored_value against item.d_data
      if (!write) begin
        // exclude read check for timer_val* reg if read happended when timer is enabled
        if (!uvm_re_match("timer_v_*", csr_name)) begin
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (!uvm_re_match($sformatf("timer_v_*%0d", i), csr_name)) begin
              if (en_timers[i] == 0) begin
                `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
              end else begin
                if (!uvm_re_match("timer_v_lower*", csr_name)) begin
                  timer_val[i][31:0] = item.d_data;
                  // on timer_val read update num_clks
                  num_clk_update_due[i] = 1'b1;
                end else begin
                  timer_val[i][63:32] = item.d_data;
                end
              end
              break;
            end else if (i == (NUM_HARTS - 1)) begin
              `uvm_fatal(`gfn, $sformatf("invalid csr: %0s", csr.get_full_name()))
            end
          end
        end  // Read happened for other registers
            else
        if (do_read_check) begin
          `DV_CHECK_EQ(csr.get_mirrored_value(), item.d_data)
        end

        void'(csr.predict(.value(item.d_data), .kind(UVM_PREDICT_READ)));
      end
    end
  endtask

  // Task : compute_and_check_interrupt
  // wait for expected # of clocks and check for interrupt state reg and pin
  virtual task compute_and_check_interrupt();
    bit [NUM_HARTS-1:0][NUM_TIMERS-1:0] reset_count;

    fork
      begin
        forever begin : compute_num_clks
          // calculate number of clocks required to have interrupt
          @(en_timers or num_clk_update_due);
          wait(under_reset == 0);
          foreach (en_timers[i, j]) begin
            uint64 mtime_diff = compare_val[i][j] - timer_val[i];
            num_clks[i][j] =
                ((mtime_diff / step[i]) + ((mtime_diff % step[i]) != 0)) * (prescale[i] + 1) + 1;
          end
          // reset count if timer is enabled and num_clks got updated
          for (int i = 0; i < NUM_HARTS; i++) begin
            if (num_clk_update_due[i]) reset_count[i] = en_timers[i];
          end
          num_clk_update_due = '0;
        end  // compute_num_clks
      end
    join_none

    forever begin : wait_for_interrupt
      @(en_timers or under_reset);
      wait(under_reset == 0);
      // fork a thread for enabled timer on all enabled hart
      foreach (en_timers[i, j]) begin
        automatic int a_i = i;
        automatic int a_j = j;
        fork
          if (en_timers[a_i][a_j] & !en_timers_prev[a_i][a_j]) begin
            fork
              begin
                uint64 count = 0;
                en_timers_prev[a_i][a_j] = 1'b1;
                forever begin
                  @cfg.clk_rst_vif.cb;
                  count = count + 1;
                  if (reset_count[a_i][a_j] == 1'b1) begin
                    count = 0;
                    reset_count[a_i][a_j] = 1'b0;
                  end
                  if (count >= num_clks[a_i][a_j]) break;
                end
                // enabling one clock cycle of ignore period
                ignore_period[a_i][a_j] = 1'b1;
                `uvm_info(`gfn, $sformatf("Timer expired check for interrupt"), UVM_LOW)
                // Update exp val and predict it in read address_channel
                intr_status_exp[a_i][a_j] = 1'b1;
                check_interrupt_pin();
                if (cfg.en_cov) begin
                  int timer_idx = a_i * NUM_TIMERS + a_j;
                  //Sample cfg coverage for each timer
                  cov.cfg_values_cov_obj[timer_idx].timer_cfg_cg.sample(
                      step[a_i], prescale[a_i], timer_val[a_i], compare_val[a_i][a_j]);
                  //Sample toggle coverage for each prescale bit
                  for (int i = 0; i < 12; i++) begin
                    cov.rv_timer_prescale_values_cov_obj[a_i][i].sample(prescale[a_i][i]);
                  end
                end
                @cfg.clk_rst_vif.cb;
                ignore_period[a_i][a_j] = 1'b0;
              end
              begin
                wait((en_timers[a_i][a_j] == 0) | (under_reset == 1));
              end
            join_any
            en_timers_prev[a_i][a_j] = 1'b0;
            // kill forked threads if timer disabled or interrupt occured or under reset
            disable fork;
          end
        join_none
      end
    end  // wait_for_interrupt
  endtask : compute_and_check_interrupt

  // function : check_interrupt_pin
  // check all interrupt output pins with expected intr state & pin enable
  function void check_interrupt_pin();
    for (int i = 0; i < NUM_HARTS; i++) begin
      for (int j = 0; j < NUM_TIMERS; j++) begin
        int intr_pin_idx = i * NUM_TIMERS + j;
        `DV_CHECK_CASE_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)),
                          (intr_status_exp[i][j] & en_interrupt[i][j]))
        //Sample interrupt and interrupt pin coverage for each timer
        if (cfg.en_cov) begin
          cov.intr_cg.sample(intr_pin_idx, en_interrupt[i][j], intr_status_exp[i][j]);
          cov.intr_pins_cg.sample(intr_pin_idx, cfg.intr_vif.sample_pin(.idx(intr_pin_idx)));
        end
      end
    end
  endfunction

  virtual function void reset(string kind = "HARD");
    super.reset(kind);
    // reset the local values
    step = '{default: 1};
    prescale = '{default: 0};
    timer_val = '{default: 0};
    compare_val = '{default: '1};
    en_timers = '{default: 0};
    en_interrupt = '{default: 0};
    intr_status_exp = '{default: 0};
    ignore_period = '{default: 0};
    en_timers_prev = '{default: 0};
    ctimecmp_update_on_fly = 0;
  endfunction

  function void check_phase(uvm_phase phase);
    super.check_phase(phase);
  endfunction

endclass
<<EOF>>
hw/ip/rv_timer/dv/tests/rv_timer_base_test.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_base_vseq.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: "bit" at 163:5-7; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class rv_timer_base_vseq extends cip_base_vseq#(
    .CFG_T(rv_timer_env_cfg),
    .RAL_T(rv_timer_reg_block),
    .COV_T(rv_timer_env_cov),
    .VIRTUAL_SEQUENCER_T(rv_timer_virtual_sequencer)
);
  `uvm_object_utils(rv_timer_base_vseq)

  // random delay between consecutive transactions
  rand uint delay;

  constraint delay_c {
    delay dist {
      0 :/ 1,
      [1 : 100] :/ 1,
      [101 : 10_000] :/ 8,
      [10_001 : 1_000_000] :/ 1
    };
  }

  // hart specific parameters
  bit [TL_DW-1:0] max_prescale;
  bit [TL_DW-1:0] max_step;

  `uvm_object_new

  function void pre_randomize();
    super.pre_randomize();
    max_prescale = (1 << p_sequencer.cfg.ral.cfg0.prescale.get_n_bits()) - 1;
    max_step = (1 << p_sequencer.cfg.ral.cfg0.step.get_n_bits()) - 1;
  endfunction

  task pre_start();
    super.pre_start();
  endtask

  // cfg rv_timer - set a particular timer active or inactive
  virtual task cfg_timer(int hart = 0, int timer = 0, bit enable = 1'b1);
    uvm_reg ctrl_rg;
    uvm_reg_field active_fld;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    ctrl_rg = ral.get_reg_by_name($sformatf("ctrl"));
    `DV_CHECK_NE_FATAL(ctrl_rg, null)
    active_fld = ctrl_rg.get_field_by_name($sformatf("active_%0d", timer));
    `DV_CHECK_NE_FATAL(active_fld, null)
    active_fld.set(enable);
    csr_update(.csr(ctrl_rg));
  endtask

  // cfg rv_timer prescaler and count step
  virtual task cfg_hart(int hart = 0, int prescale = 1, int step = 1);
    uvm_reg hart_cfg_rg;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LE_FATAL(prescale, max_prescale)
    `DV_CHECK_LE_FATAL(step, max_step)
    hart_cfg_rg = ral.get_reg_by_name($sformatf("cfg%0d", hart));
    `DV_CHECK_NE_FATAL(hart_cfg_rg, null)
    hart_cfg_rg.get_field_by_name("prescale").set(prescale);
    hart_cfg_rg.get_field_by_name("step").set(step);
    csr_update(.csr(hart_cfg_rg));
  endtask

  // set timer value for a particular HART
  virtual task set_timer_val(int hart = 0, bit [63:0] val);
    uvm_reg timer_val_l_rg;
    uvm_reg timer_val_u_rg;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    timer_val_l_rg = ral.get_reg_by_name($sformatf("timer_v_lower%0d", hart));
    timer_val_u_rg = ral.get_reg_by_name($sformatf("timer_v_upper%0d", hart));
    `DV_CHECK_NE_FATAL(timer_val_l_rg, null)
    `DV_CHECK_NE_FATAL(timer_val_u_rg, null)
    timer_val_l_rg.set(val[31:0]);
    timer_val_u_rg.set(val[63:32]);
    csr_update(.csr(timer_val_l_rg));
    csr_update(.csr(timer_val_u_rg));
  endtask

  // set timer value for a particular timer
  virtual task set_compare_val(int hart = 0, int timer = 0, bit [63:0] val);
    uvm_reg compare_val_l_rg;
    uvm_reg compare_val_u_rg;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    compare_val_l_rg = ral.get_reg_by_name($sformatf("compare_lower%0d_%0d", hart, timer));
    compare_val_u_rg = ral.get_reg_by_name($sformatf("compare_upper%0d_%0d", hart, timer));
    `DV_CHECK_NE_FATAL(compare_val_l_rg, null)
    `DV_CHECK_NE_FATAL(compare_val_u_rg, null)
    compare_val_l_rg.set(val[31:0]);
    compare_val_u_rg.set(val[63:32]);
    csr_update(.csr(compare_val_l_rg));
    csr_update(.csr(compare_val_u_rg));
  endtask

  // configure interrupt
  virtual task cfg_interrupt(int hart = 0, int timer = 0, bit enable = 1'b1);
    uvm_reg intr_en_rg;
    uvm_reg_field timer_intr_en_fld;
    int intr_pin_idx = hart * NUM_TIMERS + timer;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    intr_en_rg = ral.get_reg_by_name($sformatf("intr_enable%0d", hart));
    `DV_CHECK_NE_FATAL(intr_en_rg, null)
    timer_intr_en_fld = intr_en_rg.get_field_by_name($sformatf("ie_%0d", timer));
    `DV_CHECK_NE_FATAL(timer_intr_en_fld, null)
    timer_intr_en_fld.set(enable);
    csr_update(.csr(intr_en_rg));
    // also check intr output, if disabled
    if (!enable) begin
      `DV_CHECK_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)), 1'b0)
    end
  endtask

  // check if interrupt fired
  virtual task check_interrupt(int hart = 0, int timer = 0, bit exp_intr_state, bit exp_intr_pin);
    uvm_reg intr_state_rg;
    uvm_reg_field timer_intr_state_fld;
    int intr_pin_idx = hart * NUM_TIMERS + timer;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    intr_state_rg = ral.get_reg_by_name($sformatf("intr_state%0d", hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)
    timer_intr_state_fld = intr_state_rg.get_field_by_name($sformatf("is_%0d", timer));
    `DV_CHECK_NE_FATAL(timer_intr_state_fld, null)
    void'(timer_intr_state_fld.predict(.value(exp_intr_state), .kind(UVM_PREDICT_DIRECT)));
    csr_rd_check(.ptr(intr_state_rg), .compare_vs_ral(1));
    // also check intr output
    `DV_CHECK_EQ(cfg.intr_vif.sample_pin(.idx(intr_pin_idx)), exp_intr_pin)
  endtask

  // task to write 1 to clear and read the interrupt status register
  virtual task clear_intr_state(int hart = 0, int timer = 0);
    uvm_reg intr_state_rg;
    uvm_reg_field is_fld;
    bit [TL_DW-1:0] status;
    bit [TL_DW-1:0] wr_value;
    `DV_CHECK_LT_FATAL(hart, NUM_HARTS)
    `DV_CHECK_LT_FATAL(timer, NUM_TIMERS)
    // randomly clear the intr by writing intr_state or mtimecmp
    intr_state_rg = ral.get_reg_by_name($sformatf("intr_state%0d", hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)

    if ($urandom_range(0, 1)) begin
      wr_value = 1 << timer;
      csr_wr(.csr(intr_state_rg), .value(wr_value));
    end else begin
      wr_value = $urandom();
      set_compare_val(hart, timer, wr_value);
      // wait one clk cycle then check intr, to ensure get the sticky interrupt value
      cfg.clk_rst_vif.wait_clks(1);
    end
    csr_rd(.ptr(intr_state_rg), .value(status));
  endtask

  // poll a intr_status continuously until it reads the expected value.
  virtual task intr_state_spinwait(input int hart = 0, input uint exp_data = 0,
                                   input uint spinwait_delay_ns = 0,
                                   input uint timeout_ns = 10_000_000
    bit [TL_DW-1:0] read_data;
    bit reset_asserted;
    uvm_reg intr_state_rg;
    intr_state_rg = ral.get_reg_by_name($sformatf("intr_state%0d", hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)
    fork
      begin : isolation_fork
        fork
          begin
            wait(cfg.clk_rst_vif.rst_n == 0);
            reset_asserted = 1'b1;
          end
        join_none
        fork
          while (1) begin
            csr_rd(.ptr(intr_state_rg), .value(read_data));
            if (spinwait_delay_ns) #(spinwait_delay_ns * 1ns);
            if ((read_data == exp_data) | (reset_asserted == 1)) break;
          end
          begin
            wait_timeout(timeout_ns, "intr_state_spinwait", $sformatf(
                         "timeout %0s (addr=0x%0h) == 0x%0h", intr_state_rg.get_full_name(),
                             intr_state_rg.get_address(), exp_data));
          end
        join_any
        disable fork;
      end : isolation_fork
    join
  endtask

  // task to read interrup status reg for given Hart
  virtual task read_intr_status_reg(input int hart = 0, output uint status_val);
    uvm_reg intr_state_rg;
    intr_state_rg = ral.get_reg_by_name($sformatf("intr_state%0d", hart));
    `DV_CHECK_NE_FATAL(intr_state_rg, null)
    csr_rd(.ptr(intr_state_rg), .value(status_val));
  endtask : read_intr_status_reg

  // task to read timer value reg for given Hart
  virtual task read_timer_val_reg(input int hart = 0, output uint64 mtime_val);
    bit [TL_DW-1:0] read_data;
    uvm_reg timer_val_l_rg;
    uvm_reg timer_val_u_rg;
    timer_val_l_rg = ral.get_reg_by_name($sformatf("timer_v_lower%0d", hart));
    timer_val_u_rg = ral.get_reg_by_name($sformatf("timer_v_upper%0d", hart));
    `DV_CHECK_NE_FATAL(timer_val_l_rg, null)
    `DV_CHECK_NE_FATAL(timer_val_u_rg, null)
    csr_rd(.ptr(timer_val_u_rg), .value(read_data));
    mtime_val[63:32] = read_data;
    csr_rd(.ptr(timer_val_l_rg), .value(read_data));
    mtime_val[31:0] = read_data;
  endtask : read_timer_val_reg

  // Status register read random for passed clks
  virtual task status_read_for_clks(int hart = 0, int clks);
    bit stop_reading;
    fork
      begin
        cfg.clk_rst_vif.wait_clks(clks);
        stop_reading = 1'b1;
      end
      begin
        forever begin
          // read will trigger check in scoreboard
          uint rd_data;
          read_intr_status_reg(.hart(hart), .status_val(rd_data));
          fork
            begin : isolation_fork
              fork
                begin
                  delay = $urandom_range(1, 10000);
                  #(delay * 1ns);
                end
                wait(stop_reading == 1);
              join_any
              disable fork;
            end : isolation_fork
          join
          if (stop_reading == 1) break;
        end
      end
    join
  endtask : status_read_for_clks

endclass : rv_timer_base_vseq
<<EOF>>
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_stress_all_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/dv/tests/rv_timer_test_pkg.sv: Already formatted, no change.
hw/ip/rv_timer/dv/sva/rv_timer_bind.sv: Already formatted, no change.
hw/ip/rv_timer/dv/env/seq_lib/rv_timer_cfg_update_on_fly_vseq.sv: Already formatted, no change.
hw/ip/rv_timer/dv/tb/tb.sv: Already formatted, no change.
hw/ip/spi_device/rtl/spi_fwm_txf_ctrl.sv: Already formatted, no change.
hw/ip/spi_device/rtl/spi_device_pkg.sv: Already formatted, no change.
hw/ip/hmac/rtl/hmac_pkg.sv: *** Some token partitions failed to complete within the search limit:
>>[localparam sha_word_t CubicRootPrime [ 64 ] = '{ 32 'h 428a_2f98 , 32 'h 7137_4491 , 32 'h b5c0_fbcf , 32 'h e9b5_dba5 , 32 'h 3956_c25b , 32 'h 59f1_11f1 , 32 'h 923f_82a4 , 32 'h ab1c_5ed5 , 32 'h d807_aa98 , 32 'h 1283_5b01 , 32 'h 2431_85be , 32 'h 550c_7dc3 , 32 'h 72be_5d74 , 32 'h 80de_b1fe , 32 'h 9bdc_06a7 , 32 'h c19b_f174 , 32 'h e49b_69c1 , 32 'h efbe_4786 , 32 'h 0fc1_9dc6 , 32 'h 240c_a1cc , 32 'h 2de9_2c6f , 32 'h 4a74_84aa , 32 'h 5cb0_a9dc , 32 'h 76f9_88da , 32 'h 983e_5152 , 32 'h a831_c66d , 32 'h b003_27c8 , 32 'h bf59_7fc7 , 32 'h c6e0_0bf3 , 32 'h d5a7_9147 , 32 'h 06ca_6351 , 32 'h 1429_2967 , 32 'h 27b7_0a85 , 32 'h 2e1b_2138 , 32 'h 4d2c_6dfc , 32 'h 5338_0d13 , 32 'h 650a_7354 , 32 'h 766a_0abb , 32 'h 81c2_c92e , 32 'h 9272_2c85 , 32 'h a2bf_e8a1 , 32 'h a81a_664b , 32 'h c24b_8b70 , 32 'h c76c_51a3 , 32 'h d192_e819 , 32 'h d699_0624 , 32 'h f40e_3585 , 32 'h 106a_a070 , 32 'h 19a4_c116 , 32 'h 1e37_6c08 , 32 'h 2748_774c , 32 'h 34b0_bcb5 , 32 'h 391c_0cb3 , 32 'h 4ed8_aa4a , 32 'h 5b9c_ca4f , 32 'h 682e_6ff3 , 32 'h 748f_82ee , 32 'h 78a5_636f , 32 'h 84c8_7814 , 32 'h 8cc7_0208 , 32 'h 90be_fffa , 32 'h a450_6ceb , 32 'h bef9_a3f7 , 32 'h c671_78f2 } ;], policy: fit-else-expand, (origin: "localparam ...c671_78f2};")
*** end of partially formatted partition list
[other error status]
hw/ip/spi_device/rtl/spi_device_reg_pkg.sv: Already formatted, no change.
hw/ip/spi_device/rtl/spi_fwmode.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/spi_device_env.sv: Already formatted, no change.
hw/ip/spi_device/rtl/spi_device.sv: Already formatted, no change.
hw/ip/aes/dv/env/seq_lib/aes_base_vseq.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_control.sv: *** Some token partitions failed to complete within the search limit:
>>[assign start = cfg_valid & ( manual_operation_i ? start_trigger : ( mode_i == AES_ECB ) ? ( key_init_ready & data_in_new ) : ( mode_i == AES_CBC ) ? ( key_init_ready & data_in_new & iv_ready ) : ( mode_i == AES_CFB ) ? ( key_init_ready & data_in_new & iv_ready ) : ( mode_i == AES_OFB ) ? ( key_init_ready & data_in_new & iv_ready ) : ( mode_i == AES_CTR ) ? ( key_init_ready & data_in_new & iv_ready & ctr_ready_i ) : 1 'b 0 ) ;], policy: fit-else-expand, (origin: "assign
    ...i) : 1'b0);")
*** end of partially formatted partition list
[other error status]
hw/ip/spi_device/dv/env/spi_device_env_cov.sv: Already formatted, no change.
hw/ip/spi_device/rtl/spi_fwm_rxf_ctrl.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_extreme_fifo_size_vseq.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/spi_device_env_cfg.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_dummy_item_extra_dly_vseq.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_common_vseq.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_vseq_list.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/spi_device_scoreboard.svhw/ip/spi_device/dv/env/seq_lib/spi_device_fifo_full_vseq.sv: Already formatted, no change.: Already formatted, no change.

hw/ip/spi_device/dv/env/seq_lib/spi_device_fifo_underflow_overflow_vseq.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/spi_device_virtual_sequencer.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_sanity_vseq.sv: Already formatted, no change.
hw/ip/spi_device/rtl/spi_device_reg_top.sv: Already formatted, no change.
hw/ip/spi_device/dv/tests/spi_device_test_pkg.sv: Already formatted, no change.
hw/ip/spi_device/dv/tests/spi_device_base_test.sv: Already formatted, no change.
hw/ip/spi_device/dv/sva/spi_device_bind.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/spi_device_env_pkg.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_intr_vseq.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_txrx_vseq.sv: Already formatted, no change.
hw/ip/spi_device/dv/tb/tb.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src_pkg.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src_shtests.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src_align_sm.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/entropy_src_env.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src_reg_pkg.sv: Already formatted, no change.
hw/ip/spi_device/dv/env/seq_lib/spi_device_base_vseq.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/entropy_src_env_pkg.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/entropy_src_env_cfg.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src_core.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/seq_lib/entropy_src_vseq_list.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/entropy_src_env_cov.sv: Already formatted, no change.
hw/ip/entropy_src/pre_dv/entropy_src_tb.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/seq_lib/entropy_src_base_vseq.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/seq_lib/entropy_src_common_vseq.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/seq_lib/entropy_src_sanity_vseq.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/entropy_src_scoreboard.sv: Already formatted, no change.
hw/ip/entropy_src/dv/env/entropy_src_virtual_sequencer.sv: Already formatted, no change.
hw/ip/entropy_src/dv/tests/entropy_src_test_pkg.sv: Already formatted, no change.
hw/ip/entropy_src/dv/tests/entropy_src_base_test.sv: Already formatted, no change.
hw/ip/entropy_src/dv/sva/entropy_src_bind.sv: Already formatted, no change.
hw/ip/entropy_src/dv/tb/tb.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_pkg.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_fifo_async.sv: Already formatted, no change.
hw/ip/entropy_src/rtl/entropy_src_reg_top.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_fifo_sync.sv: Already formatted, no change.
hw/ip/tlul/rtl/sram2tlul.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_socket_1n.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_assert_multiple.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_err_resp.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_adapter_reg.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_err.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/xbar_env.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/xbar_env_cov.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/xbar_env_cfg.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/xbar_virtual_sequencer.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/xbar_env_pkg.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_adapter_host.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_random_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_sanity_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_access_same_device_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/xbar_scoreboard.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_vseq_list.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_seq_err_item.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_stress_all_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_unmapped_addr_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_tl_host_seq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_base_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_same_source_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/tests/xbar_test_pkg.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/env/seq_lib/xbar_stress_all_with_rand_reset_vseq.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/tests/xbar_error_test.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/tb/tb.sv: Already formatted, no change.
hw/ip/tlul/generic_dv/tb/xbar_macros.svh: Already formatted, no change.
hw/ip/tlul/generic_dv/tests/xbar_base_test.sv: Already formatted, no change.
hw/ip/rv_dm/dv/jtag_if.sv: Already formatted, no change.
hw/ip/rv_dm/dv/agent/rjtag_sequencer.sv: Already formatted, no change.
hw/ip/rv_dm/dv/agent/rjtag_agent.sv: Already formatted, no change.
hw/ip/rv_dm/dv/agent/rjtag_monitor.sv: Already formatted, no change.
hw/ip/rv_dm/rtl/rv_dm.sv: Already formatted, no change.
hw/ip/rv_dm/dv/test/riscv_jtag_sba_test.sv: Already formatted, no change.
hw/ip/rv_dm/dv/agent/rjtag_driver.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_virtual_sequencer.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_if.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_reg_block.sv: Already formatted, no change.
hw/ip/rv_dm/dv/scoreboard/rjtag_scoreboard.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_scoreboard.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_env_pkg.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_params_pkg.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_env_cfg.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/seq_lib/rv_dm_sanity_vseq.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/seq_lib/rv_dm_csr_vseq.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_env.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/seq_lib/rv_dm_vseq_list.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/dm_env.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/seq_lib/rv_dm_base_vseq.sv: Already formatted, no change.
hw/ip/rv_dm/dv/env/rv_dm_env_cov.sv: Already formatted, no change.
hw/ip/rv_dm/dv/rjtag_pkg.sv: Already formatted, no change.
hw/ip/rv_dm/dv/tests/rv_dm_test_pkg.sv: Already formatted, no change.
hw/ip/rv_dm/dv/tests/rv_dm_base_test.sv: Already formatted, no change.
hw/ip/rv_dm/dv/sva/rv_dm_bind.sv: Already formatted, no change.
hw/ip/rv_dm/dv/tb/tb.sv: Already formatted, no change.
hw/ip/rv_dm/dv/tb.sv: Already formatted, no change.
hw/ip/rv_dm/dv/seq/rjtag_seq_item.sv: Already formatted, no change.
hw/ip/rv_dm/dv/seq/rjtag_dmi_sequence.sv: Already formatted, no change.
hw/ip/prim_xilinx/rtl/prim_xilinx_clock_mux2.sv: Already formatted, no change.
hw/ip/prim_xilinx/rtl/prim_xilinx_pad_wrapper.sv: Already formatted, no change.
hw/ip/prim_xilinx/rtl/prim_xilinx_clock_gating.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_erase_ctrl.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_mp.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_ctrl_reg_pkg.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_rd_ctrl.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_prog_ctrl.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy_prog.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy_pkg.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_ctrl.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_socket_m1.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy_rd_buffers.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy_scramble.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_seq_cfg.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_env_pkg.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy_core.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_scoreboard.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_virtual_sequencer.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_env_cov.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_env_cfg.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_phy_rd.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_ctrl_env.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_sanity_vseq.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_common_vseq.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_vseq_list.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_rand_ops_vseq.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/tests/flash_ctrl_base_test.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_ctrl_pkg.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/flash_mem_addr_attrs.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/tests/flash_ctrl_test_pkg.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/tb/tb.sv: Error lex/parsing-ing formatted output.  Please file a bug.
First error: token: "." at 83:9; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
module tb;
  // dep packages
  import uvm_pkg::*;
  import top_pkg::*;
  import dv_utils_pkg::*;
  import flash_ctrl_pkg::*;
  import flash_ctrl_env_pkg::*;
  import flash_ctrl_test_pkg::*;

  // macro includes
  `include "uvm_macros.svh"
  `include "dv_macros.svh"

  wire clk, rst_n;
  wire devmode;
  wire intr_prog_empty;
  wire intr_prog_lvl;
  wire intr_rd_full;
  wire intr_rd_lvl;
  wire intr_op_done;
  wire intr_op_error;
  wire [NUM_MAX_INTERRUPTS-1:0] interrupts;

  // interfaces
  clk_rst_if clk_rst_if (
      .clk  (clk),
      .rst_n(rst_n)
  );
  pins_if #(NUM_MAX_INTERRUPTS) intr_if (interrupts);
  pins_if #(1) devmode_if (devmode);
  tl_if tl_if (
      .clk  (clk),
      .rst_n(rst_n)
  );
  tl_if eflash_tl_if (
      .clk  (clk),
      .rst_n(rst_n)
  );

  // dut
  flash_ctrl_wrapper dut (
      .clk_i (clk),
      .rst_ni(rst_n),

      .flash_ctrl_tl_i(tl_if.h2d),
      .flash_ctrl_tl_o(tl_if.d2h),

      .eflash_tl_i(eflash_tl_if.h2d),
      .eflash_tl_o(eflash_tl_if.d2h),

      // TODO: create and hook this up to an interface.
      .otp_i(flash_ctrl_pkg::OTP_FLASH_DEFAULT),

      .intr_prog_empty_o(intr_prog_empty),
      .intr_prog_lvl_o  (intr_prog_lvl),
      .intr_rd_full_o   (intr_rd_full),
      .intr_rd_lvl_o    (intr_rd_lvl),
      .intr_op_done_o   (intr_op_done),
      .intr_op_error_o  (intr_op_error)
  );

  // bind mem_bkdr_if
  `define FLASH_DATA_MEM_HIER(i) \
      dut.u_flash_eflash.gen_flash_banks[``i``].i_core.i_flash.gen_generic.u_impl_generic.u_mem

  `define FLASH_INFO_MEM_HIER(i) \
      dut.u_flash_eflash.gen_flash_banks[``i``].i_core.i_flash.gen_generic.u_impl_generic.u_info_mem

  generate
    for (genvar i = 0; i < flash_ctrl_pkg::NumBanks; i++) begin : mem_bkdr_if_i
      bind `FLASH_DATA_MEM_HIER(i) mem_bkdr_if mem_bkdr_if ();
      bind `FLASH_INFO_MEM_HIER(i) mem_bkdr_if mem_bkdr_if ();
      initial begin
        flash_part_e part;
        part = flash_ctrl_pkg::FlashPartData;
        uvm_config_db#(mem_bkdr_vif)::set(null, "*.env",
                                          $sformatf("mem_bkdr_vifs[%0s][%0d]", part.name(), i),
        `FLASH_DATA_MEM_HIER(i)
        .mem_bkdr_if);

        part = flash_ctrl_pkg::FlashPartInfo;
        uvm_config_db#(mem_bkdr_vif)::set(null, "*.env",
                                          $sformatf("mem_bkdr_vifs[%0s][%0d]", part.name(), i),
        `FLASH_INFO_MEM_HIER(i)
        .mem_bkdr_if);
      end
    end
  endgenerate

  `undef FLASH_DATA_MEM_HIER
  `undef FLASH_INFO_MEM_HIER

  // Connect the interrupts
  assign interrupts[FlashCtrlIntrProgEmpty] = intr_prog_empty;
  assign interrupts[FlashCtrlIntrProgLvl] = intr_prog_lvl;
  assign interrupts[FlashCtrlIntrRdFull] = intr_rd_full;
  assign interrupts[FlashCtrlIntrRdLvl] = intr_rd_lvl;
  assign interrupts[FlashCtrlIntrOpDone] = intr_op_done;
  assign interrupts[FlashCtrlIntrOpError] = intr_op_error;

  initial begin
    // drive clk and rst_n from clk_if
    clk_rst_if.set_active();
    uvm_config_db#(virtual clk_rst_if)::set(null, "*.env", "clk_rst_vif", clk_rst_if);
    uvm_config_db#(intr_vif)::set(null, "*.env", "intr_vif", intr_if);
    uvm_config_db#(devmode_vif)::set(null, "*.env", "devmode_vif", devmode_if);
    uvm_config_db#(virtual tl_if)::set(null, "*.env.m_tl_agent*", "vif", tl_if);
    uvm_config_db#(virtual tl_if)::set(null, "*.env.m_eflash_tl_agent*", "vif", eflash_tl_if);
    $timeformat(-12, 0, " ps", 12);
    run_test();
  end

endmodule
<<EOF>>
hw/ip/flash_ctrl/dv/sva/flash_ctrl_bind.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/tb/flash_ctrl_wrapper.sv: Already formatted, no change.
hw/ip/padctrl/rtl/padring.sv: Already formatted, no change.
hw/ip/padctrl/rtl/padctrl_reg_pkg.sv: Already formatted, no change.
hw/ip/padctrl/rtl/padctrl.sv: Already formatted, no change.
hw/ip/padctrl/rtl/jtag_mux.sv: Already formatted, no change.
hw/ip/padctrl/rtl/padctrl_reg_top.sv: Already formatted, no change.
hw/ip/padctrl/fpv/vip/padring_assert_fpv.sv: Already formatted, no change.
hw/ip/padctrl/fpv/vip/padctrl_assert_fpv.sv: Already formatted, no change.
hw/ip/padctrl/fpv/tb/padctrl_fpv.sv: Already formatted, no change.
hw/ip/padctrl/fpv/tb/padctrl_bind_fpv.sv: Already formatted, no change.
hw/ip/flash_ctrl/rtl/flash_ctrl_reg_top.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usbuart_reg_pkg.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usbuart.sv: Already formatted, no change.
hw/ip/aes/rtl/aes_cipher_control.sv: *** Some token partitions failed to complete within the search limit:
>>>>>>>>[key_words_sel_o = dec_key_gen_q ? KEY_WORDS_ZERO : ( key_len_i == AES_128 ) ? KEY_WORDS_0123 : ( key_len_i == AES_192 && op_i == CIPH_FWD ) ? KEY_WORDS_0123 : ( key_len_i == AES_192 && op_i == CIPH_INV ) ? KEY_WORDS_2345 : ( key_len_i == AES_256 && op_i == CIPH_FWD ) ? KEY_WORDS_0123 : ( key_len_i == AES_256 && op_i == CIPH_INV ) ? KEY_WORDS_4567 : KEY_WORDS_ZERO ;], policy: fit-else-expand, (origin: "key_words_s...WORDS_ZERO;")
>>>>>>>>[key_words_sel_o = dec_key_gen_q ? KEY_WORDS_ZERO : ( key_len_i == AES_128 ) ? KEY_WORDS_0123 : ( key_len_i == AES_192 && op_i == CIPH_FWD ) ? KEY_WORDS_2345 : ( key_len_i == AES_192 && op_i == CIPH_INV ) ? KEY_WORDS_0123 : ( key_len_i == AES_256 && op_i == CIPH_FWD ) ? KEY_WORDS_4567 : ( key_len_i == AES_256 && op_i == CIPH_INV ) ? KEY_WORDS_0123 : KEY_WORDS_ZERO ;], policy: fit-else-expand, (origin: "key_words_s...WORDS_ZERO;")
>>>>>>>>[key_words_sel_o = dec_key_gen_q ? KEY_WORDS_ZERO : ( key_len_i == AES_128 ) ? KEY_WORDS_0123 : ( key_len_i == AES_192 && op_i == CIPH_FWD ) ? KEY_WORDS_2345 : ( key_len_i == AES_192 && op_i == CIPH_INV ) ? KEY_WORDS_0123 : ( key_len_i == AES_256 && op_i == CIPH_FWD ) ? KEY_WORDS_4567 : ( key_len_i == AES_256 && op_i == CIPH_INV ) ? KEY_WORDS_0123 : KEY_WORDS_ZERO ;], policy: fit-else-expand, (origin: "key_words_s...WORDS_ZERO;")
*** end of partially formatted partition list
[other error status]
hw/ip/usbuart/rtl/rising_edge_detector.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usbuart_usbif.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usbuart_core.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usb_serial_fifo_ep.sv: Already formatted, no change.
hw/ip/usbuart/dv/sva/usbuart_bind.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usb_serial_ctrl_ep.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_reg_wrap.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_reg_pkg.sv: Already formatted, no change.
hw/ip/usbuart/rtl/usbuart_reg_top.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_pkg.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_ping_timer.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_esc_timer.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_accu.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_class.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler.sv: Already formatted, no change.
hw/ip/alert_handler/fpv/tb/alert_handler_esc_timer_fpv.sv: Already formatted, no change.
hw/ip/alert_handler/fpv/tb/alert_handler_ping_timer_fpv.sv: Already formatted, no change.
hw/ip/alert_handler/fpv/tb/alert_handler_ping_timer_bind_fpv.sv: Already formatted, no change.
hw/ip/alert_handler/fpv/vip/alert_handler_ping_timer_assert_fpv.sv: Already formatted, no change.
hw/ip/alert_handler/fpv/tb/alert_handler_esc_timer_bind_fpv.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/alert_handler_virtual_sequencer.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/alert_handler_env_pkg.svhw/ip/alert_handler/dv/env/alert_handler_env_cov.sv: Already formatted, no change.
: Already formatted, no change.
hw/ip/alert_handler/dv/env/alert_handler_env_cfg.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/alert_handler_env.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_esc_intr_timeout_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_common_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_random_classes_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/fpv/vip/alert_handler_esc_timer_assert_fpv.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_entropy_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_esc_alert_accum_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_ping_rsp_fail_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_sig_int_fail_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_stress_all_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_random_alerts_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_base_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_vseq_list.sv: hw/ip/alert_handler/dv/tests/alert_handler_base_test.svAlready formatted, no change.: Already formatted, no change.

hw/ip/alert_handler/dv/tests/alert_handler_test_pkg.sv: Already formatted, no change.
hw/ip/alert_handler/dv/sva/alert_handler_bind.sv: Already formatted, no change.
hw/ip/alert_handler/dv/tb/alert_handler_env_pkg__params.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/seq_lib/alert_handler_sanity_vseq.sv: Already formatted, no change.
hw/ip/alert_handler/dv/env/alert_handler_scoreboard.sv: Already formatted, no change.
hw/ip/alert_handler/dv/tb/tb.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_alert_pkg.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_esc_pkg.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_dom_and_2share.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_fifo_sync.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_util_memload.svh: Already formatted, no change.
hw/ip/prim/rtl/prim_subreg_arb.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_assert_yosys_macros.svh: Already formatted, no change.
hw/ip/prim/rtl/prim_fifo_async.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_ram_2p_async_adv.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_gate_gen.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_secded_28_22_enc.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_subst_perm.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_subreg_ext.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_prince.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_arbiter_fixed.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_pulse_sync.sv: Already formatted, no change.
hw/ip/alert_handler/rtl/alert_handler_reg_top.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_adapter_sram.sv: *** Some token partitions failed to complete within the search limit:
>>[assign tl_o = '{ d_valid : d_valid , d_opcode : ( d_valid && reqfifo_rdata . op != OpRead ) ? AccessAck : AccessAckData , d_param : '0 , d_size : ( d_valid ) ? reqfifo_rdata . size : '0 , d_source : ( d_valid ) ? reqfifo_rdata . source : '0 , d_sink : 1 'b 0 , d_data : ( d_valid && rspfifo_rvalid && reqfifo_rdata . op == OpRead ) ? rspfifo_rdata . data : '0 , d_user : '0 , d_error : d_valid && d_error , a_ready : ( gnt_i | error_internal ) & reqfifo_wready & sramreqfifo_wready } ;], policy: fit-else-expand, (origin: "assign tl_o...fo_wready};")
*** end of partially formatted partition list
[other error status]
hw/ip/prim/rtl/prim_subreg_shadow.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_diff_decode.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_sram_arbiter.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_alert_sender.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_gf_mult.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_util_pkg.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_ram_1p_adv.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_ram_1p_scr.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_secded_39_32_dec.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_filter.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_cipher_pkg.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_assert_dummy_macros.svh: Already formatted, no change.
hw/ip/prim/rtl/prim_alert_receiver.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_keccak.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_clock_gating_sync.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_packer.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_present.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_ram_2p_adv.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_secded_28_22_dec.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_filter_ctr.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_esc_sender.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_arbiter_ppc.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_subreg.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_rom_adv.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_assert_standard_macros.svh: Already formatted, no change.
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro INC_ASSERT
hw/ip/prim/rtl/prim_arbiter_tree.sv: Already formatted, no change.
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro INC_ASSERT
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro INC_ASSERT
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro INC_ASSERT
hw/ip/prim/rtl/prim_assert.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_intr_hw.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_sync_reqack.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_secded_39_32_enc.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_esc_receiver.sv: Already formatted, no change.
hw/ip/prim/fpv/vip/prim_fifo_sync_assert_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/vip/prim_esc_rxtx_assert_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_alert_rxtx_bind_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_lfsr_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_alert_rxtx_async_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/vip/prim_alert_rxtx_async_assert_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_esc_rxtx_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_alert_rxtx_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_fifo_sync_bind_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_alert_rxtx_async_bind_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_esc_rxtx_bind_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_arbiter_fixed_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/vip/prim_alert_rxtx_assert_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_keccak_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_arbiter_tree_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_arbiter_ppc_fpv.sv: Already formatted, no change.
hw/ip/prim/fpv/tb/prim_fifo_sync_fpv.sv: Already formatted, no change.
hw/ip/prim/dv/prim_lfsr/tb/prim_lfsr_tb.sv: Already formatted, no change.
hw/ip/prim/pre_dv/prim_sync_reqack/rtl/prim_sync_reqack_tb.sv: Already formatted, no change.
hw/ip/prim/dv/prim_present/crypto_dpi_present/crypto_dpi_present_pkg.sv: Already formatted, no change.
hw/ip/clkmgr/rtl/clkmgr_reg_pkg.sv: Already formatted, no change.
hw/ip/prim/dv/prim_present/tb/prim_present_tb.sv: Already formatted, no change.
hw/ip/clkmgr/rtl/clkmgr_pkg.sv: Already formatted, no change.
hw/ip/flash_ctrl/dv/env/seq_lib/flash_ctrl_base_vseq.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev_iomux.sv: Already formatted, no change.
hw/ip/clkmgr/rtl/clkmgr.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev_flop_2syncpulse.sv: Already formatted, no change.
hw/ip/clkmgr/rtl/clkmgr_reg_top.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev_linkstate.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev_reg_pkg.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev_usbif.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/usbdev_env_pkg.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/usbdev_virtual_sequencer.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_secded_72_64_enc.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/usbdev_env.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/seq_lib/usbdev_common_vseq.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/usbdev_env_cfg.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/seq_lib/usbdev_vseq_list.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/seq_lib/usbdev_sanity_vseq.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/seq_lib/usbdev_base_vseq.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/usbdev_env_cov.sv: Already formatted, no change.
hw/ip/usbdev/dv/tests/usbdev_base_test.sv: Already formatted, no change.
hw/ip/usbdev/dv/tests/usbdev_test_pkg.sv: Already formatted, no change.
hw/ip/usbdev/dv/env/usbdev_scoreboard.sv: Already formatted, no change.
hw/ip/usbdev/dv/sva/usbdev_bind.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev.sv: Already formatted, no change.
hw/ip/usbdev/dv/tb/tb.sv: Already formatted, no change.
hw/ip/rv_plic/rtl/rv_plic.sv: Already formatted, no change.
hw/ip/rv_plic/rtl/rv_plic_gateway.sv: Already formatted, no change.
hw/ip/rv_plic/rtl/rv_plic_target.sv: Already formatted, no change.
hw/ip/rv_plic/fpv/tb/rv_plic_bind_fpv.sv: Already formatted, no change.
hw/ip/rv_plic/rtl/rv_plic_reg_pkg.sv: Already formatted, no change.
hw/ip/rv_plic/fpv/vip/rv_plic_assert_fpv.sv: Already formatted, no change.
hw/ip/rv_plic/fpv/tb/rv_plic_generic_fpv.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_wake_info.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_cdc_pulse.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_slow_fsm.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_pkg.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_cdc.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_reg_pkg.sv: Already formatted, no change.
hw/ip/pwrmgr/dv/sva/pwrmgr_bind.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_fsm.sv: Already formatted, no change.
hw/ip/pwrmgr/rtl/pwrmgr_reg_top.sv: Already formatted, no change.
hw/ip/i2c/rtl/i2c_fsm.sv: Already formatted, no change.
hw/ip/i2c/rtl/i2c_core.sv: Already formatted, no change.
hw/ip/i2c/rtl/i2c.sv: Already formatted, no change.
hw/ip/i2c/dv/env/i2c_virtual_sequencer.sv: Already formatted, no change.
hw/ip/i2c/dv/env/i2c_env_cfg.svhw/ip/i2c/rtl/i2c_reg_pkg.sv: Already formatted, no change.
: Already formatted, no change.
hw/ip/i2c/dv/env/i2c_env_cov.sv: Already formatted, no change.
hw/ip/i2c/dv/env/i2c_env_pkg.sv: Already formatted, no change.
hw/ip/i2c/dv/env/i2c_env.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_perf_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_fifo_full_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_sanity_vseq.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_secded_72_64_dec.sv: Already formatted, no change.
hw/ip/tlul/rtl/tlul_assert.sv: *** Some token partitions failed to complete within the search limit:
>>>>[( ( ! a_mask [ 0 ] ) || ( a_mask [ 0 ] && ! $isunknown ( a_data [ 8 * 0 +: 8 ] ) ) ) && ( ( ! a_mask [ 1 ] ) || ( a_mask [ 1 ] && ! $isunknown ( a_data [ 8 * 1 +: 8 ] ) ) ) && ( ( ! a_mask [ 2 ] ) || ( a_mask [ 2 ] && ! $isunknown ( a_data [ 8 * 2 +: 8 ] ) ) ) && ( ( ! a_mask [ 3 ] ) || ( a_mask [ 3 ] && ! $isunknown ( a_data [ 8 * 3 +: 8 ] ) ) ) && ( ( ! a_mask [ 4 ] ) || ( a_mask [ 4 ] && ! $isunknown ( a_data [ 8 * 4 +: 8 ] ) ) ) && ( ( ! a_mask [ 5 ] ) || ( a_mask [ 5 ] && ! $isunknown ( a_data [ 8 * 5 +: 8 ] ) ) ) && ( ( ! a_mask [ 6 ] ) || ( a_mask [ 6 ] && ! $isunknown ( a_data [ 8 * 6 +: 8 ] ) ) ) && ( ( ! a_mask [ 7 ] ) || ( a_mask [ 7 ] && ! $isunknown ( a_data [ 8 * 7 +: 8 ] ) ) ) ;], policy: fit-else-expand
>>>>[( ( ! d_mask [ 0 ] ) || ( d_mask [ 0 ] && ! $isunknown ( d_data [ 8 * 0 +: 8 ] ) ) ) && ( ( ! d_mask [ 1 ] ) || ( d_mask [ 1 ] && ! $isunknown ( d_data [ 8 * 1 +: 8 ] ) ) ) && ( ( ! d_mask [ 2 ] ) || ( d_mask [ 2 ] && ! $isunknown ( d_data [ 8 * 2 +: 8 ] ) ) ) && ( ( ! d_mask [ 3 ] ) || ( d_mask [ 3 ] && ! $isunknown ( d_data [ 8 * 3 +: 8 ] ) ) ) && ( ( ! d_mask [ 4 ] ) || ( d_mask [ 4 ] && ! $isunknown ( d_data [ 8 * 4 +: 8 ] ) ) ) && ( ( ! d_mask [ 5 ] ) || ( d_mask [ 5 ] && ! $isunknown ( d_data [ 8 * 5 +: 8 ] ) ) ) && ( ( ! d_mask [ 6 ] ) || ( d_mask [ 6 ] && ! $isunknown ( d_data [ 8 * 6 +: 8 ] ) ) ) && ( ( ! d_mask [ 7 ] ) || ( d_mask [ 7 ] && ! $isunknown ( d_data [ 8 * 7 +: 8 ] ) ) ) ;], policy: fit-else-expand
*** end of partially formatted partition list
[other error status]
hw/ip/i2c/dv/env/seq_lib/i2c_stretch_timeout_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_rx_tx_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/env/i2c_scoreboard.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_override_vseq.sv: Already formatted, no change.
hw/ip/usbdev/rtl/usbdev_reg_top.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_common_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_fifo_watermark_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/tests/i2c_base_test.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_vseq_list.sv: Already formatted, no change.
hw/ip/i2c/dv/tests/i2c_test_pkg.sv: Already formatted, no change.
hw/ip/i2c/dv/sva/i2c_bind.sv: Already formatted, no change.
hw/ip/i2c/rtl/i2c_reg_top.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_fifo_overflow_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/env/seq_lib/i2c_base_vseq.sv: Already formatted, no change.
hw/ip/i2c/dv/tb/tb.sv: Already formatted, no change.
hw/ip/uart/rtl/uart_rx.sv: Already formatted, no change.
hw/ip/uart/rtl/uart_tx.sv: Already formatted, no change.
hw/ip/uart/rtl/uart_reg_pkg.sv: Already formatted, no change.
hw/ip/uart/rtl/uart.sv: Already formatted, no change.
hw/ip/uart/dv/env/uart_env_cfg.sv: Already formatted, no change.
hw/ip/rv_plic/rtl/rv_plic_reg_top.sv: Already formatted, no change.
hw/ip/uart/dv/env/uart_virtual_sequencer.sv: Already formatted, no change.
hw/ip/uart/dv/env/uart_env.sv: Already formatted, no change.
hw/ip/uart/rtl/uart_core.sv: Already formatted, no change.
hw/ip/uart/dv/env/uart_env_pkg.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_common_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/uart_env_cov.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_fifo_full_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_fifo_overflow_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_tx_ovrd_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_sanity_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_loopback_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_perf_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_rx_parity_err_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_stress_all_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_vseq_list.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_rx_start_bit_filter_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_noise_filter_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_tx_rx_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_base_vseq.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (')') (#41: ")") vs. (MacroCallCloseToEndLine) (#746: ")")
First mismatched token [103]: (')') (#41: ")") vs. (MacroCallCloseToEndLine) (#746: ")")
; problematic formatter output is
// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

class uart_base_vseq extends cip_base_vseq#(
    .CFG_T(uart_env_cfg),
    .RAL_T(uart_reg_block),
    .COV_T(uart_env_cov),
    .VIRTUAL_SEQUENCER_T(uart_virtual_sequencer)
);
  `uvm_object_utils(uart_base_vseq)

  // variables for dut initialization
  rand baud_rate_e baud_rate;  // set baud rate
  rand bit en_tx;  // enable tx
  rand bit en_rx;  // enable rx
  rand bit en_parity;  // enable parity
  rand bit odd_parity;  // enable odd parity
  rand bit en_noise_filter;  // enable noise filter

  // enable interrupts
  rand bit [NumUartIntr-1:0] en_intr;

  // random delays to access fifo/intr, may be controlled in extended seq
  rand uint dly_to_access_fifo;

  // various knobs to enable certain routines
  bit do_interrupt = 1'b1;

  constraint baud_rate_c {
    // constrain nco not over nco.get_n_bits
    `CALC_NCO(baud_rate, p_sequencer.cfg.clk_freq_mhz)
    < 2 ** p_sequencer.cfg.ral.ctrl.nco.get_n_bits();
  }

  constraint dly_to_access_fifo_c {
    // uart clk is slow, up to 2 ** 16 (65_536) slower than pclk
    // 1_000_000 is about 1.5 * 65_536
    dly_to_access_fifo dist {
      0 :/ 1,
      [1 : 100] :/ 1,
      [101 : 10_000] :/ 8,
      [10_001 : 1_000_000] :/ 1
    };
  }

  `uvm_object_new

  virtual task dut_shutdown();
    super.dut_shutdown();
    // wait for tx and rx operations to complete
    `uvm_info(`gfn, "waiting for idle", UVM_HIGH)
    cfg.m_uart_agent_cfg.vif.wait_for_idle();
    `uvm_info(`gfn, "done waiting for idle", UVM_HIGH)
  endtask

  // setup basic uart features
  virtual task uart_init();
    int nco = get_nco(baud_rate, cfg.clk_freq_mhz, ral.ctrl.nco.get_n_bits());
    // cfg uart agent to set the baud rate & parity
    cfg.m_uart_agent_cfg.set_baud_rate(baud_rate);
    cfg.m_uart_agent_cfg.set_parity(en_parity, odd_parity);
    ral.ctrl.tx.set(en_tx);
    ral.ctrl.rx.set(en_rx);
    ral.ctrl.nf.set(en_noise_filter);
    ral.ctrl.parity_en.set(en_parity);
    ral.ctrl.parity_odd.set(odd_parity);
    if (do_interrupt) `DV_CHECK_RANDOMIZE_FATAL(ral.ctrl.rxblvl)
    ral.ctrl.nco.set(nco);
    csr_update(ral.ctrl);

    if (do_interrupt) begin
      ral.intr_enable.set(en_intr);
      csr_update(ral.intr_enable);

      // from spec - timeout value may be reduced by 1.5 clock periods at some corner cases
      // need >= char time + 2, so that receiving next character can reset the counter
      // before timer is expired
      `DV_CHECK_RANDOMIZE_WITH_FATAL(ral.timeout_ctrl.val,
                                     value inside {[10 + en_parity + 2 : 100]};)
      `DV_CHECK_RANDOMIZE_FATAL(ral.timeout_ctrl.en)
      csr_update(ral.timeout_ctrl);

      `DV_CHECK_RANDOMIZE_WITH_FATAL(ral.fifo_ctrl.rxilvl, value <= 4;)
      `DV_CHECK_RANDOMIZE_FATAL(ral.fifo_ctrl.txilvl)
      csr_update(ral.fifo_ctrl);
    end
  endtask

  // clear fifos
  virtual task clear_fifos(bit clear_tx_fifo, bit clear_rx_fifo);
    ral.fifo_ctrl.rxrst.set(clear_rx_fifo);
    ral.fifo_ctrl.txrst.set(clear_tx_fifo);
    csr_update(ral.fifo_ctrl);
  endtask

  // set uart parity for the dut and the agent
  virtual task set_parity(bit en_parity, bit odd_parity);
    // cfg uart dut
    ral.ctrl.parity_en.set(en_parity);
    ral.ctrl.parity_odd.set(odd_parity);
    csr_update(ral.ctrl);
    // cfg uart agent
    cfg.m_uart_agent_cfg.set_parity(en_parity, odd_parity);
  endtask

  // set uart baud rate for the dut and the agent
  virtual task set_baud_rate(baud_rate_e baud_rate);
    int nco = get_nco(baud_rate, cfg.clk_freq_mhz, ral.ctrl.nco.get_n_bits());
    ral.ctrl.nco.set(nco);
    csr_update(ral.ctrl);
    // cfg uart agent
    cfg.m_uart_agent_cfg.set_baud_rate(baud_rate);
  endtask

  virtual task spinwait_txidle();
    if (ral.ctrl.tx.get_mirrored_value()) begin
      // use a very big timeout as it takes long time to flush all the items
      csr_spinwait(.ptr(ral.status.txidle), .exp_data(1'b1), .timeout_ns(40_000_000));
    end
  endtask

  virtual task spinwait_rxidle();
    if (ral.ctrl.rx.get_mirrored_value()) begin
      csr_spinwait(.ptr(ral.status.rxidle), .exp_data(1'b1));
    end
  endtask

  // task to send a byte of data out of dut
  virtual task send_tx_byte(byte data);
    csr_wr(.csr(ral.wdata), .value(data));
  endtask

  // task to send a byte of data into dut, can override it to test error cases
  virtual task send_rx_byte(byte data);
    drive_rx_error_byte(.parity_err(0), .frame_err(0), .data(data));
  endtask

  // drive rx byte with parity_err or frame_err, data is random
  virtual task drive_rx_error_byte(bit parity_err, bit frame_err, byte data = $urandom);
    uart_seq send_rx_seq;
    `uvm_create_on(send_rx_seq, p_sequencer.uart_sequencer_h);
    `DV_CHECK_RANDOMIZE_WITH_FATAL(send_rx_seq, data == local::data;
                                   parity_err == local::parity_err;
                                   frame_err  == local::frame_err;)
    `uvm_send(send_rx_seq)
  endtask : drive_rx_error_byte

  // task to check if byte received is what was sent by the agent
  virtual task chk_rx_byte(logic [7:0] exp_data);
    bit [TL_DW-1:0] rdata;
    csr_rd(.ptr(ral.rdata), .value(rdata));
    // do check but only if rx is enabled
    if (ral.ctrl.rx.get_mirrored_value()) begin
      if (!cfg.under_reset) `DV_CHECK_EQ(rdata, exp_data)
    end
  endtask

  // task to read all the rx bytes
  virtual task read_all_rx_bytes();
    bit [TL_DW-1:0] rdata, fifo_status;

    csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
    repeat (get_field_val(ral.fifo_status.rxlvl, fifo_status)) begin
      wait_ignored_period_and_read_rdata(rdata);
    end

    csr_rd(.ptr(ral.fifo_status), .value(fifo_status));

    `uvm_info(`gfn, "read_all_rx_bytes is done", UVM_HIGH)
  endtask : read_all_rx_bytes

  // override this function to control RX fifo level
  virtual task rand_read_rx_byte(uint weight_to_skip);
    bit [TL_DW-1:0] rdata, fifo_status;
    int rxlvl;

    randcase
      1: begin  // read & check one byte
        csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
        rxlvl = get_field_val(ral.fifo_status.rxlvl, fifo_status);
        if (rxlvl > 0) begin
          wait_ignored_period_and_read_rdata(rdata);
        end
      end
      1: begin  // read & check some bytes
        csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
        rxlvl = get_field_val(ral.fifo_status.rxlvl, fifo_status);
        if (rxlvl > 0) begin
          repeat ($urandom_range(1, rxlvl)) wait_ignored_period_and_read_rdata(rdata);
        end
      end
      1: begin  // read & check all rx bytes
        read_all_rx_bytes();
      end
      weight_to_skip: begin
      end
    endcase
  endtask : rand_read_rx_byte

  // read rx data from CSR rdata, but wait until it's not in igored period
  virtual task wait_ignored_period_and_read_rdata(ref bit [TL_DW-1:0] rdata);
    wait_when_in_ignored_period(.rx(1));
    csr_rd(.ptr(ral.rdata), .value(rdata));
  endtask

  // task to wait for all rx bytes to be sent
  virtual task wait_for_all_tx_bytes();
    bit [TL_DW-1:0] fifo_status, status;

    if (ral.ctrl.tx.get_mirrored_value()) begin
      do begin
        `DV_CHECK_MEMBER_RANDOMIZE_FATAL(dly_to_access_fifo)
        cfg.clk_rst_vif.wait_clks(dly_to_access_fifo);
        csr_rd(.ptr(ral.fifo_status), .value(fifo_status));
        csr_rd(.ptr(ral.status), .value(status));
      end while (get_field_val(ral.fifo_status.txlvl, fifo_status) > 0 ||
                 get_field_val(ral.status.txidle, status) == 0);
    end

    `uvm_info(`gfn, "wait_for_all_tx_bytes is done", UVM_HIGH)
  endtask : wait_for_all_tx_bytes

  // task to wait for tx fifo not full
  virtual task wait_for_tx_fifo_not_full();
    bit [TL_DW-1:0] status;

    if (ral.ctrl.tx.get_mirrored_value()) begin
      `DV_CHECK_MEMBER_RANDOMIZE_FATAL(dly_to_access_fifo)
      csr_spinwait(
      .ptr(ral.status.txfull),
      .exp_data(1'b0),
      .spinwait_delay_ns(dly_to_access_fifo)
      );
    end

    `uvm_info(`gfn, "wait_for_tx_fifo_not_full is done", UVM_HIGH)
  endtask : wait_for_tx_fifo_not_full

  // task to wait for rx fifo not full, will be overriden in overflow test
  virtual task wait_for_rx_fifo_not_full();
    if (ral.ctrl.rx.get_mirrored_value()) begin
      `DV_CHECK_MEMBER_RANDOMIZE_FATAL(dly_to_access_fifo)
      csr_spinwait(
      .ptr(ral.status.rxfull),
      .exp_data(1'b0),
      .spinwait_delay_ns(dly_to_access_fifo),
      .timeout_ns(50_000_000)
      );  // use longer timeout as uart freq is low
    end
    `uvm_info(`gfn, "wait_for_rx_fifo_not_full is done", UVM_HIGH)
  endtask : wait_for_rx_fifo_not_full

  // in some corner cases, we can't drive when the uart item is almost done
  // wait for this period to pass
  virtual task wait_when_in_ignored_period(bit tx = 0, bit rx = 0);
    wait(!((tx && cfg.m_uart_agent_cfg.vif.uart_tx_clk_pulses inside `TX_IGNORED_PERIOD) || (
           rx && cfg.m_uart_agent_cfg.vif.uart_rx_clk_pulses inside `RX_IGNORED_PERIOD)));
    `uvm_info(`gfn, "wait_when_in_ignored_period is done", UVM_HIGH)
  endtask : wait_when_in_ignored_period

endclass : uart_base_vseq
<<EOF>>
hw/ip/uart/dv/env/seq_lib/uart_rx_oversample_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/tests/uart_base_test.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_fifo_reset_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/tests/uart_test_pkg.sv: Already formatted, no change.
hw/ip/uart/dv/sva/uart_bind.sv: Already formatted, no change.
hw/ip/uart/dv/env/seq_lib/uart_intr_vseq.sv: Already formatted, no change.
hw/ip/uart/dv/tb/tb.sv: Already formatted, no change.
hw/ip/trial1/rtl/trial1_reg_pkg.sv: Already formatted, no change.
hw/ip/trial1/dv/bus_pkg.sv: Already formatted, no change.
hw/ip/trial1/dv/tb.sv: Already formatted, no change.
hw/ip/uart/rtl/uart_reg_top.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/tb/unused/SimDTM.sv: hw/vendor/pulp_riscv_dbg/tb/unused/SimDTM.sv:38:8: syntax error, rejected "#" (https://github.com/google/verible).
hw/vendor/pulp_riscv_dbg/tb/unused/SimDTM.sv:39:8: syntax error, rejected "#" (https://github.com/google/verible).

hw/vendor/pulp_riscv_dbg/tb/tb_top.sv: Already formatted, no change.
hw/ip/uart/dv/env/uart_scoreboard.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/tb/SimJTAG.sv: hw/vendor/pulp_riscv_dbg/tb/SimJTAG.sv:45:17: syntax error, rejected "#" (https://github.com/google/verible).

hw/vendor/pulp_riscv_dbg/tb/tb_test_env.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/tb/dp_ram.sv: Re-formatted text does not match formatted text; formatting failed to converge!  Please file a bug.
Original: --lines: 
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright 2017 Embecosm Limited <www.embecosm.com>
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

module dp_ram #(
    parameter int unsigned ADDR_WIDTH = 8,
    parameter int unsigned INSTR_RDATA_WIDTH = 128
) (
    input logic                          clk_i,

    input logic                          en_a_i,
    input logic [ADDR_WIDTH-1:0]         addr_a_i,
    input logic [31:0]                   wdata_a_i,
    output logic [INSTR_RDATA_WIDTH-1:0] rdata_a_o,
    input logic                          we_a_i,
    input logic [3:0]                    be_a_i,

    input logic                          en_b_i,
    input logic [ADDR_WIDTH-1:0]         addr_b_i,
    input logic [31:0]                   wdata_b_i,
    output logic [31:0]                  rdata_b_o,
    input logic                          we_b_i,
    input logic [3:0]                    be_b_i
);

    localparam bytes = 2**ADDR_WIDTH;

    logic [7:0]                      mem[bytes];
    logic [ADDR_WIDTH-1:0]           addr_a_int;
    logic [ADDR_WIDTH-1:0]           addr_b_int;

    always_comb addr_a_int = {addr_a_i[ADDR_WIDTH-1:2], 2'b0};
    always_comb addr_b_int = {addr_b_i[ADDR_WIDTH-1:2], 2'b0};

    always @(posedge clk_i) begin
        for (int i = 0; i < INSTR_RDATA_WIDTH/8; i++) begin
            rdata_a_o[(i*8)+: 8] <= mem[addr_a_int +  i];
        end

        /* addr_b_i is the actual memory address referenced */
        if (en_b_i) begin
            /* handle writes */
            if (we_b_i) begin
                if (be_b_i[0]) mem[addr_b_int    ] <= wdata_b_i[ 0+:8];
                if (be_b_i[1]) mem[addr_b_int + 1] <= wdata_b_i[ 8+:8];
                if (be_b_i[2]) mem[addr_b_int + 2] <= wdata_b_i[16+:8];
                if (be_b_i[3]) mem[addr_b_int + 3] <= wdata_b_i[24+:8];
            end
            /* handle reads */
            else begin
                if ($test$plusargs("verbose"))
                    $display("read  addr=0x%08x: data=0x%08x", addr_b_int,
                             {mem[addr_b_int + 3], mem[addr_b_int + 2],
                              mem[addr_b_int + 1], mem[addr_b_int + 0]});

                rdata_b_o[ 7: 0] <= mem[addr_b_int    ];
                rdata_b_o[15: 8] <= mem[addr_b_int + 1];
                rdata_b_o[23:16] <= mem[addr_b_int + 2];
                rdata_b_o[31:24] <= mem[addr_b_int + 3];
            end
        end
    end

    export "DPI-C" function read_byte;
    export "DPI-C" task write_byte;

    function int read_byte(input logic [ADDR_WIDTH-1:0] byte_addr);
        read_byte = mem[byte_addr];
    endfunction

    task write_byte(input integer byte_addr, logic [7:0] val, output logic [7:0] other);
        mem[byte_addr] = val;
        other          = mem[byte_addr];

    endtask

endmodule // dp_ram
Formatted:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright 2017 Embecosm Limited <www.embecosm.com>
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

module dp_ram #(
    parameter int unsigned ADDR_WIDTH = 8,
    parameter int unsigned INSTR_RDATA_WIDTH = 128
) (
    input logic clk_i,

    input  logic                         en_a_i,
    input  logic [       ADDR_WIDTH-1:0] addr_a_i,
    input  logic [                 31:0] wdata_a_i,
    output logic [INSTR_RDATA_WIDTH-1:0] rdata_a_o,
    input  logic                         we_a_i,
    input  logic [                  3:0] be_a_i,

    input  logic                  en_b_i,
    input  logic [ADDR_WIDTH-1:0] addr_b_i,
    input  logic [          31:0] wdata_b_i,
    output logic [          31:0] rdata_b_o,
    input  logic                  we_b_i,
    input  logic [           3:0] be_b_i
);

  localparam bytes = 2 ** ADDR_WIDTH;

  logic [7:0] mem[bytes];
  logic [ADDR_WIDTH-1:0] addr_a_int;
  logic [ADDR_WIDTH-1:0] addr_b_int;

  always_comb addr_a_int = {addr_a_i[ADDR_WIDTH - 1:2], 2'b0};
  always_comb addr_b_int = {addr_b_i[ADDR_WIDTH - 1:2], 2'b0};

  always @(posedge clk_i) begin
    for (int i = 0; i < INSTR_RDATA_WIDTH / 8; i++) begin
      rdata_a_o[(i * 8) +: 8] <= mem[addr_a_int + i];
    end

    /* addr_b_i is the actual memory address referenced */
    if (en_b_i) begin
      /* handle writes */
      if (we_b_i) begin
        if (be_b_i[0]) mem[addr_b_int] <= wdata_b_i[0 +: 8];
        if (be_b_i[1]) mem[addr_b_int + 1] <= wdata_b_i[8 +: 8];
        if (be_b_i[2]) mem[addr_b_int + 2] <= wdata_b_i[16 +: 8];
        if (be_b_i[3]) mem[addr_b_int + 3] <= wdata_b_i[24 +: 8];
      end  /* handle reads */
          else
      begin
        if ($test$plusargs("verbose"))
          $display("read  addr=0x%08x: data=0x%08x", addr_b_int, {
            mem[addr_b_int + 3], mem[addr_b_int + 2], mem[addr_b_int + 1], mem[addr_b_int + 0]
          });

        rdata_b_o[7:0] <= mem[addr_b_int];
        rdata_b_o[15:8] <= mem[addr_b_int + 1];
        rdata_b_o[23:16] <= mem[addr_b_int + 2];
        rdata_b_o[31:24] <= mem[addr_b_int + 3];
      end
    end
  end

  export "DPI-C"
  function read_byte
  ; export "DPI-C"
  task write_byte
  ;

  function int read_byte(input logic [ADDR_WIDTH-1:0] byte_addr);
    read_byte = mem[byte_addr];
  endfunction

  task write_byte(input integer byte_addr, logic [7:0] val, output logic [7:0] other);
    mem[byte_addr] = val;
    other = mem[byte_addr];

  endtask

endmodule  // dp_ram
Re-formatted:
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright 2017 Embecosm Limited <www.embecosm.com>
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

module dp_ram #(
    parameter int unsigned ADDR_WIDTH = 8,
    parameter int unsigned INSTR_RDATA_WIDTH = 128
) (
    input logic clk_i,

    input  logic                         en_a_i,
    input  logic [       ADDR_WIDTH-1:0] addr_a_i,
    input  logic [                 31:0] wdata_a_i,
    output logic [INSTR_RDATA_WIDTH-1:0] rdata_a_o,
    input  logic                         we_a_i,
    input  logic [                  3:0] be_a_i,

    input  logic                  en_b_i,
    input  logic [ADDR_WIDTH-1:0] addr_b_i,
    input  logic [          31:0] wdata_b_i,
    output logic [          31:0] rdata_b_o,
    input  logic                  we_b_i,
    input  logic [           3:0] be_b_i
);

  localparam bytes = 2 ** ADDR_WIDTH;

  logic [7:0] mem[bytes];
  logic [ADDR_WIDTH-1:0] addr_a_int;
  logic [ADDR_WIDTH-1:0] addr_b_int;

  always_comb addr_a_int = {addr_a_i[ADDR_WIDTH - 1:2], 2'b0};
  always_comb addr_b_int = {addr_b_i[ADDR_WIDTH - 1:2], 2'b0};

  always @(posedge clk_i) begin
    for (int i = 0; i < INSTR_RDATA_WIDTH / 8; i++) begin
      rdata_a_o[(i * 8) +: 8] <= mem[addr_a_int + i];
    end

    /* addr_b_i is the actual memory address referenced */
    if (en_b_i) begin
      /* handle writes */
      if (we_b_i) begin
        if (be_b_i[0]) mem[addr_b_int] <= wdata_b_i[0 +: 8];
        if (be_b_i[1]) mem[addr_b_int + 1] <= wdata_b_i[8 +: 8];
        if (be_b_i[2]) mem[addr_b_int + 2] <= wdata_b_i[16 +: 8];
        if (be_b_i[3]) mem[addr_b_int + 3] <= wdata_b_i[24 +: 8];
      end  /* handle reads */
          else begin
        if ($test$plusargs("verbose"))
          $display("read  addr=0x%08x: data=0x%08x", addr_b_int, {
            mem[addr_b_int + 3], mem[addr_b_int + 2], mem[addr_b_int + 1], mem[addr_b_int + 0]
          });

        rdata_b_o[7:0] <= mem[addr_b_int];
        rdata_b_o[15:8] <= mem[addr_b_int + 1];
        rdata_b_o[23:16] <= mem[addr_b_int + 2];
        rdata_b_o[31:24] <= mem[addr_b_int + 3];
      end
    end
  end

  export "DPI-C"
  function read_byte
  ; export "DPI-C"
  task write_byte
  ;

  function int read_byte(input logic [ADDR_WIDTH-1:0] byte_addr);
    read_byte = mem[byte_addr];
  endfunction

  task write_byte(input integer byte_addr, logic [7:0] val, output logic [7:0] other);
    mem[byte_addr] = val;
    other = mem[byte_addr];

  endtask

endmodule  // dp_ram
Diffs are:
 // Copyright 2020 ETH Zurich and University of Bologna.
 // Copyright 2017 Embecosm Limited <www.embecosm.com>
 // Copyright and related rights are licensed under the Solderpad Hardware
 // License, Version 0.51 (the "License"); you may not use this file except in
 // compliance with the License.  You may obtain a copy of the License at
 // http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
 // or agreed to in writing, software, hardware and materials distributed under
 // this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 // CONDITIONS OF ANY KIND, either express or implied. See the License for the
 // specific language governing permissions and limitations under the License.
 
 module dp_ram #(
     parameter int unsigned ADDR_WIDTH = 8,
     parameter int unsigned INSTR_RDATA_WIDTH = 128
 ) (
     input logic clk_i,
 
     input  logic                         en_a_i,
     input  logic [       ADDR_WIDTH-1:0] addr_a_i,
     input  logic [                 31:0] wdata_a_i,
     output logic [INSTR_RDATA_WIDTH-1:0] rdata_a_o,
     input  logic                         we_a_i,
     input  logic [                  3:0] be_a_i,
 
     input  logic                  en_b_i,
     input  logic [ADDR_WIDTH-1:0] addr_b_i,
     input  logic [          31:0] wdata_b_i,
     output logic [          31:0] rdata_b_o,
     input  logic                  we_b_i,
     input  logic [           3:0] be_b_i
 );
 
   localparam bytes = 2 ** ADDR_WIDTH;
 
   logic [7:0] mem[bytes];
   logic [ADDR_WIDTH-1:0] addr_a_int;
   logic [ADDR_WIDTH-1:0] addr_b_int;
 
   always_comb addr_a_int = {addr_a_i[ADDR_WIDTH - 1:2], 2'b0};
   always_comb addr_b_int = {addr_b_i[ADDR_WIDTH - 1:2], 2'b0};
 
   always @(posedge clk_i) begin
     for (int i = 0; i < INSTR_RDATA_WIDTH / 8; i++) begin
       rdata_a_o[(i * 8) +: 8] <= mem[addr_a_int + i];
     end
 
     /* addr_b_i is the actual memory address referenced */
     if (en_b_i) begin
       /* handle writes */
       if (we_b_i) begin
         if (be_b_i[0]) mem[addr_b_int] <= wdata_b_i[0 +: 8];
         if (be_b_i[1]) mem[addr_b_int + 1] <= wdata_b_i[8 +: 8];
         if (be_b_i[2]) mem[addr_b_int + 2] <= wdata_b_i[16 +: 8];
         if (be_b_i[3]) mem[addr_b_int + 3] <= wdata_b_i[24 +: 8];
       end  /* handle reads */
-          else
-      begin
+          else begin
         if ($test$plusargs("verbose"))
           $display("read  addr=0x%08x: data=0x%08x", addr_b_int, {
             mem[addr_b_int + 3], mem[addr_b_int + 2], mem[addr_b_int + 1], mem[addr_b_int + 0]
           });
 
         rdata_b_o[7:0] <= mem[addr_b_int];
         rdata_b_o[15:8] <= mem[addr_b_int + 1];
         rdata_b_o[23:16] <= mem[addr_b_int + 2];
         rdata_b_o[31:24] <= mem[addr_b_int + 3];
       end
     end
   end
 
   export "DPI-C"
   function read_byte
   ; export "DPI-C"
   task write_byte
   ;
 
   function int read_byte(input logic [ADDR_WIDTH-1:0] byte_addr);
     read_byte = mem[byte_addr];
   endfunction
 
   task write_byte(input integer byte_addr, logic [7:0] val, output logic [7:0] other);
     mem[byte_addr] = val;
     other = mem[byte_addr];
 
   endtask
 
 endmodule  // dp_ram
; problematic formatter output is
// Copyright 2020 ETH Zurich and University of Bologna.
// Copyright 2017 Embecosm Limited <www.embecosm.com>
// Copyright and related rights are licensed under the Solderpad Hardware
// License, Version 0.51 (the "License"); you may not use this file except in
// compliance with the License.  You may obtain a copy of the License at
// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law
// or agreed to in writing, software, hardware and materials distributed under
// this License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

module dp_ram #(
    parameter int unsigned ADDR_WIDTH = 8,
    parameter int unsigned INSTR_RDATA_WIDTH = 128
) (
    input logic clk_i,

    input  logic                         en_a_i,
    input  logic [       ADDR_WIDTH-1:0] addr_a_i,
    input  logic [                 31:0] wdata_a_i,
    output logic [INSTR_RDATA_WIDTH-1:0] rdata_a_o,
    input  logic                         we_a_i,
    input  logic [                  3:0] be_a_i,

    input  logic                  en_b_i,
    input  logic [ADDR_WIDTH-1:0] addr_b_i,
    input  logic [          31:0] wdata_b_i,
    output logic [          31:0] rdata_b_o,
    input  logic                  we_b_i,
    input  logic [           3:0] be_b_i
);

  localparam bytes = 2 ** ADDR_WIDTH;

  logic [7:0] mem[bytes];
  logic [ADDR_WIDTH-1:0] addr_a_int;
  logic [ADDR_WIDTH-1:0] addr_b_int;

  always_comb addr_a_int = {addr_a_i[ADDR_WIDTH - 1:2], 2'b0};
  always_comb addr_b_int = {addr_b_i[ADDR_WIDTH - 1:2], 2'b0};

  always @(posedge clk_i) begin
    for (int i = 0; i < INSTR_RDATA_WIDTH / 8; i++) begin
      rdata_a_o[(i * 8) +: 8] <= mem[addr_a_int + i];
    end

    /* addr_b_i is the actual memory address referenced */
    if (en_b_i) begin
      /* handle writes */
      if (we_b_i) begin
        if (be_b_i[0]) mem[addr_b_int] <= wdata_b_i[0 +: 8];
        if (be_b_i[1]) mem[addr_b_int + 1] <= wdata_b_i[8 +: 8];
        if (be_b_i[2]) mem[addr_b_int + 2] <= wdata_b_i[16 +: 8];
        if (be_b_i[3]) mem[addr_b_int + 3] <= wdata_b_i[24 +: 8];
      end  /* handle reads */
          else
      begin
        if ($test$plusargs("verbose"))
          $display("read  addr=0x%08x: data=0x%08x", addr_b_int, {
            mem[addr_b_int + 3], mem[addr_b_int + 2], mem[addr_b_int + 1], mem[addr_b_int + 0]
          });

        rdata_b_o[7:0] <= mem[addr_b_int];
        rdata_b_o[15:8] <= mem[addr_b_int + 1];
        rdata_b_o[23:16] <= mem[addr_b_int + 2];
        rdata_b_o[31:24] <= mem[addr_b_int + 3];
      end
    end
  end

  export "DPI-C"
  function read_byte
  ; export "DPI-C"
  task write_byte
  ;

  function int read_byte(input logic [ADDR_WIDTH-1:0] byte_addr);
    read_byte = mem[byte_addr];
  endfunction

  task write_byte(input integer byte_addr, logic [7:0] val, output logic [7:0] other);
    mem[byte_addr] = val;
    other = mem[byte_addr];

  endtask

endmodule  // dp_ram
<<EOF>>
hw/vendor/pulp_riscv_dbg/tb/boot_rom.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/tb/tb_top_verilator.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/debug_rom/debug_rom.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/tb/dm_tb_pkg.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/debug_rom/debug_rom_one_scratch.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dmi_cdc.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dmi_jtag.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dm_sba.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dmi_jtag_tap.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dm_pkg.sv: Already formatted, no change.
hw/ip/trial1/rtl/trial1_reg_top.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dm_obi_top.sv: Already formatted, no change.
hw/ip/trial1/dv/trial1_test.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_pmp.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dm_csrs.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/src/dm_mem.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_dummy_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_id_stage.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_tracer_pkg.sv: Already formatted, no change.
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro COUNTER_FLOP_RST
hw/vendor/lowrisc_ibex/rtl/ibex_if_stage.sv: Already formatted, no change.
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro COUNTER_FLOP_RST
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro COUNTER_FLOP_RST
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro COUNTER_FLOP_RST
hw/vendor/lowrisc_ibex/rtl/ibex_counter.sv: Already formatted, no change.
hw/ip/prim/rtl/prim_lfsr.sv: *** Some token partitions failed to complete within the search limit:
>>[localparam logic [ 63 : 0 ] GAL_XOR_COEFFS [ 61 ] = '{ 64 'h 9 , 64 'h 12 , 64 'h 21 , 64 'h 41 , 64 'h 8E , 64 'h 108 , 64 'h 204 , 64 'h 402 , 64 'h 829 , 64 'h 100D , 64 'h 2015 , 64 'h 4001 , 64 'h 8016 , 64 'h 10004 , 64 'h 20013 , 64 'h 40013 , 64 'h 80004 , 64 'h 100002 , 64 'h 200001 , 64 'h 400010 , 64 'h 80000D , 64 'h 1000004 , 64 'h 2000023 , 64 'h 4000013 , 64 'h 8000004 , 64 'h 10000002 , 64 'h 20000029 , 64 'h 40000004 , 64 'h 80000057 , 64 'h 100000029 , 64 'h 200000073 , 64 'h 400000002 , 64 'h 80000003B , 64 'h 100000001F , 64 'h 2000000031 , 64 'h 4000000008 , 64 'h 800000001C , 64 'h 10000000004 , 64 'h 2000000001F , 64 'h 4000000002C , 64 'h 80000000032 , 64 'h 10000000000D , 64 'h 200000000097 , 64 'h 400000000010 , 64 'h 80000000005B , 64 'h 1000000000038 , 64 'h 200000000000E , 64 'h 4000000000025 , 64 'h 8000000000004 , 64 'h 10000000000023 , 64 'h 2000000000003E , 64 'h 40000000000023 , 64 'h 8000000000004A , 64 'h 100000000000016 , 64 'h 200000000000031 , 64 'h 40000000000003D , 64 'h 800000000000001 , 64 'h 1000000000000013 , 64 'h 2000000000000034 , 64 'h 4000000000000001 , 64 'h 800000000000000D } ;], policy: fit-else-expand, (origin: "localparam ...00000000D};")
>>[localparam logic [ 167 : 0 ] FIB_XNOR_COEFFS [ 166 ] = '{ 168 'h 6 , 168 'h C , 168 'h 14 , 168 'h 30 , 168 'h 60 , 168 'h B8 , 168 'h 110 , 168 'h 240 , 168 'h 500 , 168 'h 829 , 168 'h 100D , 168 'h 2015 , 168 'h 6000 , 168 'h D008 , 168 'h 12000 , 168 'h 20400 , 168 'h 40023 , 168 'h 90000 , 168 'h 140000 , 168 'h 300000 , 168 'h 420000 , 168 'h E10000 , 168 'h 1200000 , 168 'h 2000023 , 168 'h 4000013 , 168 'h 9000000 , 168 'h 14000000 , 168 'h 20000029 , 168 'h 48000000 , 168 'h 80200003 , 168 'h 100080000 , 168 'h 204000003 , 168 'h 500000000 , 168 'h 801000000 , 168 'h 100000001F , 168 'h 2000000031 , 168 'h 4400000000 , 168 'h A000140000 , 168 'h 12000000000 , 168 'h 300000C0000 , 168 'h 63000000000 , 168 'h C0000030000 , 168 'h 1B0000000000 , 168 'h 300003000000 , 168 'h 420000000000 , 168 'h C00000180000 , 168 'h 1008000000000 , 168 'h 3000000C00000 , 168 'h 6000C00000000 , 168 'h 9000000000000 , 168 'h 18003000000000 , 168 'h 30000000030000 , 168 'h 40000040000000 , 168 'h C0000600000000 , 168 'h 102000000000000 , 168 'h 200004000000000 , 168 'h 600003000000000 , 168 'h C00000000000000 , 168 'h 1800300000000000 , 168 'h 3000000000000030 , 168 'h 6000000000000000 , 168 'h D800000000000000 , 168 'h 10000400000000000 , 168 'h 30180000000000000 , 168 'h 60300000000000000 , 168 'h 80400000000000000 , 168 'h 140000028000000000 , 168 'h 300060000000000000 , 168 'h 410000000000000000 , 168 'h 820000000001040000 , 168 'h 1000000800000000000 , 168 'h 3000600000000000000 , 168 'h 6018000000000000000 , 168 'h C000000018000000000 , 168 'h 18000000600000000000 , 168 'h 30000600000000000000 , 168 'h 40200000000000000000 , 168 'h C0000000060000000000 , 168 'h 110000000000000000000 , 168 'h 240000000480000000000 , 168 'h 600000000003000000000 , 168 'h 800400000000000000000 , 168 'h 1800000300000000000000 , 168 'h 3003000000000000000000 , 168 'h 4002000000000000000000 , 168 'h C000000000000000018000 , 168 'h 10000000004000000000000 , 168 'h 30000C00000000000000000 , 168 'h 600000000000000000000C0 , 168 'h C00C0000000000000000000 , 168 'h 140000000000000000000000 , 168 'h 200001000000000000000000 , 168 'h 400800000000000000000000 , 168 'h A00000000001400000000000 , 168 'h 1040000000000000000000000 , 168 'h 2004000000000000000000000 , 168 'h 5000000000028000000000000 , 168 'h 8000000004000000000000000 , 168 'h 18600000000000000000000000 , 168 'h 30000000000000000C00000000 , 168 'h 40200000000000000000000000 , 168 'h C0300000000000000000000000 , 168 'h 100010000000000000000000000 , 168 'h 200040000000000000000000000 , 168 'h 5000000000000000A0000000000 , 168 'h 800000010000000000000000000 , 168 'h 1860000000000000000000000000 , 168 'h 3003000000000000000000000000 , 168 'h 4010000000000000000000000000 , 168 'h A000000000140000000000000000 , 168 'h 10080000000000000000000000000 , 168 'h 30000000000000000000180000000 , 168 'h 60018000000000000000000000000 , 168 'h C0000000000000000300000000000 , 168 'h 140005000000000000000000000000 , 168 'h 200000001000000000000000000000 , 168 'h 404000000000000000000000000000 , 168 'h 810000000000000000000000000102 , 168 'h 1000040000000000000000000000000 , 168 'h 3000000000000006000000000000000 , 168 'h 5000000000000000000000000000000 , 168 'h 8000000004000000000000000000000 , 168 'h 18000000000000000000000000030000 , 168 'h 30000000030000000000000000000000 , 168 'h 60000000000000000000000000000000 , 168 'h A0000014000000000000000000000000 , 168 'h 108000000000000000000000000000000 , 168 'h 240000000000000000000000000000000 , 168 'h 600000000000C00000000000000000000 , 168 'h 800000040000000000000000000000000 , 168 'h 1800000000000300000000000000000000 , 168 'h 2000000000000010000000000000000000 , 168 'h 4008000000000000000000000000000000 , 168 'h C000000000000000000000000000000600 , 168 'h 10000080000000000000000000000000000 , 168 'h 30600000000000000000000000000000000 , 168 'h 4A400000000000000000000000000000000 , 168 'h 80000004000000000000000000000000000 , 168 'h 180000003000000000000000000000000000 , 168 'h 200001000000000000000000000000000000 , 168 'h 600006000000000000000000000000000000 , 168 'h C00000000000000006000000000000000000 , 168 'h 1000000000000100000000000000000000000 , 168 'h 3000000000000006000000000000000000000 , 168 'h 6000000003000000000000000000000000000 , 168 'h 8000001000000000000000000000000000000 , 168 'h 1800000000000000000000000000C000000000 , 168 'h 20000000000001000000000000000000000000 , 168 'h 48000000000000000000000000000000000000 , 168 'h C0000000000000006000000000000000000000 , 168 'h 180000000000000000000000000000000000000 , 168 'h 280000000000000000000000000000005000000 , 168 'h 60000000C000000000000000000000000000000 , 168 'h C00000000000000000000000000018000000000 , 168 'h 1800000600000000000000000000000000000000 , 168 'h 3000000C00000000000000000000000000000000 , 168 'h 4000000080000000000000000000000000000000 , 168 'h C000300000000000000000000000000000000000 , 168 'h 10000400000000000000000000000000000000000 , 168 'h 30000000000000000000006000000000000000000 , 168 'h 600000000000000C0000000000000000000000000 , 168 'h C0060000000000000000000000000000000000000 , 168 'h 180000006000000000000000000000000000000000 , 168 'h 3000000000C0000000000000000000000000000000 , 168 'h 410000000000000000000000000000000000000000 , 168 'h A00140000000000000000000000000000000000000 } ;], policy: fit-else-expand, (origin: "localparam
...000000000};")
*** end of partially formatted partition list
[other error status]
hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_slow.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_register_file_latch.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_ex_block.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_register_file_fpga.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_core_tracing.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_register_file_ff.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_decoder.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_wb_stage.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_pkg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_load_store_unit.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_compressed_decoder.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_fetch_fifo.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_prefetch_buffer.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_multdiv_fast.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/formal/icache/formal_tb_frag.svh: hw/vendor/lowrisc_ibex/formal/icache/formal_tb_frag.svh:26:8: syntax error, rejected "(" (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/rtl/ibex_core.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_controller.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_tracer.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/examples/fpga/artya7/rtl/top_artya7.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/test/riscv_instr_gen_tb_top.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/examples/simple_system/rtl/ibex_simple_system.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/test/riscv_instr_test_lib.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/test/riscv_instr_test.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/test/riscv_instr_test_pkg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_icache.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/multi_harts/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/multi_harts/riscv_core_setting.sv:97:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/multi_harts/riscv_core_setting.sv:123:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/multi_harts/riscv_core_setting.sv:133:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/multi_harts/riscv_core_setting.sv:143:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/test/riscv_instr_base_test.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/test/riscv_instr_cov_test.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gc/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gc/riscv_core_setting.sv:97:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gc/riscv_core_setting.sv:149:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gc/riscv_core_setting.sv:165:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gc/riscv_core_setting.sv:182:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gcv/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gcv/riscv_core_setting.sv:96:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gcv/riscv_core_setting.sv:148:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gcv/riscv_core_setting.sv:164:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64gcv/riscv_core_setting.sv:181:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32i/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32i/riscv_core_setting.sv:94:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32i/riscv_core_setting.sv:120:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32i/riscv_core_setting.sv:130:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32i/riscv_core_setting.sv:141:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imc/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imc/riscv_core_setting.sv:97:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imc/riscv_core_setting.sv:123:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imc/riscv_core_setting.sv:133:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imc/riscv_core_setting.sv:143:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imc/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imc/riscv_core_setting.sv:96:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imc/riscv_core_setting.sv:122:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imc/riscv_core_setting.sv:132:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imc/riscv_core_setting.sv:142:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imcb/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imcb/riscv_core_setting.sv:97:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imcb/riscv_core_setting.sv:123:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imcb/riscv_core_setting.sv:133:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv64imcb/riscv_core_setting.sv:143:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/ml/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/ml/riscv_core_setting.sv:97:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/ml/riscv_core_setting.sv:123:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/ml/riscv_core_setting.sv:133:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/ml/riscv_core_setting.sv:143:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imcb/riscv_core_setting.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imcb/riscv_core_setting.sv:97:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imcb/riscv_core_setting.sv:123:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imcb/riscv_core_setting.sv:133:1: syntax error, rejected "`else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/target/rv32imcb/riscv_core_setting.sv:143:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/user_extension/user_extension.svh: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_page_table_exception_cfg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_signature_pkg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:736:5: syntax error, rejected "`VECTOR_INCLUDE" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1113:3: syntax error, rejected "typedef" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1116:5: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1117:5: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1118:5: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1119:5: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1125:5: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_pkg.sv:1127:3: syntax error, rejected "}" (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/formal/icache/formal_tb.sv: Already formatted, no change.
I verilog/preprocessor/verilog_preprocess.cc:203] Re-defining macro DV
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_defines.svh: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:458:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:462:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:466:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:467:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:469:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:471:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:472:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:474:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:485:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:489:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:493:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:497:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:498:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:499:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:500:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:505:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:506:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:507:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:508:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:513:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:514:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:515:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:516:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:522:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:523:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:527:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:528:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:532:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:533:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:537:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:538:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:542:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:543:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:547:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:548:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:553:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:554:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:555:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:559:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:560:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:561:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:565:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:566:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:570:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:571:19: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:598:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:602:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:609:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:617:16: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:621:16: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:626:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:630:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:632:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:633:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:634:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:637:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:638:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:639:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:641:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:642:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:643:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:660:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:664:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:668:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:672:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:676:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:680:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:684:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:688:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:698:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:702:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:706:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:710:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:739:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:740:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:741:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:742:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:749:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:750:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:751:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:752:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:915:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:916:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:918:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:923:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:925:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:930:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:932:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:937:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:939:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1105:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1109:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1114:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1119:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1124:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1129:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1229:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1254:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1258:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1262:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1288:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1292:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1296:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1300:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1304:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1305:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1309:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1311:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1316:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1317:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1321:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1323:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1332:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1336:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1337:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1339:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1340:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1345:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1347:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1350:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1351:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1356:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1357:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1359:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1360:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1365:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1367:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1370:7: syntax error, rejected "bins" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1371:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1377:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1381:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1385:16: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1389:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1393:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1397:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1402:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1406:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1410:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1414:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1415:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1416:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1417:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1422:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1423:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1424:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1425:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1430:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1431:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1432:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1433:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1438:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1442:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1446:18: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1470:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1480:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1491:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1494:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1500:20: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1502:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1505:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1511:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1524:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1528:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1538:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1540:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1560:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1564:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1591:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1597:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1598:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1599:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1600:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1601:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1602:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1603:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1608:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1613:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1618:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1620:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1623:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1624:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1625:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1629:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1630:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1631:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1632:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1633:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1634:7: syntax error, rejected "wildcard" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1635:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1640:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1641:3: syntax error, rejected "endgroup" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1645:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1646:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1647:11: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1648:3: syntax error, rejected "endgroup" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1652:22: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1653:3: syntax error, rejected "endgroup" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1676:12: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1678:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1683:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1686:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1690:17: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1692:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1696:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1698:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1702:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1703:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1704:13: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1705:3: syntax error, rejected "endgroup" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1708:15: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1709:15: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1711:5: syntax error, rejected "}" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1718:14: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1719:23: syntax error, rejected ";" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1721:23: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1724:5: syntax error, rejected "void" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1726:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1732:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1737:7: syntax error, rejected "void" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1738:7: syntax error, rejected "$display" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1740:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1744:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1751:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1752:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1753:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1754:18: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1755:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1756:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1757:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1758:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1759:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1760:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1761:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1762:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1763:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1764:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1765:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1766:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1767:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1768:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1769:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1770:18: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1771:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1772:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1773:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1774:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1775:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1776:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1777:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1778:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1779:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1780:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1781:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1782:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1783:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1784:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1785:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1786:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1790:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1793:18: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1794:18: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1795:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1796:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1797:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1798:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1804:21: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1805:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1808:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1810:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1816:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1817:9: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1819:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1825:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1826:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1827:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1828:14: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1829:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1830:14: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1831:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1835:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1836:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1837:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1838:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1839:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1843:14: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1844:13: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1845:13: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1846:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1847:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1848:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1849:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1850:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1851:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1852:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1853:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1854:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1855:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1856:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1857:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1861:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1862:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1863:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1864:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1865:21: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1866:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1867:21: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1868:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1869:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1870:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1871:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1872:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1873:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1874:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1875:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1876:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1877:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1878:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1879:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1880:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1881:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1882:14: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1883:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1885:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1887:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1891:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1892:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1893:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1894:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1895:18: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1896:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1897:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1901:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1902:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1903:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1904:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1905:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1906:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1907:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1908:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1909:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1910:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1911:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1912:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1913:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1914:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1915:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1916:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1917:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1918:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1919:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1920:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1921:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1922:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1923:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1924:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1925:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1926:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1930:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1931:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1932:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1933:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1934:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1935:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1936:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1937:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1938:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1939:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1940:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1941:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1942:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1943:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1944:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1945:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1946:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1947:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1948:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1949:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1950:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1951:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1952:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1953:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1957:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1958:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1959:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1960:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1964:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1965:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1966:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1967:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1968:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1969:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1970:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1971:20: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1975:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1976:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1977:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1978:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1979:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1980:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1981:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1982:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1983:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1984:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1985:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1986:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1987:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1988:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1989:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1990:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1991:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1992:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1993:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1994:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1995:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1996:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1997:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1998:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:1999:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2000:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2001:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2002:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2003:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2004:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2005:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2006:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2007:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2008:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2009:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2010:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2011:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2012:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2013:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2014:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2015:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2016:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2017:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2018:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2019:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2020:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2021:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2022:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2023:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2024:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2025:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2026:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2027:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2028:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2032:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2033:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2034:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2035:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2036:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2037:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2038:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2039:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2040:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2041:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2042:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2043:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2044:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2045:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2046:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2047:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2048:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2049:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2050:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2051:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2052:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2053:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2054:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2055:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2056:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2057:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2058:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2059:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2060:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2061:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2062:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2063:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2064:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2065:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2066:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2067:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2068:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2069:19: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2072:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2074:26: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2075:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2077:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2083:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2090:29: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2091:29: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2092:22: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2093:17: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2094:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2097:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2102:15: syntax error, rejected "+=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2103:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2105:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2110:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2113:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2385:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2390:24: syntax error, rejected "+=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2391:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2394:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2399:7: syntax error, rejected "case" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2403:13: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2405:13: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2408:13: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2410:13: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2415:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2418:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2421:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2431:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2435:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2437:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2439:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2444:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2446:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2448:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2454:16: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2455:5: syntax error, rejected "do" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2457:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2460:9: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2468:13: syntax error, rejected "continue" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2469:11: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2473:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2476:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2478:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2481:15: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2482:22: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2483:24: syntax error, rejected "=" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2485:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_cover_group.sv:2488:5: syntax error, rejected "if" (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_amo_instr_lib.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_pseudo_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_vector_cfg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_directed_instr_lib.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_pmp_cfg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/dv_defines.svh: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_load_store_instr_lib.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_sequence.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_reg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_data_page_gen.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_callstack_gen.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_page_table_list.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_stream.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64m_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32c_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/custom/riscv_custom_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/custom/rv32x_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/custom/riscv_custom_instr_enum.sv: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/custom/riscv_custom_instr_enum.sv:3:1: syntax error (unexpected EOF) (https://github.com/google/verible).

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/custom/rv64x_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32dc_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_privil_reg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64a_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64i_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32i_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_floating_point_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32fc_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh: hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:28:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:29:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:30:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:31:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:32:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:33:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:34:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:35:3: syntax error, rejected "rand" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:67:11: syntax error, rejected "function" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:82:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:84:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:87:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:91:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:98:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:101:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:104:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:108:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:110:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:112:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:116:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:118:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:120:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:122:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:124:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:128:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:130:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:132:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:136:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:138:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:140:5: syntax error, rejected "else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:142:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:145:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:147:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:149:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:151:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:153:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:157:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:159:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:163:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:165:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:168:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:174:7: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:176:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:179:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:182:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:188:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:190:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:192:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:194:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:198:5: syntax error, rejected "case" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:200:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:201:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:202:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:203:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:204:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:205:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:206:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:207:14: syntax error, rejected ":" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:210:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:218:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:220:5: syntax error, rejected "else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:222:5: syntax error, rejected "else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:224:5: syntax error, rejected "else" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:226:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:230:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:233:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:235:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:238:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:240:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:245:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:247:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:252:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:254:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:256:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:265:5: syntax error, rejected "case" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:270:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:277:18: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:278:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:281:11: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:283:11: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:285:11: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:290:18: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:291:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:300:18: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:301:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:307:18: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:308:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:320:11: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:322:11: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:325:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:330:11: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:333:11: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:344:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:350:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:353:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:358:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:361:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:368:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:375:16: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:376:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:383:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:388:16: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:389:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:396:16: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:397:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:403:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:407:9: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:412:7: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:418:12: syntax error, rejected "(" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:421:3: syntax error, rejected "endfunction" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:425:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:431:5: syntax error, rejected "if" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:433:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:435:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr_cov.svh:438:5: syntax error, rejected "end" (https://github.com/google/verible).
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv128c_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32m_instr.sv: Already formatted, no change.

hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64f_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64c_instr.svhw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32a_instr.sv: Already formatted, no change.
: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64d_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32b_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv64b_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32v_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_compressed_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_amo_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32d_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/rv32f_instr.sv: Already formatted, no change.
hw/vendor/pulp_riscv_dbg/tb/mm_ram.sv: *** Some token partitions failed to complete within the search limit:
>>[assert property ( @ ( posedge clk_i ) disable iff ( ! rst_ni ) ( data_req_i && data_gnt_o && data_we_i |-> ( data_addr_i >= STDOUT_BASE && data_addr_i < STDOUT_BASE + STDOUT_LEN ) || ( data_addr_i >= DEBUG_BASE && data_addr_i < DEBUG_BASE + DEBUG_LEN ) || ( data_addr_i >= SRAM_BASE && data_addr_i < SRAM_BASE + SRAM_LEN ) || ( data_addr_i >= 0 && data_addr_i < SRAM_LEN ) ) )], policy: fit-else-expand, (origin: "assert
    ...SRAM_LEN)))")
*** end of partially formatted partition list
[other error status]
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_vector_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_loop_instr.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_debug_rom_gen.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_privileged_common_seq.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_page_table_entry.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_page_table.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_instr.sv: Already formatted, no change.
hw/top_earlgrey/rtl/top_earlgrey_nexysvideo.sv: Already formatted, no change.
hw/top_earlgrey/rtl/clkgen_xil7series.sv: Already formatted, no change.
hw/top_earlgrey/rtl/top_earlgrey_asic.sv: Already formatted, no change.
hw/top_earlgrey/rtl/top_earlgrey_cw305.sv: Already formatted, no change.
hw/top_earlgrey/rtl/top_pkg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_illegal_instr.sv: Already formatted, no change.
hw/top_earlgrey/rtl/top_earlgrey_verilator.sv: Already formatted, no change.
hw/top_earlgrey/rtl/autogen/top_earlgrey_pkg.sv: Already formatted, no change.
hw/top_earlgrey/rtl/top_earlgrey_artys7.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/rtl/ibex_alu.sv: Formatted output is lexically different from the input.    Please file a bug.  Details:
Mismatched token enums.  got: (')') (#41: ")") vs. (MacroCallCloseToEndLine) (#746: ")")
First mismatched token [4059]: (')') (#41: ")") vs. (MacroCallCloseToEndLine) (#746: ")")
; problematic formatter output is
// Copyright lowRISC contributors.
// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

/**
 * Arithmetic logic unit
 */
module ibex_alu #(
    parameter ibex_pkg::rv32b_e RV32B = ibex_pkg::RV32BNone
) (
    input ibex_pkg::alu_op_e        operator_i,
    input logic              [31:0] operand_a_i,
    input logic              [31:0] operand_b_i,

    input logic instr_first_cycle_i,

    input logic [32:0] multdiv_operand_a_i,
    input logic [32:0] multdiv_operand_b_i,

    input logic multdiv_sel_i,

    input  logic [31:0] imd_val_q_i [2],
    output logic [31:0] imd_val_d_o [2],
    output logic [ 1:0] imd_val_we_o,

    output logic [31:0] adder_result_o,
    output logic [33:0] adder_result_ext_o,

    output logic [31:0] result_o,
    output logic        comparison_result_o,
    output logic        is_equal_result_o
);
  import ibex_pkg::*;

  logic [31:0] operand_a_rev;
  logic [32:0] operand_b_neg;

  // bit reverse operand_a for left shifts and bit counting
  for (genvar k = 0; k < 32; k++) begin : gen_rev_operand_a
    assign operand_a_rev[k] = operand_a_i[31 - k];
  end

  ///////////
  // Adder //
  ///////////

  logic adder_op_b_negate;
  logic [32:0] adder_in_a, adder_in_b;
  logic [31:0] adder_result;

  always_comb begin
    adder_op_b_negate = 1'b0;
    unique case (operator_i)
      // Adder OPs
      ALU_SUB,

      // Comparator OPs
      ALU_EQ, ALU_NE, ALU_GE, ALU_GEU, ALU_LT, ALU_LTU, ALU_SLT, ALU_SLTU,

      // MinMax OPs (RV32B Ops)
      ALU_MIN, ALU_MINU, ALU_MAX, ALU_MAXU:
      adder_op_b_negate = 1'b1;

      default: ;
    endcase
  end

  // prepare operand a
  assign adder_in_a = multdiv_sel_i ? multdiv_operand_a_i : {operand_a_i, 1'b1};

  // prepare operand b
  assign operand_b_neg = {operand_b_i, 1'b0} ^ {33{1'b1}};
  always_comb begin
    unique case (1'b1)
      multdiv_sel_i: adder_in_b = multdiv_operand_b_i;
      adder_op_b_negate: adder_in_b = operand_b_neg;
      default: adder_in_b = {operand_b_i, 1'b0};
    endcase
  end

  // actual adder
  assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);

  assign adder_result = adder_result_ext_o[32:1];

  assign adder_result_o = adder_result;

  ////////////////
  // Comparison //
  ////////////////

  logic is_equal;
  logic is_greater_equal;  // handles both signed and unsigned forms
  logic cmp_signed;

  always_comb begin
    unique case (operator_i)
      ALU_GE, ALU_LT, ALU_SLT,
      // RV32B only
      ALU_MIN, ALU_MAX:
      cmp_signed = 1'b1;

      default: cmp_signed = 1'b0;
    endcase
  end

  assign is_equal = (adder_result == 32'b0);
  assign is_equal_result_o = is_equal;

  // Is greater equal
  always_comb begin
    if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin
      is_greater_equal = (adder_result[31] == 1'b0);
    end else begin
      is_greater_equal = operand_a_i[31] ^ (cmp_signed);
    end
  end

  // GTE unsigned:
  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
  // (a[31] == 1 && b[31] == 0) => 1
  // (a[31] == 0 && b[31] == 1) => 0

  // GTE signed:
  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0
  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0
  // (a[31] == 1 && b[31] == 0) => 0
  // (a[31] == 0 && b[31] == 1) => 1

  // generate comparison result
  logic cmp_result;

  always_comb begin
    unique case (operator_i)
      ALU_EQ: cmp_result = is_equal;
      ALU_NE: cmp_result = ~is_equal;
      ALU_GE, ALU_GEU, ALU_MAX, ALU_MAXU: cmp_result = is_greater_equal;  // RV32B only
      ALU_LT, ALU_LTU, ALU_MIN, ALU_MINU,  //RV32B only
      ALU_SLT, ALU_SLTU:
      cmp_result = ~is_greater_equal;

      default: cmp_result = is_equal;
    endcase
  end

  assign comparison_result_o = cmp_result;

  ///////////
  // Shift //
  ///////////

  // The shifter structure consists of a 33-bit shifter: 32-bit operand + 1 bit extension for
  // arithmetic shifts and one-shift support.
  // Rotations and funnel shifts are implemented as multi-cycle instructions.
  // The shifter is also used for single-bit instructions and bit-field place as detailed below.
  //
  // Standard Shifts
  // ===============
  // For standard shift instructions, the direction of the shift is to the right by default. For
  // left shifts, the signal shift_left signal is set. If so, the operand is initially reversed,
  // shifted to the right by the specified amount and shifted back again. For arithmetic- and
  // one-shifts the 33rd bit of the shifter operand can is set accordingly.
  //
  // Multicycle Shifts
  // =================
  //
  // Rotation
  // --------
  // For rotations, the operand signals operand_a_i and operand_b_i are kept constant to rs1 and
  // rs2 respectively.
  //
  // Rotation pseudocode:
  //   shift_amt = rs2 & 31;
  //   multicycle_result = (rs1 >> shift_amt) | (rs1 << (32 - shift_amt));
  //                       ^-- cycle 0 -----^ ^-- cycle 1 --------------^
  //
  // Funnel Shifts
  // -------------
  // For funnel shifs, operand_a_i is tied to rs1 in the first cycle and rs3 in the
  // second cycle. operand_b_i is always tied to rs2. The order of applying the shift amount or
  // its complement is determined by bit [5] of shift_amt.
  //
  // Funnel shift Pseudocode: (fsl)
  //  shift_amt = rs2 & 63;
  //  shift_amt_compl = 32 - shift_amt[4:0]
  //  if (shift_amt >=33):
  //     multicycle_result = (rs1 >> shift_amt_cmpl[4:0]) | (rs3 << shift_amt[4:0]);
  //                         ^-- cycle 0 ---------------^ ^-- cycle 1 ------------^
  //  else if (shift_amt <= 31 && shift_amt > 0):
  //     multicycle_result = (rs1 << shift_amt[4:0]) | (rs3 >> shift_amt_compl[4:0]);
  //                         ^-- cycle 0 ----------^ ^-- cycle 1 -------------------^
  //  For shift_amt == 0, 32, both shift_amt[4:0] and shift_amt_compl[4:0] == '0.
  //  these cases need to be handled separately outside the shifting structure:
  //  else if (shift_amt == 32):
  //     multicycle_result = rs3
  //  else if (shift_amt == 0):
  //     multicycle_result = rs1.
  //
  // Single-Bit Instructions
  // =======================
  // Single bit instructions operate on bit operand_b_i[4:0] of operand_a_i.

  // The operations sbset, sbclr and sbinv are implemented by generation of a bit-mask using the
  // shifter structure. This is done by left-shifting the operand 32'h1 by the required amount.
  // The signal shift_sbmode multiplexes the shifter input and sets the signal shift_left.
  // Further processing is taken care of by a separate structure.
  //
  // For sbext, the bit defined by operand_b_i[4:0] is to be returned. This is done by simply
  // shifting operand_a_i to the right by the required amount and returning bit [0] of the result.
  //
  // Bit-Field Place
  // ===============
  // The shifter structure is shared to compute bfp_mask << bfp_off.

  logic shift_left;
  logic shift_ones;
  logic shift_arith;
  logic shift_funnel;
  logic shift_sbmode;
  logic [5:0] shift_amt;
  logic [5:0] shift_amt_compl;  // complementary shift amount (32 - shift_amt)

  logic [31:0] shift_result;
  logic [32:0] shift_result_ext;
  logic [31:0] shift_result_rev;

  // zbf
  logic bfp_op;
  logic [4:0] bfp_len;
  logic [4:0] bfp_off;
  logic [31:0] bfp_mask;
  logic [31:0] bfp_mask_rev;
  logic [31:0] bfp_result;

  // bfp: shares the shifter structure to compute bfp_mask << bfp_off
  assign bfp_op = (RV32B != RV32BNone) ? (operator_i == ALU_BFP) : 1'b0;
  assign bfp_len = {~(|operand_b_i[27:24]), operand_b_i[27:24]};  // len = 0 encodes for len = 16
  assign bfp_off = operand_b_i[20:16];
  assign bfp_mask = (RV32B != RV32BNone) ? ~(32'hffff_ffff << bfp_len) : '0;
  for (genvar i = 0; i < 32; i++) begin : gen_rev_bfp_mask
    assign bfp_mask_rev[i] = bfp_mask[31 - i];
  end

  assign bfp_result = (RV32B != RV32BNone
      ) ? (~shift_result & operand_a_i) | ((operand_b_i & bfp_mask) << bfp_off) : '0;

  // bit shift_amt[5]: word swap bit: only considered for FSL/FSR.
  // if set, reverse operations in first and second cycle.
  assign shift_amt[5] = operand_b_i[5] & shift_funnel;
  assign shift_amt_compl = 32 - operand_b_i[4:0];

  always_comb begin
    if (bfp_op) begin
      shift_amt[4:0] = bfp_off;  // length field of bfp control word
    end else begin
      shift_amt[4:0] = instr_first_cycle_i
          ? (operand_b_i[5] && shift_funnel ? shift_amt_compl[4:0] : operand_b_i[4:0]) : (
          operand_b_i[5] && shift_funnel ? operand_b_i[4:0] : shift_amt_compl[4:0]);
    end
  end

  // single-bit mode: shift
  assign shift_sbmode = (RV32B != RV32BNone
      ) ? (operator_i == ALU_SBSET) | (operator_i == ALU_SBCLR) | (operator_i == ALU_SBINV) : 1'b0;

  // left shift if this is:
  // * a standard left shift (slo, sll)
  // * a rol in the first cycle
  // * a ror in the second cycle
  // * fsl: without word-swap bit: first cycle, else: second cycle
  // * fsr: without word-swap bit: second cycle, else: first cycle
  // * a single-bit instruction: sbclr, sbset, sbinv (excluding sbext)
  // * bfp: bfp_mask << bfp_off
  always_comb begin
    unique case (operator_i)
      ALU_SLL: shift_left = 1'b1;
      ALU_SLO, ALU_BFP: shift_left = (RV32B != RV32BNone) ? 1'b1 : 1'b0;
      ALU_ROL: shift_left = (RV32B != RV32BNone) ? instr_first_cycle_i : 0;
      ALU_ROR: shift_left = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 0;
      ALU_FSL:
      shift_left =
          (RV32B != RV32BNone) ? (shift_amt[5] ? ~instr_first_cycle_i : instr_first_cycle_i) : 1'b0;
      ALU_FSR:
      shift_left =
          (RV32B != RV32BNone) ? (shift_amt[5] ? instr_first_cycle_i : ~instr_first_cycle_i) : 1'b0;
      default: shift_left = 1'b0;
    endcase
    if (shift_sbmode) begin
      shift_left = 1'b1;
    end
  end

  assign shift_arith = (operator_i == ALU_SRA);
  assign
      shift_ones = (RV32B != RV32BNone) ? (operator_i == ALU_SLO) | (operator_i == ALU_SRO) : 1'b0;
  assign shift_funnel = (RV32B != RV32BNone) ? (operator_i == ALU_FSL) | (operator_i == ALU_FSR) :
      1'b0;

  // shifter structure.
  always_comb begin
    // select shifter input
    // for bfp, sbmode and shift_left the corresponding bit-reversed input is chosen.
    if (RV32B == RV32BNone) begin
      shift_result = shift_left ? operand_a_rev : operand_a_i;
    end else begin
      unique case (1'b1)
        bfp_op: shift_result = bfp_mask_rev;
        shift_sbmode: shift_result = 32'h8000_0000;
        default: shift_result = shift_left ? operand_a_rev : operand_a_i;
      endcase
    end

    shift_result_ext = $signed({
      shift_ones | (shift_arith & shift_result[31]), shift_result
    }) >>> shift_amt[4:0];

    shift_result = shift_result_ext[31:0];

    for (int unsigned i = 0; i < 32; i++) begin
      shift_result_rev[i] = shift_result[31 - i];
    end

    shift_result = shift_left ? shift_result_rev : shift_result;

  end

  ///////////////////
  // Bitwise Logic //
  ///////////////////

  logic bwlogic_or;
  logic bwlogic_and;
  logic [31:0] bwlogic_operand_b;
  logic [31:0] bwlogic_or_result;
  logic [31:0] bwlogic_and_result;
  logic [31:0] bwlogic_xor_result;
  logic [31:0] bwlogic_result;

  logic bwlogic_op_b_negate;

  always_comb begin
    unique case (operator_i)
      // Logic-with-negate OPs (RV32B Ops)
      ALU_XNOR, ALU_ORN, ALU_ANDN:
      bwlogic_op_b_negate = (RV32B != RV32BNone) ? 1'b1 : 1'b0;
      ALU_CMIX: bwlogic_op_b_negate = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 1'b0;
      default: bwlogic_op_b_negate = 1'b0;
    endcase
  end

  assign bwlogic_operand_b = bwlogic_op_b_negate ? operand_b_neg[32:1] : operand_b_i;

  assign bwlogic_or_result = operand_a_i | bwlogic_operand_b;
  assign bwlogic_and_result = operand_a_i & bwlogic_operand_b;
  assign bwlogic_xor_result = operand_a_i ^ bwlogic_operand_b;

  assign bwlogic_or = (operator_i == ALU_OR) | (operator_i == ALU_ORN);
  assign bwlogic_and = (operator_i == ALU_AND) | (operator_i == ALU_ANDN);

  always_comb begin
    unique case (1'b1)
      bwlogic_or: bwlogic_result = bwlogic_or_result;
      bwlogic_and: bwlogic_result = bwlogic_and_result;
      default: bwlogic_result = bwlogic_xor_result;
    endcase
  end

  logic [5:0] bitcnt_result;
  logic [31:0] minmax_result;
  logic [31:0] pack_result;
  logic [31:0] sext_result;
  logic [31:0] singlebit_result;
  logic [31:0] rev_result;
  logic [31:0] shuffle_result;
  logic [31:0] butterfly_result;
  logic [31:0] invbutterfly_result;
  logic [31:0] clmul_result;
  logic [31:0] multicycle_result;

  if (RV32B != RV32BNone) begin : g_alu_rvb

    /////////////////
    // Bitcounting //
    /////////////////

    // The bit-counter structure computes the number of set bits in its operand. Partial results
    // (from left to right) are needed to compute the control masks for computation of bext/bdep
    // by the butterfly network, if implemented.
    // For pcnt, clz and ctz, only the end result is used.

    logic zbe_op;
    logic bitcnt_ctz;
    logic bitcnt_clz;
    logic bitcnt_cz;
    logic [31:0] bitcnt_bits;
    logic [31:0] bitcnt_mask_op;
    logic [31:0] bitcnt_bit_mask;
    logic [5:0] bitcnt_partial[32];
    logic [31:0] bitcnt_partial_lsb_d;
    logic [31:0] bitcnt_partial_msb_d;


    assign bitcnt_ctz = operator_i == ALU_CTZ;
    assign bitcnt_clz = operator_i == ALU_CLZ;
    assign bitcnt_cz = bitcnt_ctz | bitcnt_clz;
    assign bitcnt_result = bitcnt_partial[31];

    // Bit-mask generation for clz and ctz:
    // The bit mask is generated by spreading the lowest-order set bit in the operand to all
    // higher order bits. The resulting mask is inverted to cover the lowest order zeros. In order
    // to create the bit mask for leading zeros, the input operand needs to be reversed.
    assign bitcnt_mask_op = bitcnt_clz ? operand_a_rev : operand_a_i;

    always_comb begin
      bitcnt_bit_mask = bitcnt_mask_op;
      bitcnt_bit_mask |= bitcnt_bit_mask << 1;
      bitcnt_bit_mask |= bitcnt_bit_mask << 2;
      bitcnt_bit_mask |= bitcnt_bit_mask << 4;
      bitcnt_bit_mask |= bitcnt_bit_mask << 8;
      bitcnt_bit_mask |= bitcnt_bit_mask << 16;
      bitcnt_bit_mask = ~bitcnt_bit_mask;
    end

    assign zbe_op = (operator_i == ALU_BEXT) | (operator_i == ALU_BDEP);

    always_comb begin
      case (1'b1)
        zbe_op: bitcnt_bits = operand_b_i;
        bitcnt_cz: bitcnt_bits = bitcnt_bit_mask & ~bitcnt_mask_op;  // clz / ctz
        default: bitcnt_bits = operand_a_i;  // pcnt
      endcase
    end

    // The parallel prefix counter is of the structure of a Brent-Kung Adder. In the first
    // log2(width) stages, the sum of the n preceding bit lines is computed for the bit lines at
    // positions 2**n-1 (power-of-two positions) where n denotes the current stage.
    // In stage n=log2(width), the count for position width-1 (the MSB) is finished.
    // For the intermediate values, an inverse adder tree then computes the bit counts for the bit
    // lines at positions
    // m = 2**(n-1) + i*2**(n-2), where i = [1 ... width / 2**(n-1)-1] and n = [log2(width) ... 2].
    // Thus, at every subsequent stage the result of two previously unconnected sub-trees is
    // summed, starting at the node summing bits [width/2-1 : 0] and [3*width/4-1: width/2]
    // and moving to iteratively sum up all the sub-trees.
    // The inverse adder tree thus features log2(width) - 1 stages the first of these stages is a
    // single addition at position 3*width/4 - 1. It does not interfere with the last
    // stage of the primary adder tree. These stages can thus be folded together, resulting in a
    // total of 2*log2(width)-2 stages.
    // For more details refer to R. Brent, H. T. Kung, "A Regular Layout for Parallel Adders",
    // (1982).
    // For a bitline at position p, only bits
    // bitcnt_partial[max(i, such that p % log2(i) == 0)-1 : 0] are needed for generation of the
    // butterfly network control signals. The adders in the intermediate value adder tree thus need
    // not be full 5-bit adders. We leave the optimization to the synthesis tools.
    //
    // Consider the following 8-bit example for illustraton.
    //
    // let bitcnt_bits = 8'babcdefgh.
    //
    //                   a  b  c  d  e  f  g  h
    //                   | /:  | /:  | /:  | /:
    //                   |/ :  |/ :  |/ :  |/ :
    // stage 1:          +  :  +  :  +  :  +  :
    //                   |  : /:  :  |  : /:  :
    //                   |,--+ :  :  |,--+ :  :
    // stage 2:          +  :  :  :  +  :  :  :
    //                   |  :  |  : /:  :  :  :
    //                   |,-----,--+ :  :  :  : ^-primary adder tree
    // stage 3:          +  :  +  :  :  :  :  : -------------------------
    //                   :  | /| /| /| /| /|  : ,-intermediate adder tree
    //                   :  |/ |/ |/ |/ |/ :  :
    // stage 4           :  +  +  +  +  +  :  :
    //                   :  :  :  :  :  :  :  :
    // bitcnt_partial[i] 7  6  5  4  3  2  1  0

    always_comb begin
      bitcnt_partial = '{default: '0};
      // stage 1
      for (int unsigned i = 1; i < 32; i += 2) begin
        bitcnt_partial[i] = {5'h0, bitcnt_bits[i]} + {5'h0, bitcnt_bits[i - 1]};
      end
      // stage 2
      for (int unsigned i = 3; i < 32; i += 4) begin
        bitcnt_partial[i] = bitcnt_partial[i - 2] + bitcnt_partial[i];
      end
      // stage 3
      for (int unsigned i = 7; i < 32; i += 8) begin
        bitcnt_partial[i] = bitcnt_partial[i - 4] + bitcnt_partial[i];
      end
      // stage 4
      for (int unsigned i = 15; i < 32; i += 16) begin
        bitcnt_partial[i] = bitcnt_partial[i - 8] + bitcnt_partial[i];
      end
      // stage 5
      bitcnt_partial[31] = bitcnt_partial[15] + bitcnt_partial[31];
      // ^- primary adder tree
      // -------------------------------
      // ,-intermediate value adder tree
      bitcnt_partial[23] = bitcnt_partial[15] + bitcnt_partial[23];

      // stage 6
      for (int unsigned i = 11; i < 32; i += 8) begin
        bitcnt_partial[i] = bitcnt_partial[i - 4] + bitcnt_partial[i];
      end

      // stage 7
      for (int unsigned i = 5; i < 32; i += 4) begin
        bitcnt_partial[i] = bitcnt_partial[i - 2] + bitcnt_partial[i];
      end
      // stage 8
      bitcnt_partial[0] = {5'h0, bitcnt_bits[0]};
      for (int unsigned i = 2; i < 32; i += 2) begin
        bitcnt_partial[i] = bitcnt_partial[i - 1] + {5'h0, bitcnt_bits[i]};
      end
    end

    ///////////////
    // Min / Max //
    ///////////////

    assign minmax_result = cmp_result ? operand_a_i : operand_b_i;

    //////////
    // Pack //
    //////////

    logic packu;
    logic packh;
    assign packu = operator_i == ALU_PACKU;
    assign packh = operator_i == ALU_PACKH;

    always_comb begin
      unique case (1'b1)
        packu: pack_result = {operand_b_i[31:16], operand_a_i[31:16]};
        packh: pack_result = {16'h0, operand_b_i[7:0], operand_a_i[7:0]};
        default: pack_result = {operand_b_i[15:0], operand_a_i[15:0]};
      endcase
    end

    //////////
    // Sext //
    //////////

    assign sext_result = (operator_i == ALU_SEXTB) ? {
      {24{operand_a_i[7]}}, operand_a_i[7:0]
    } : {
      {16{operand_a_i[15]}}, operand_a_i[15:0]
    };

    /////////////////////////////
    // Single-bit Instructions //
    /////////////////////////////

    always_comb begin
      unique case (operator_i)
        ALU_SBSET: singlebit_result = operand_a_i | shift_result;
        ALU_SBCLR: singlebit_result = operand_a_i & ~shift_result;
        ALU_SBINV: singlebit_result = operand_a_i ^ shift_result;
        default: singlebit_result = {31'h0, shift_result[0]};  // ALU_SBEXT
      endcase
    end

    ////////////////////////////////////
    // General Reverse and Or-combine //
    ////////////////////////////////////

    // Only a subset of the General reverse and or-combine instructions are implemented in the
    // balanced version of the B extension. Currently rev, rev8 and orc.b are supported in the
    // base extension.

    logic [4:0] zbp_shift_amt;
    logic gorc_op;

    assign gorc_op = (operator_i == ALU_GORC);
    assign zbp_shift_amt[2:0] = (RV32B == RV32BFull) ? shift_amt[2:0] : {3{&shift_amt[2:0]}};
    assign zbp_shift_amt[4:3] = (RV32B == RV32BFull) ? shift_amt[4:3] : {2{&shift_amt[4:3]}};

    always_comb begin
      rev_result = operand_a_i;

      if (zbp_shift_amt[0]) begin
        rev_result = (gorc_op ? rev_result : 32'h0) | ((rev_result & 32'h5555_5555) << 1
            ) | ((rev_result & 32'haaaa_aaaa) >> 1);
      end

      if (zbp_shift_amt[1]) begin
        rev_result = (gorc_op ? rev_result : 32'h0) | ((rev_result & 32'h3333_3333) << 2
            ) | ((rev_result & 32'hcccc_cccc) >> 2);
      end

      if (zbp_shift_amt[2]) begin
        rev_result = (gorc_op ? rev_result : 32'h0) | ((rev_result & 32'h0f0f_0f0f) << 4
            ) | ((rev_result & 32'hf0f0_f0f0) >> 4);
      end

      if (zbp_shift_amt[3]) begin
        rev_result = (gorc_op & (RV32B == RV32BFull) ? rev_result : 32'h0
            ) | ((rev_result & 32'h00ff_00ff) << 8) | ((rev_result & 32'hff00_ff00) >> 8);
      end

      if (zbp_shift_amt[4]) begin
        rev_result = (gorc_op & (RV32B == RV32BFull) ? rev_result : 32'h0
            ) | ((rev_result & 32'h0000_ffff) << 16) | ((rev_result & 32'hffff_0000) >> 16);
      end
    end

    logic crc_hmode;
    logic crc_bmode;
    logic [31:0] clmul_result_rev;

    if (RV32B == RV32BFull) begin : gen_alu_rvb_full

      /////////////////////////
      // Shuffle / Unshuffle //
      /////////////////////////

      localparam logic [31:0]
          SHUFFLE_MASK_L[4] = '{32'h00ff_0000, 32'h0f00_0f00, 32'h3030_3030, 32'h4444_4444};
      localparam logic [31:0]
          SHUFFLE_MASK_R[4] = '{32'h0000_ff00, 32'h00f0_00f0, 32'h0c0c_0c0c, 32'h2222_2222};

      localparam logic [31:0]
          FLIP_MASK_L[4] = '{32'h2200_1100, 32'h0044_0000, 32'h4411_0000, 32'h1100_0000};
      localparam logic [31:0]
          FLIP_MASK_R[4] = '{32'h0088_0044, 32'h0000_2200, 32'h0000_8822, 32'h0000_0088};

      logic [31:0] SHUFFLE_MASK_NOT[4];
      for (genvar i = 0; i < 4; i++) begin : gen_shuffle_mask_not
        assign SHUFFLE_MASK_NOT[i] = ~(SHUFFLE_MASK_L[i] | SHUFFLE_MASK_R[i]);
      end

      logic shuffle_flip;
      assign shuffle_flip = operator_i == ALU_UNSHFL;

      logic [3:0] shuffle_mode;

      always_comb begin
        shuffle_result = operand_a_i;

        if (shuffle_flip) begin
          shuffle_mode[3] = shift_amt[0];
          shuffle_mode[2] = shift_amt[1];
          shuffle_mode[1] = shift_amt[2];
          shuffle_mode[0] = shift_amt[3];
        end else begin
          shuffle_mode = shift_amt[3:0];
        end

        if (shuffle_flip) begin
          shuffle_result = (shuffle_result & 32'h8822_4411) | ((shuffle_result << 6) & FLIP_MASK_L
                                                               [0]) | (
              (shuffle_result >> 6) & FLIP_MASK_R[0])
              | ((shuffle_result << 9) & FLIP_MASK_L[1]) | ((shuffle_result >> 9) & FLIP_MASK_R[1])
              | ((shuffle_result << 15) & FLIP_MASK_L[2]) | ((shuffle_result >> 15) & FLIP_MASK_R[2]
              ) | ((shuffle_result << 21) & FLIP_MASK_L[3]) | ((shuffle_result >> 21) & FLIP_MASK_R[
                                                               3]);
        end

        if (shuffle_mode[3]) begin
          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[0]
              ) | (((shuffle_result << 8) & SHUFFLE_MASK_L[0]
                   ) | ((shuffle_result >> 8) & SHUFFLE_MASK_R[0]));
        end
        if (shuffle_mode[2]) begin
          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[1]
              ) | (((shuffle_result << 4) & SHUFFLE_MASK_L[1]
                   ) | ((shuffle_result >> 4) & SHUFFLE_MASK_R[1]));
        end
        if (shuffle_mode[1]) begin
          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[2]
              ) | (((shuffle_result << 2) & SHUFFLE_MASK_L[2]
                   ) | ((shuffle_result >> 2) & SHUFFLE_MASK_R[2]));
        end
        if (shuffle_mode[0]) begin
          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[3]
              ) | (((shuffle_result << 1) & SHUFFLE_MASK_L[3]
                   ) | ((shuffle_result >> 1) & SHUFFLE_MASK_R[3]));
        end

        if (shuffle_flip) begin
          shuffle_result = (shuffle_result & 32'h8822_4411) | ((shuffle_result << 6) & FLIP_MASK_L
                                                               [0]) | (
              (shuffle_result >> 6) & FLIP_MASK_R[0])
              | ((shuffle_result << 9) & FLIP_MASK_L[1]) | ((shuffle_result >> 9) & FLIP_MASK_R[1])
              | ((shuffle_result << 15) & FLIP_MASK_L[2]) | ((shuffle_result >> 15) & FLIP_MASK_R[2]
              ) | ((shuffle_result << 21) & FLIP_MASK_L[3]) | ((shuffle_result >> 21) & FLIP_MASK_R[
                                                               3]);
        end
      end

      ///////////////
      // Butterfly //
      ///////////////

      // The butterfly / inverse butterfly network executing bext/bdep (zbe) instructions.
      // For bdep, the control bits mask of a local left region is generated by
      // the inverse of a n-bit left rotate and complement upon wrap (LROTC) operation by the number
      // of ones in the deposit bitmask to the right of the segment. n hereby denotes the width
      // of the according segment. The bitmask for a pertaining local right region is equal to the
      // corresponding local left region. Bext uses an analogue inverse process.
      // Consider the following 8-bit example.  For details, see Hilewitz et al. "Fast Bit Gather,
      // Bit Scatter and Bit Permuation Instructions for Commodity Microprocessors", (2008).
      //
      // The bext/bdep instructions are completed in 2 cycles. In the first cycle, the control
      // bitmask is prepared by executing the parallel prefix bit count. In the second cycle,
      // the bit swapping is executed according to the control masks.

      // 8-bit example:  (Hilewitz et al.)
      // Consider the instruction bdep operand_a_i deposit_mask
      // Let operand_a_i = 8'babcd_efgh
      //    deposit_mask = 8'b1010_1101
      //
      // control bitmask for stage 1:
      //  - number of ones in the right half of the deposit bitmask: 3
      //  - width of the segment: 4
      //  - control bitmask = ~LROTC(4'b0, 3)[3:0] = 4'b1000
      //
      // control bitmask:   c3 c2  c1 c0  c3 c2  c1 c0
      //                    1  0   0  0   1  0   0  0
      //                    <- L ----->   <- R ----->
      // operand_a_i        a  b   c  d   e  f   g  h
      //                    :\ |   |  |  /:  |   |  |
      //                    : +|---|--|-+ :  |   |  |
      //                    :/ |   |  |  \:  |   |  |
      // stage 1            e  b   c  d   a  f   g  h
      //                    <L->   <R->   <L->   <R->
      // control bitmask:   c3 c2  c3 c2  c1 c0  c1 c0
      //                    1  1   1  1   1  0   1  0
      //                    :\ :\ /: /:   :\ |  /:  |
      //                    : +:-+-:+ :   : +|-+ :  |
      //                    :/ :/ \: \:   :/ |  \:  |
      // stage 2            c  d   e  b   g  f   a  h
      //                    L  R   L  R   L  R   L  R
      // control bitmask:   c3 c3  c2 c2  c1 c1  c0 c0
      //                    1  1   0  0   1  1   0  0
      //                    :\/:   |  |   :\/:   |  |
      //                    :  :   |  |   :  :   |  |
      //                    :/\:   |  |   :/\:   |  |
      // stage 3            d  c   e  b   f  g   a  h
      // & deposit bitmask: 1  0   1  0   1  1   0  1
      // result:            d  0   e  0   f  g   0  h

      logic [5:0] bitcnt_partial_q[32];

      // first cycle
      // Store partial bitcnts
      for (genvar i = 0; i < 32; i++) begin : gen_bitcnt_reg_in_lsb
        assign bitcnt_partial_lsb_d[i] = bitcnt_partial[i][0];
      end

      for (genvar i = 0; i < 16; i++) begin : gen_bitcnt_reg_in_b1
        assign bitcnt_partial_msb_d[i] = bitcnt_partial[2 * i + 1][1];
      end

      for (genvar i = 0; i < 8; i++) begin : gen_bitcnt_reg_in_b2
        assign bitcnt_partial_msb_d[16 + i] = bitcnt_partial[4 * i + 3][2];
      end

      for (genvar i = 0; i < 4; i++) begin : gen_bitcnt_reg_in_b3
        assign bitcnt_partial_msb_d[24 + i] = bitcnt_partial[8 * i + 7][3];
      end

      for (genvar i = 0; i < 2; i++) begin : gen_bitcnt_reg_in_b4
        assign bitcnt_partial_msb_d[28 + i] = bitcnt_partial[16 * i + 15][4];
      end

      assign bitcnt_partial_msb_d[30] = bitcnt_partial[31][5];
      assign bitcnt_partial_msb_d[31] = 1'b0;  // unused

      // Second cycle
      // Load partial bitcnts
      always_comb begin
        bitcnt_partial_q = '{default: '0};

        for (int unsigned i = 0; i < 32; i++) begin : gen_bitcnt_reg_out_lsb
          bitcnt_partial_q[i][0] = imd_val_q_i[0][i];
        end

        for (int unsigned i = 0; i < 16; i++) begin : gen_bitcnt_reg_out_b1
          bitcnt_partial_q[2 * i + 1][1] = imd_val_q_i[1][i];
        end

        for (int unsigned i = 0; i < 8; i++) begin : gen_bitcnt_reg_out_b2
          bitcnt_partial_q[4 * i + 3][2] = imd_val_q_i[1][16 + i];
        end

        for (int unsigned i = 0; i < 4; i++) begin : gen_bitcnt_reg_out_b3
          bitcnt_partial_q[8 * i + 7][3] = imd_val_q_i[1][24 + i];
        end

        for (int unsigned i = 0; i < 2; i++) begin : gen_bitcnt_reg_out_b4
          bitcnt_partial_q[16 * i + 15][4] = imd_val_q_i[1][28 + i];
        end

        bitcnt_partial_q[31][5] = imd_val_q_i[1][30];
      end

      logic [31:0] butterfly_mask_l[5];
      logic [31:0] butterfly_mask_r[5];
      logic [31:0] butterfly_mask_not[5];
      logic [31:0] lrotc_stage[5];  // left rotate and complement upon wrap

      // number of bits in local r = 32 / 2**(stage + 1) = 16/2**stage
      `define _N(stg) (16 >> stg)

      // bext / bdep control bit generation
      for (genvar stg = 0; stg < 5; stg++) begin : gen_butterfly_ctrl_stage
        // number of segs: 2** stg
        for (genvar seg = 0; seg < 2 ** stg; seg++) begin : gen_butterfly_ctrl

          assign lrotc_stage[stg][2 *
          `_N(stg)
          * (seg + 1) - 1 : 2 *
          `_N(stg)
          * seg] = {
            {`_N(stg) {1'b0}}, {`_N(stg) {1'b1}}
          } << bitcnt_partial_q[
          `_N(stg)
          * (2 * seg + 1) - 1][$clog2(
          `_N(stg)
          ):0];

          assign butterfly_mask_l[stg][
          `_N(stg)
          * (2 * seg + 2) - 1 :
          `_N(stg)
          * (2 * seg + 1)] = ~lrotc_stage[stg][
          `_N(stg)
          * (2 * seg + 2) - 1 :
          `_N(stg)
          * (2 * seg + 1)];

          assign butterfly_mask_r[stg][
          `_N(stg)
          * (2 * seg + 1) - 1 :
          `_N(stg)
          * (2 * seg)] = ~lrotc_stage[stg][
          `_N(stg)
          * (2 * seg + 2) - 1 :
          `_N(stg)
          * (2 * seg + 1)];

          assign butterfly_mask_l[stg][`_N(stg) * (2 * seg + 1) - 1 : `_N(stg) * (2 * seg)] = '0;
          assign butterfly_mask_r[stg][
          `_N(stg)
          * (2 * seg + 2) - 1 :
          `_N(stg)
          * (2 * seg + 1)] = '0;
        end
      end
      `undef _N

      for (genvar stg = 0; stg < 5; stg++) begin : gen_butterfly_not
        assign butterfly_mask_not[stg] = ~(butterfly_mask_l[stg] | butterfly_mask_r[stg]);
      end

      always_comb begin
        butterfly_result = operand_a_i;

        butterfly_result = butterfly_result &
            butterfly_mask_not[0] | ((butterfly_result & butterfly_mask_l[0]) >> 16
            ) | ((butterfly_result & butterfly_mask_r[0]) << 16);

        butterfly_result = butterfly_result &
            butterfly_mask_not[1] | ((butterfly_result & butterfly_mask_l[1]) >> 8
            ) | ((butterfly_result & butterfly_mask_r[1]) << 8);

        butterfly_result = butterfly_result &
            butterfly_mask_not[2] | ((butterfly_result & butterfly_mask_l[2]) >> 4
            ) | ((butterfly_result & butterfly_mask_r[2]) << 4);

        butterfly_result = butterfly_result &
            butterfly_mask_not[3] | ((butterfly_result & butterfly_mask_l[3]) >> 2
            ) | ((butterfly_result & butterfly_mask_r[3]) << 2);

        butterfly_result = butterfly_result &
            butterfly_mask_not[4] | ((butterfly_result & butterfly_mask_l[4]) >> 1
            ) | ((butterfly_result & butterfly_mask_r[4]) << 1);

        butterfly_result = butterfly_result & operand_b_i;
      end

      always_comb begin
        invbutterfly_result = operand_a_i & operand_b_i;

        invbutterfly_result = invbutterfly_result &
            butterfly_mask_not[4] | ((invbutterfly_result & butterfly_mask_l[4]) >> 1
            ) | ((invbutterfly_result & butterfly_mask_r[4]) << 1);

        invbutterfly_result = invbutterfly_result &
            butterfly_mask_not[3] | ((invbutterfly_result & butterfly_mask_l[3]) >> 2
            ) | ((invbutterfly_result & butterfly_mask_r[3]) << 2);

        invbutterfly_result = invbutterfly_result &
            butterfly_mask_not[2] | ((invbutterfly_result & butterfly_mask_l[2]) >> 4
            ) | ((invbutterfly_result & butterfly_mask_r[2]) << 4);

        invbutterfly_result = invbutterfly_result &
            butterfly_mask_not[1] | ((invbutterfly_result & butterfly_mask_l[1]) >> 8
            ) | ((invbutterfly_result & butterfly_mask_r[1]) << 8);

        invbutterfly_result = invbutterfly_result &
            butterfly_mask_not[0] | ((invbutterfly_result & butterfly_mask_l[0]) >> 16
            ) | ((invbutterfly_result & butterfly_mask_r[0]) << 16);
      end

      ///////////////////////////////////////////////////
      // Carry-less Multiply + Cyclic Redundancy Check //
      ///////////////////////////////////////////////////

      // Carry-less multiplication can be understood as multiplication based on
      // the addition interpreted as the bit-wise xor operation.
      //
      // Example: 1101 X 1011 = 1111111:
      //
      //       1011 X 1101
      //       -----------
      //              1101
      //         xor 1101
      //         ---------
      //             10111
      //        xor 0000
      //        ----------
      //            010111
      //       xor 1101
      //       -----------
      //           1111111
      //
      // Architectural details:
      //         A 32 x 32-bit array
      //         [ operand_b[i] ? (operand_a << i) : '0 for i in 0 ... 31 ]
      //         is generated. The entries of the array are pairwise 'xor-ed'
      //         together in a 5-stage binary tree.
      //
      //
      // Cyclic Redundancy Check:
      //
      // CRC-32 (CRC-32/ISO-HDLC) and CRC-32C (CRC-32/ISCSI) are directly implemented. For
      // documentation of the crc configuration (crc-polynomials, initialization, reflection, etc.)
      // see http://reveng.sourceforge.net/crc-catalogue/all.htm
      // A useful guide to crc arithmetic and algorithms is given here:
      // http://www.piclist.com/techref/method/math/crcguide.html.
      //
      // The CRC operation solves the following equation using binary polynomial arithmetic:
      //
      // rev(rd)(x) = rev(rs1)(x) * x**n mod {1, P}(x)
      //
      // where P denotes lower 32 bits of the corresponding CRC polynomial, rev(a) the bit reversal
      // of a, n = 8,16, or 32 for .b, .h, .w -variants. {a, b} denotes bit concatenation.
      //
      // Using barret reduction, one can show that
      //
      // M(x) mod P(x) = R(x) =
      //          (M(x) * x**n) & {deg(P(x)'{1'b1}}) ^ (M(x) x**-(deg(P(x) - n)) cx mu(x) cx P(x),
      //
      // Where mu(x) = polydiv(x**64, {1,P}) & 0xffffffff. Here, 'cx' refers to carry-less
      // multiplication. Substituting rev(rd)(x) for R(x) and rev(rs1)(x) for M(x) and solving for
      // rd(x) with P(x) a crc32 polynomial (deg(P(x)) = 32), we get
      //
      // rd = rev( (rev(rs1) << n)  ^ ((rev(rs1) >> (32-n)) cx mu cx P)
      //    = (rs1 >> n) ^ rev(rev( (rs1 << (32-n)) cx rev(mu)) cx P)
      //                       ^-- cycle 0--------------------^
      //      ^- cycle 1 -------------------------------------------^
      //
      // In the last step we used the fact that carry-less multiplication is bit-order agnostic:
      // rev(a cx b) = rev(a) cx rev(b).

      logic clmul_rmode;
      logic clmul_hmode;
      logic [31:0] clmul_op_a;
      logic [31:0] clmul_op_b;
      logic [31:0] operand_b_rev;
      logic [31:0] clmul_and_stage[32];
      logic [31:0] clmul_xor_stage1[16];
      logic [31:0] clmul_xor_stage2[8];
      logic [31:0] clmul_xor_stage3[4];
      logic [31:0] clmul_xor_stage4[2];

      logic [31:0] clmul_result_raw;

      for (genvar i = 0; i < 32; i++) begin : gen_rev_operand_b
        assign operand_b_rev[i] = operand_b_i[31 - i];
      end

      assign clmul_rmode = operator_i == ALU_CLMULR;
      assign clmul_hmode = operator_i == ALU_CLMULH;

      // CRC
      localparam logic [31:0] CRC32_POLYNOMIAL = 32'h04c1_1db7;
      localparam logic [31:0] CRC32_MU_REV = 32'hf701_1641;

      localparam logic [31:0] CRC32C_POLYNOMIAL = 32'h1edc_6f41;
      localparam logic [31:0] CRC32C_MU_REV = 32'hdea7_13f1;

      logic crc_op;

      logic crc_cpoly;

      logic [31:0] crc_operand;
      logic [31:0] crc_poly;
      logic [31:0] crc_mu_rev;

      assign crc_op = (operator_i == ALU_CRC32C_W) | (operator_i == ALU_CRC32_W) | (
          operator_i == ALU_CRC32C_H) | (operator_i == ALU_CRC32_H) | (operator_i == ALU_CRC32C_B
          ) | (operator_i == ALU_CRC32_B);

      assign crc_cpoly = (operator_i == ALU_CRC32C_W) | (operator_i == ALU_CRC32C_H) | (
          operator_i == ALU_CRC32C_B);

      assign crc_hmode = (operator_i == ALU_CRC32_H) | (operator_i == ALU_CRC32C_H);
      assign crc_bmode = (operator_i == ALU_CRC32_B) | (operator_i == ALU_CRC32C_B);

      assign crc_poly = crc_cpoly ? CRC32C_POLYNOMIAL : CRC32_POLYNOMIAL;
      assign crc_mu_rev = crc_cpoly ? CRC32C_MU_REV : CRC32_MU_REV;

      always_comb begin
        unique case (1'b1)
          crc_bmode: crc_operand = {operand_a_i[7:0], 24'h0};
          crc_hmode: crc_operand = {operand_a_i[15:0], 16'h0};
          default: crc_operand = operand_a_i;
        endcase
      end

      // Select clmul input
      always_comb begin
        if (crc_op) begin
          clmul_op_a = instr_first_cycle_i ? crc_operand : imd_val_q_i[0];
          clmul_op_b = instr_first_cycle_i ? crc_mu_rev : crc_poly;
        end else begin
          clmul_op_a = clmul_rmode | clmul_hmode ? operand_a_rev : operand_a_i;
          clmul_op_b = clmul_rmode | clmul_hmode ? operand_b_rev : operand_b_i;
        end
      end

      for (genvar i = 0; i < 32; i++) begin : gen_clmul_and_op
        assign clmul_and_stage[i] = clmul_op_b[i] ? clmul_op_a << i : '0;
      end

      for (genvar i = 0; i < 16; i++) begin : gen_clmul_xor_op_l1
        assign clmul_xor_stage1[i] = clmul_and_stage[2 * i] ^ clmul_and_stage[2 * i + 1];
      end

      for (genvar i = 0; i < 8; i++) begin : gen_clmul_xor_op_l2
        assign clmul_xor_stage2[i] = clmul_xor_stage1[2 * i] ^ clmul_xor_stage1[2 * i + 1];
      end

      for (genvar i = 0; i < 4; i++) begin : gen_clmul_xor_op_l3
        assign clmul_xor_stage3[i] = clmul_xor_stage2[2 * i] ^ clmul_xor_stage2[2 * i + 1];
      end

      for (genvar i = 0; i < 2; i++) begin : gen_clmul_xor_op_l4
        assign clmul_xor_stage4[i] = clmul_xor_stage3[2 * i] ^ clmul_xor_stage3[2 * i + 1];
      end

      assign clmul_result_raw = clmul_xor_stage4[0] ^ clmul_xor_stage4[1];

      for (genvar i = 0; i < 32; i++) begin : gen_rev_clmul_result
        assign clmul_result_rev[i] = clmul_result_raw[31 - i];
      end

      // clmulr_result = rev(clmul(rev(a), rev(b)))
      // clmulh_result = clmulr_result >> 1
      always_comb begin
        case (1'b1)
          clmul_rmode: clmul_result = clmul_result_rev;
          clmul_hmode: clmul_result = {1'b0, clmul_result_rev[31:1]};
          default: clmul_result = clmul_result_raw;
        endcase
      end
    end else begin : gen_alu_rvb_notfull
      assign shuffle_result = '0;
      assign butterfly_result = '0;
      assign invbutterfly_result = '0;
      assign clmul_result = '0;
      // support signals
      assign bitcnt_partial_lsb_d = '0;
      assign bitcnt_partial_msb_d = '0;
      assign clmul_result_rev = '0;
      assign crc_bmode = '0;
      assign crc_hmode = '0;
    end

    //////////////////////////////////////
    // Multicycle Bitmanip Instructions //
    //////////////////////////////////////
    // Ternary instructions + Shift Rotations + Bit extract/deposit + CRC
    // For ternary instructions (zbt), operand_a_i is tied to rs1 in the first cycle and rs3 in the
    // second cycle. operand_b_i is always tied to rs2.

    always_comb begin
      unique case (operator_i)
        ALU_CMOV: begin
          multicycle_result = (operand_b_i == 32'h0) ? operand_a_i : imd_val_q_i[0];
          imd_val_d_o = '{operand_a_i, 32'h0};
          if (instr_first_cycle_i) begin
            imd_val_we_o = 2'b01;
          end else begin
            imd_val_we_o = 2'b00;
          end
        end

        ALU_CMIX: begin
          multicycle_result = imd_val_q_i[0] | bwlogic_and_result;
          imd_val_d_o = '{bwlogic_and_result, 32'h0};
          if (instr_first_cycle_i) begin
            imd_val_we_o = 2'b01;
          end else begin
            imd_val_we_o = 2'b00;
          end
        end

        ALU_FSR, ALU_FSL, ALU_ROL, ALU_ROR: begin
          if (shift_amt[4:0] == 5'h0) begin
            multicycle_result = shift_amt[5] ? operand_a_i : imd_val_q_i[0];
          end else begin
            multicycle_result = imd_val_q_i[0] | shift_result;
          end
          imd_val_d_o = '{shift_result, 32'h0};
          if (instr_first_cycle_i) begin
            imd_val_we_o = 2'b01;
          end else begin
            imd_val_we_o = 2'b00;
          end
        end

        ALU_CRC32_W, ALU_CRC32C_W, ALU_CRC32_H, ALU_CRC32C_H, ALU_CRC32_B, ALU_CRC32C_B: begin
          if (RV32B == RV32BFull) begin
            unique case (1'b1)
              crc_bmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 8);
              crc_hmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 16);
              default: multicycle_result = clmul_result_rev;
            endcase
            imd_val_d_o = '{clmul_result_rev, 32'h0};
            if (instr_first_cycle_i) begin
              imd_val_we_o = 2'b01;
            end else begin
              imd_val_we_o = 2'b00;
            end
          end else begin
            imd_val_d_o = '{operand_a_i, 32'h0};
            imd_val_we_o = 2'b00;
            multicycle_result = '0;
          end
        end

        ALU_BEXT, ALU_BDEP: begin
          if (RV32B == RV32BFull) begin
            multicycle_result = (operator_i == ALU_BDEP) ? butterfly_result : invbutterfly_result;
            imd_val_d_o = '{bitcnt_partial_lsb_d, bitcnt_partial_msb_d};
            if (instr_first_cycle_i) begin
              imd_val_we_o = 2'b11;
            end else begin
              imd_val_we_o = 2'b00;
            end
          end else begin
            imd_val_d_o = '{operand_a_i, 32'h0};
            imd_val_we_o = 2'b00;
            multicycle_result = '0;
          end
        end

        default: begin
          imd_val_d_o = '{operand_a_i, 32'h0};
          imd_val_we_o = 2'b00;
          multicycle_result = '0;
        end
      endcase
    end


  end else begin : g_no_alu_rvb
    // RV32B result signals
    assign bitcnt_result = '0;
    assign minmax_result = '0;
    assign pack_result = '0;
    assign sext_result = '0;
    assign singlebit_result = '0;
    assign rev_result = '0;
    assign shuffle_result = '0;
    assign butterfly_result = '0;
    assign invbutterfly_result = '0;
    assign clmul_result = '0;
    assign multicycle_result = '0;
    // RV32B support signals
    assign imd_val_d_o = '{default: '0};
    assign imd_val_we_o = '{default: '0};
  end

  ////////////////
  // Result mux //
  ////////////////

  always_comb begin
    result_o = '0;

    unique case (operator_i)
      // Bitwise Logic Operations (negate: RV32B)
      ALU_XOR, ALU_XNOR, ALU_OR, ALU_ORN, ALU_AND, ALU_ANDN:
      result_o = bwlogic_result;

      // Adder Operations
      ALU_ADD, ALU_SUB:
      result_o = adder_result;

      // Shift Operations
      ALU_SLL, ALU_SRL, ALU_SRA,
      // RV32B
      ALU_SLO, ALU_SRO:
      result_o = shift_result;

      // Shuffle Operations (RV32B)
      ALU_SHFL, ALU_UNSHFL:
      result_o = shuffle_result;

      // Comparison Operations
      ALU_EQ, ALU_NE, ALU_GE, ALU_GEU, ALU_LT, ALU_LTU, ALU_SLT, ALU_SLTU:
      result_o = {31'h0, cmp_result};

      // MinMax Operations (RV32B)
      ALU_MIN, ALU_MAX, ALU_MINU, ALU_MAXU:
      result_o = minmax_result;

      // Bitcount Operations (RV32B)
      ALU_CLZ, ALU_CTZ, ALU_PCNT:
      result_o = {26'h0, bitcnt_result};

      // Pack Operations (RV32B)
      ALU_PACK, ALU_PACKH, ALU_PACKU:
      result_o = pack_result;

      // Sign-Extend (RV32B)
      ALU_SEXTB, ALU_SEXTH:
      result_o = sext_result;

      // Ternary Bitmanip Operations (RV32B)
      ALU_CMIX, ALU_CMOV, ALU_FSL, ALU_FSR,
      // Rotate Shift (RV32B)
      ALU_ROL, ALU_ROR,
      // Cyclic Redundancy Checks (RV32B)
      ALU_CRC32_W, ALU_CRC32C_W, ALU_CRC32_H, ALU_CRC32C_H, ALU_CRC32_B, ALU_CRC32C_B,
      // Bit Extract / Deposit (RV32B)
      ALU_BEXT, ALU_BDEP:
      result_o = multicycle_result;

      // Single-Bit Bitmanip Operations (RV32B)
      ALU_SBSET, ALU_SBCLR, ALU_SBINV, ALU_SBEXT:
      result_o = singlebit_result;

      // General Reverse / Or-combine (RV32B)
      ALU_GREV, ALU_GORC:
      result_o = rev_result;

      // Bit Field Place (RV32B)
      ALU_BFP:
      result_o = bfp_result;

      // Carry-less Multiply Operations (RV32B)
      ALU_CLMUL, ALU_CLMULR, ALU_CLMULH:
      result_o = clmul_result;

      default: ;
    endcase
  end

endmodule
<<EOF>>
hw/top_earlgrey/ip/ast/rtl/ast_wrapper_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/usb_osc.sv: hw/top_earlgrey/ip/ast/rtl/usb_osc.sv:42:6: syntax error, rejected "#" (https://github.com/google/verible).

hw/top_earlgrey/ip/ast/rtl/usb_clk.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/entropy.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/ast_reg_top.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/gen_pok.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/pdm.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/sys_osc.sv: hw/top_earlgrey/ip/ast/rtl/sys_osc.sv:39:6: syntax error, rejected "#" (https://github.com/google/verible).

hw/top_earlgrey/ip/ast/rtl/ast_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/ast_wrapper.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/aon_osc.sv: Already formatted, no change.
hw/top_earlgrey/rtl/autogen/top_earlgrey.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/main_rglt.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/adc.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/gen_alert.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/io_clk.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/io_osc.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/sys_clk.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/rng.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/aon_clk.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/rng_osc.sv: Already formatted, no change.
hw/top_earlgrey/ip/padctrl/rtl/autogen/padctrl_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/ast/rtl/ast.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_instr_gen_config.sv: Already formatted, no change.
hw/top_earlgrey/ip/alert_handler/rtl/autogen/alert_handler_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/alert_handler/dv/alert_handler_env_pkg__params.sv: Already formatted, no change.
hw/top_earlgrey/ip/clkmgr/rtl/autogen/clkmgr_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/clkmgr/rtl/autogen/clkmgr_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/clkmgr/rtl/autogen/clkmgr.sv: Already formatted, no change.
hw/top_earlgrey/ip/clkmgr/rtl/autogen/clkmgr_reg_top.sv: Already formatted, no change.
hw/top_earlgrey/ip/padctrl/rtl/autogen/padctrl_reg_top.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/riscv_asm_program_gen.sv: Already formatted, no change.
hw/top_earlgrey/ip/sensor_ctrl/rtl/sensor_ctrl_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/sensor_ctrl/rtl/sensor_ctrl.sv: Already formatted, no change.
hw/top_earlgrey/ip/sensor_ctrl/rtl/sensor_ctrl_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/rv_plic/rtl/autogen/rv_plic.sv: Already formatted, no change.
hw/top_earlgrey/ip/rv_plic/fpv/rv_plic_fpv.sv: Already formatted, no change.
hw/top_earlgrey/ip/rv_plic/fpv/rv_plic_bind_fpv.svhw/top_earlgrey/ip/sensor_ctrl/rtl/sensor_ctrl_reg_top.sv: Already formatted, no change.: Already formatted, no change.

hw/top_earlgrey/ip/rv_plic/rtl/autogen/rv_plic_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/pwrmgr/rtl/autogen/pwrmgr_reg_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_main/rtl/autogen/tl_main_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_main/dv/autogen/tb__xbar_connect.sv: hw/top_earlgrey/ip/xbar_main/dv/autogen/tb__xbar_connect.sv:7:14: syntax error, rejected "(" (https://github.com/google/verible).

hw/top_earlgrey/ip/xbar_main/dv/autogen/xbar_main_bind.sv: Already formatted, no change.
hw/top_earlgrey/ip/pwrmgr/rtl/autogen/pwrmgr_reg_top.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_peri/rtl/autogen/xbar_peri.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_peri/rtl/autogen/tl_peri_pkg.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_peri/dv/autogen/xbar_peri_bind.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_peri/dv/autogen/tb__xbar_connect.sv: hw/top_earlgrey/ip/xbar_peri/dv/autogen/tb__xbar_connect.sv:7:14: syntax error, rejected "(" (https://github.com/google/verible).

hw/top_earlgrey/ip/pinmux/rtl/autogen/pinmux_reg_top.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_env_cov.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_virtual_sequencer.sv: Already formatted, no change.
hw/top_earlgrey/ip/alert_handler/rtl/autogen/alert_handler_reg_top.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_scoreboard.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_tl_seq_item.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_env_cfg.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_env.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/sw_test_status_if.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/chip_env_pkg.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/sw_test_status_pkg.sv: Already formatted, no change.
hw/vendor/lowrisc_ibex/vendor/google_riscv-dv/src/isa/riscv_b_instr.sv: *** Some token partitions failed to complete within the search limit:
>>>>[return cfg . enable_b_extension && ( ( ZBB inside { cfg . enable_bitmanip_groups } && instr_name inside { CLZ , CTZ , CLZW , CTZW , PCNT , PCNTW , SLO , SLOI , SLOW , SLOIW , SRO , SROI , SROW , SROIW , MIN , MINU , MAX , MAXU , ADDWU , ADDIWU , SUBWU , ADDU_W , SUBU_W , SLLIU_W , ANDN , ORN , XNOR , PACK , PACKW , PACKU , PACKUW , PACKH , ROL , ROLW , ROR , RORW , RORI , RORIW } ) || ( ZBS inside { cfg . enable_bitmanip_groups } && instr_name inside { SBSET , SBSETW , SBSETI , SBSETIW , SBCLR , SBCLRW , SBCLRI , SBCLRIW , SBINV , SBINVW , SBINVI , SBINVIW , SBEXT , SBEXTW , SBEXTI } ) || ( ZBP inside { cfg . enable_bitmanip_groups } && instr_name inside { GREV , GREVW , GREVI , GREVIW , GORC , GORCW , GORCI , GORCIW , SHFL , SHFLW , UNSHFL , UNSHFLW , SHFLI , UNSHFLI } ) || ( ZBE inside { cfg . enable_bitmanip_groups } && instr_name inside { BEXT , BEXTW , BDEP , BDEPW } ) || ( ZBF inside { cfg . enable_bitmanip_groups } && instr_name inside { BFP , BFPW } ) || ( ZBC inside { cfg . enable_bitmanip_groups } && instr_name inside { CLMUL , CLMULW , CLMULH , CLMULHW , CLMULR , CLMULRW } ) || ( ZBR inside { cfg . enable_bitmanip_groups } && instr_name inside { CRC32_B , CRC32_H , CRC32_W , CRC32_D , CRC32C_B , CRC32C_H , CRC32C_W , CRC32C_D } ) || ( ZBM inside { cfg . enable_bitmanip_groups } && instr_name inside { BMATOR , BMATXOR , BMATFLIP } ) || ( ZBT inside { cfg . enable_bitmanip_groups } && instr_name inside { CMOV , CMIX , FSL , FSLW , FSR , FSRW , FSRI , FSRIW } ) ||], policy: fit-else-expand
*** end of partially formatted partition list
[other error status]
hw/top_earlgrey/dv/env/seq_lib/chip_vseq_list.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/seq_lib/chip_sw_uart_tx_rx_vseq.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/seq_lib/chip_sw_base_vseq.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/seq_lib/chip_base_vseq.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/seq_lib/chip_sw_gpio_vseq.sv: Already formatted, no change.
hw/top_earlgrey/dv/env/seq_lib/chip_common_vseq.sv: Already formatted, no change.
hw/top_earlgrey/dv/tests/chip_test_pkg.sv: Already formatted, no change.
hw/top_earlgrey/dv/tb/chip_hier_macros.svh: Already formatted, no change.
hw/top_earlgrey/dv/tests/chip_base_test.sv: Already formatted, no change.
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv: hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:7:27: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:9:25: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:11:18: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:12:18: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:13:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:15:16: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:16:22: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:17:21: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:18:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:19:23: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:20:17: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:21:16: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:22:20: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:23:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:24:20: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:25:26: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:26:20: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:27:17: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:28:17: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:29:17: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:30:23: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:31:21: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:32:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:33:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:34:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:35:19: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:36:20: syntax error, rejected "(" (https://github.com/google/verible).
hw/top_earlgrey/dv/autogen/tb__xbar_connect.sv:37:24: syntax error, rejected "(" (https://github.com/google/verible).

hw/top_earlgrey/dv/tb/tb.sv: Already formatted, no change.
hw/top_earlgrey/ip/rv_plic/rtl/autogen/rv_plic_reg_top.sv: Already formatted, no change.
hw/top_earlgrey/ip/xbar_peri/dv/autogen/xbar_env_pkg__params.sv: *** Some token partitions failed to complete within the search limit:
[tl_device_t xbar_devices [ $ ] = '{ '{ "uart" , '{ '{ 32 'h 40000000 , 32 'h 40000fff } } } , '{ "gpio" , '{ '{ 32 'h 40010000 , 32 'h 40010fff } } } , '{ "spi_device" , '{ '{ 32 'h 40020000 , 32 'h 40020fff } } } , '{ "rv_timer" , '{ '{ 32 'h 40080000 , 32 'h 40080fff } } } , '{ "usbdev" , '{ '{ 32 'h 40150000 , 32 'h 40150fff } } } , '{ "pwrmgr" , '{ '{ 32 'h 400a0000 , 32 'h 400a0fff } } } , '{ "rstmgr" , '{ '{ 32 'h 400b0000 , 32 'h 400b0fff } } } , '{ "clkmgr" , '{ '{ 32 'h 400c0000 , 32 'h 400c0fff } } } , '{ "ram_ret" , '{ '{ 32 'h 18000000 , 32 'h 18000fff } } } , '{ "sensor_ctrl" , '{ '{ 32 'h 40170000 , 32 'h 40170fff } } } } ;], policy: fit-else-expand, (origin: "tl_device_t...170fff}}}};")
*** end of partially formatted partition list
[other error status]
hw/top_earlgrey/ip/xbar_main/dv/autogen/xbar_env_pkg__params.sv: *** Some token partitions failed to complete within the search limit:
[tl_device_t xbar_devices [ $ ] = '{ '{ "rom" , '{ '{ 32 'h 00008000 , 32 'h 0000bfff } } } , '{ "debug_mem" , '{ '{ 32 'h 1a110000 , 32 'h 1a110fff } } } , '{ "ram_main" , '{ '{ 32 'h 10000000 , 32 'h 1000ffff } } } , '{ "eflash" , '{ '{ 32 'h 20000000 , 32 'h 2007ffff } } } , '{ "peri" , '{ '{ 32 'h 18000000 , 32 'h 18000fff } , '{ 32 'h 40000000 , 32 'h 40020fff } , '{ 32 'h 40080000 , 32 'h 40080fff } , '{ 32 'h 400a0000 , 32 'h 400c0fff } , '{ 32 'h 40150000 , 32 'h 40150fff } , '{ 32 'h 40170000 , 32 'h 40170fff } } } , '{ "flash_ctrl" , '{ '{ 32 'h 40030000 , 32 'h 40030fff } } } , '{ "hmac" , '{ '{ 32 'h 40120000 , 32 'h 40120fff } } } , '{ "aes" , '{ '{ 32 'h 40110000 , 32 'h 40110fff } } } , '{ "rv_plic" , '{ '{ 32 'h 40090000 , 32 'h 40090fff } } } , '{ "pinmux" , '{ '{ 32 'h 40070000 , 32 'h 40070fff } } } , '{ "padctrl" , '{ '{ 32 'h 40160000 , 32 'h 40160fff } } } , '{ "alert_handler" , '{ '{ 32 'h 40130000 , 32 'h 40130fff } } } , '{ "nmi_gen" , '{ '{ 32 'h 40140000 , 32 'h 40140fff } } } , '{ "otbn" , '{ '{ 32 'h 50000000 , 32 'h 503fffff } } } } ;], policy: fit-else-expand, (origin: "tl_device_t...      }}}};")
[tl_host_t xbar_hosts [ $ ] = '{ '{ "corei" , 0 , '{ "rom" , "debug_mem" , "ram_main" , "eflash" } } , '{ "cored" , 1 , '{ "rom" , "debug_mem" , "ram_main" , "eflash" , "peri" , "flash_ctrl" , "aes" , "hmac" , "rv_plic" , "pinmux" , "padctrl" , "alert_handler" , "nmi_gen" , "otbn" } } , '{ "dm_sba" , 2 , '{ "rom" , "ram_main" , "eflash" , "peri" , "flash_ctrl" , "aes" , "hmac" , "rv_plic" , "pinmux" , "padctrl" , "alert_handler" , "nmi_gen" , "otbn" } } } ;], policy: fit-else-expand, (origin: "tl_host_t
 ... "otbn"}}};")
*** end of partially formatted partition list
[other error status]
hw/top_earlgrey/ip/xbar_main/rtl/autogen/xbar_main.sv: *** Some token partitions failed to complete within the search limit:
>>>>[end else if ( ( ( tl_s1n_22_us_h2d . a_address & ~ ( ADDR_MASK_PERI [ 0 ] ) ) == ADDR_SPACE_PERI [ 0 ] ) || ( ( tl_s1n_22_us_h2d . a_address <= ( ADDR_MASK_PERI [ 1 ] + ADDR_SPACE_PERI [ 1 ] ) ) && ( tl_s1n_22_us_h2d . a_address >= ADDR_SPACE_PERI [ 1 ] ) ) || ( ( tl_s1n_22_us_h2d . a_address <= ( ADDR_MASK_PERI [ 2 ] + ADDR_SPACE_PERI [ 2 ] ) ) && ( tl_s1n_22_us_h2d . a_address >= ADDR_SPACE_PERI [ 2 ] ) ) || ( ( tl_s1n_22_us_h2d . a_address <= ( ADDR_MASK_PERI [ 3 ] + ADDR_SPACE_PERI [ 3 ] ) ) && ( tl_s1n_22_us_h2d . a_address >= ADDR_SPACE_PERI [ 3 ] ) ) || ( ( tl_s1n_22_us_h2d . a_address <= ( ADDR_MASK_PERI [ 4 ] + ADDR_SPACE_PERI [ 4 ] ) ) && ( tl_s1n_22_us_h2d . a_address >= ADDR_SPACE_PERI [ 4 ] ) ) || ( ( tl_s1n_22_us_h2d . a_address <= ( ADDR_MASK_PERI [ 5 ] + ADDR_SPACE_PERI [ 5 ] ) ) && ( tl_s1n_22_us_h2d . a_address >= ADDR_SPACE_PERI [ 5 ] ) ) ) begin], policy: fit-else-expand
>>>>[end else if ( ( ( tl_s1n_34_us_h2d . a_address & ~ ( ADDR_MASK_PERI [ 0 ] ) ) == ADDR_SPACE_PERI [ 0 ] ) || ( ( tl_s1n_34_us_h2d . a_address <= ( ADDR_MASK_PERI [ 1 ] + ADDR_SPACE_PERI [ 1 ] ) ) && ( tl_s1n_34_us_h2d . a_address >= ADDR_SPACE_PERI [ 1 ] ) ) || ( ( tl_s1n_34_us_h2d . a_address <= ( ADDR_MASK_PERI [ 2 ] + ADDR_SPACE_PERI [ 2 ] ) ) && ( tl_s1n_34_us_h2d . a_address >= ADDR_SPACE_PERI [ 2 ] ) ) || ( ( tl_s1n_34_us_h2d . a_address <= ( ADDR_MASK_PERI [ 3 ] + ADDR_SPACE_PERI [ 3 ] ) ) && ( tl_s1n_34_us_h2d . a_address >= ADDR_SPACE_PERI [ 3 ] ) ) || ( ( tl_s1n_34_us_h2d . a_address <= ( ADDR_MASK_PERI [ 4 ] + ADDR_SPACE_PERI [ 4 ] ) ) && ( tl_s1n_34_us_h2d . a_address >= ADDR_SPACE_PERI [ 4 ] ) ) || ( ( tl_s1n_34_us_h2d . a_address <= ( ADDR_MASK_PERI [ 5 ] + ADDR_SPACE_PERI [ 5 ] ) ) && ( tl_s1n_34_us_h2d . a_address >= ADDR_SPACE_PERI [ 5 ] ) ) ) begin], policy: fit-else-expand
*** end of partially formatted partition list
[other error status]
hw/top_earlgrey/dv/autogen/xbar_env_pkg__params.sv: *** Some token partitions failed to complete within the search limit:
[tl_device_t xbar_devices [ $ ] = '{ '{ "rom" , '{ '{ 32 'h 00008000 , 32 'h 0000bfff } } } , '{ "debug_mem" , '{ '{ 32 'h 1a110000 , 32 'h 1a110fff } } } , '{ "ram_main" , '{ '{ 32 'h 10000000 , 32 'h 1000ffff } } } , '{ "eflash" , '{ '{ 32 'h 20000000 , 32 'h 2007ffff } } } , '{ "flash_ctrl" , '{ '{ 32 'h 40030000 , 32 'h 40030fff } } } , '{ "hmac" , '{ '{ 32 'h 40120000 , 32 'h 40120fff } } } , '{ "aes" , '{ '{ 32 'h 40110000 , 32 'h 40110fff } } } , '{ "rv_plic" , '{ '{ 32 'h 40090000 , 32 'h 40090fff } } } , '{ "pinmux" , '{ '{ 32 'h 40070000 , 32 'h 40070fff } } } , '{ "padctrl" , '{ '{ 32 'h 40160000 , 32 'h 40160fff } } } , '{ "alert_handler" , '{ '{ 32 'h 40130000 , 32 'h 40130fff } } } , '{ "nmi_gen" , '{ '{ 32 'h 40140000 , 32 'h 40140fff } } } , '{ "otbn" , '{ '{ 32 'h 50000000 , 32 'h 503fffff } } } , '{ "uart" , '{ '{ 32 'h 40000000 , 32 'h 40000fff } } } , '{ "gpio" , '{ '{ 32 'h 40010000 , 32 'h 40010fff } } } , '{ "spi_device" , '{ '{ 32 'h 40020000 , 32 'h 40020fff } } } , '{ "rv_timer" , '{ '{ 32 'h 40080000 , 32 'h 40080fff } } } , '{ "usbdev" , '{ '{ 32 'h 40150000 , 32 'h 40150fff } } } , '{ "pwrmgr" , '{ '{ 32 'h 400a0000 , 32 'h 400a0fff } } } , '{ "rstmgr" , '{ '{ 32 'h 400b0000 , 32 'h 400b0fff } } } , '{ "clkmgr" , '{ '{ 32 'h 400c0000 , 32 'h 400c0fff } } } , '{ "ram_ret" , '{ '{ 32 'h 18000000 , 32 'h 18000fff } } } , '{ "sensor_ctrl" , '{ '{ 32 'h 40170000 , 32 'h 40170fff } } } } ;], policy: fit-else-expand, (origin: "tl_device_t...170fff}}}};")
[tl_host_t xbar_hosts [ $ ] = '{ '{ "corei" , 0 , '{ "rom" , "debug_mem" , "ram_main" , "eflash" } } , '{ "cored" , 1 , '{ "rom" , "debug_mem" , "ram_main" , "eflash" , "uart" , "gpio" , "spi_device" , "rv_timer" , "usbdev" , "pwrmgr" , "rstmgr" , "clkmgr" , "ram_ret" , "sensor_ctrl" , "flash_ctrl" , "aes" , "hmac" , "rv_plic" , "pinmux" , "padctrl" , "alert_handler" , "nmi_gen" , "otbn" } } , '{ "dm_sba" , 2 , '{ "rom" , "ram_main" , "eflash" , "uart" , "gpio" , "spi_device" , "rv_timer" , "usbdev" , "pwrmgr" , "rstmgr" , "clkmgr" , "ram_ret" , "sensor_ctrl" , "flash_ctrl" , "aes" , "hmac" , "rv_plic" , "pinmux" , "padctrl" , "alert_handler" , "nmi_gen" , "otbn" } } } ;], policy: fit-else-expand, (origin: "tl_host_t x... "otbn"}}};")
*** end of partially formatted partition list
[other error status]
hw/vendor/lowrisc_ibex/rtl/ibex_cs_registers.sv: *** Some token partitions failed to complete within the search limit:
>>>>>>[CSR_MCYCLE , CSR_MINSTRET , CSR_MHPMCOUNTER3 , CSR_MHPMCOUNTER4 , CSR_MHPMCOUNTER5 , CSR_MHPMCOUNTER6 , CSR_MHPMCOUNTER7 , CSR_MHPMCOUNTER8 , CSR_MHPMCOUNTER9 , CSR_MHPMCOUNTER10 , CSR_MHPMCOUNTER11 , CSR_MHPMCOUNTER12 , CSR_MHPMCOUNTER13 , CSR_MHPMCOUNTER14 , CSR_MHPMCOUNTER15 , CSR_MHPMCOUNTER16 , CSR_MHPMCOUNTER17 , CSR_MHPMCOUNTER18 , CSR_MHPMCOUNTER19 , CSR_MHPMCOUNTER20 , CSR_MHPMCOUNTER21 , CSR_MHPMCOUNTER22 , CSR_MHPMCOUNTER23 , CSR_MHPMCOUNTER24 , CSR_MHPMCOUNTER25 , CSR_MHPMCOUNTER26 , CSR_MHPMCOUNTER27 , CSR_MHPMCOUNTER28 , CSR_MHPMCOUNTER29 , CSR_MHPMCOUNTER30 , CSR_MHPMCOUNTER31 : begin], policy: fit-else-expand
>>>>>>[CSR_MCYCLEH , CSR_MINSTRETH , CSR_MHPMCOUNTER3H , CSR_MHPMCOUNTER4H , CSR_MHPMCOUNTER5H , CSR_MHPMCOUNTER6H , CSR_MHPMCOUNTER7H , CSR_MHPMCOUNTER8H , CSR_MHPMCOUNTER9H , CSR_MHPMCOUNTER10H , CSR_MHPMCOUNTER11H , CSR_MHPMCOUNTER12H , CSR_MHPMCOUNTER13H , CSR_MHPMCOUNTER14H , CSR_MHPMCOUNTER15H , CSR_MHPMCOUNTER16H , CSR_MHPMCOUNTER17H , CSR_MHPMCOUNTER18H , CSR_MHPMCOUNTER19H , CSR_MHPMCOUNTER20H , CSR_MHPMCOUNTER21H , CSR_MHPMCOUNTER22H , CSR_MHPMCOUNTER23H , CSR_MHPMCOUNTER24H , CSR_MHPMCOUNTER25H , CSR_MHPMCOUNTER26H , CSR_MHPMCOUNTER27H , CSR_MHPMCOUNTER28H , CSR_MHPMCOUNTER29H , CSR_MHPMCOUNTER30H , CSR_MHPMCOUNTER31H : begin], policy: fit-else-expand
>>>>>>>>[CSR_MCYCLE , CSR_MINSTRET , CSR_MHPMCOUNTER3 , CSR_MHPMCOUNTER4 , CSR_MHPMCOUNTER5 , CSR_MHPMCOUNTER6 , CSR_MHPMCOUNTER7 , CSR_MHPMCOUNTER8 , CSR_MHPMCOUNTER9 , CSR_MHPMCOUNTER10 , CSR_MHPMCOUNTER11 , CSR_MHPMCOUNTER12 , CSR_MHPMCOUNTER13 , CSR_MHPMCOUNTER14 , CSR_MHPMCOUNTER15 , CSR_MHPMCOUNTER16 , CSR_MHPMCOUNTER17 , CSR_MHPMCOUNTER18 , CSR_MHPMCOUNTER19 , CSR_MHPMCOUNTER20 , CSR_MHPMCOUNTER21 , CSR_MHPMCOUNTER22 , CSR_MHPMCOUNTER23 , CSR_MHPMCOUNTER24 , CSR_MHPMCOUNTER25 , CSR_MHPMCOUNTER26 , CSR_MHPMCOUNTER27 , CSR_MHPMCOUNTER28 , CSR_MHPMCOUNTER29 , CSR_MHPMCOUNTER30 , CSR_MHPMCOUNTER31 : begin], policy: fit-else-expand
>>>>>>>>[CSR_MCYCLEH , CSR_MINSTRETH , CSR_MHPMCOUNTER3H , CSR_MHPMCOUNTER4H , CSR_MHPMCOUNTER5H , CSR_MHPMCOUNTER6H , CSR_MHPMCOUNTER7H , CSR_MHPMCOUNTER8H , CSR_MHPMCOUNTER9H , CSR_MHPMCOUNTER10H , CSR_MHPMCOUNTER11H , CSR_MHPMCOUNTER12H , CSR_MHPMCOUNTER13H , CSR_MHPMCOUNTER14H , CSR_MHPMCOUNTER15H , CSR_MHPMCOUNTER16H , CSR_MHPMCOUNTER17H , CSR_MHPMCOUNTER18H , CSR_MHPMCOUNTER19H , CSR_MHPMCOUNTER20H , CSR_MHPMCOUNTER21H , CSR_MHPMCOUNTER22H , CSR_MHPMCOUNTER23H , CSR_MHPMCOUNTER24H , CSR_MHPMCOUNTER25H , CSR_MHPMCOUNTER26H , CSR_MHPMCOUNTER27H , CSR_MHPMCOUNTER28H , CSR_MHPMCOUNTER29H , CSR_MHPMCOUNTER30H , CSR_MHPMCOUNTER31H : begin], policy: fit-else-expand
*** end of partially formatted partition list
[other error status]
